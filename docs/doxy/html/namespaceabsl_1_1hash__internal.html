<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>open spiel: absl::hash_internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">open spiel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceabsl.html">absl</a></li><li class="navelem"><a class="el" href="namespaceabsl_1_1hash__internal.html">hash_internal</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">absl::hash_internal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_aggregate_barrier.html">AggregateBarrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_container_as_vector.html">ContainerAsVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_container_as_vector_3_01std_1_1tuple_3_01_t_8_8_8_01_4_01_4.html">ContainerAsVector&lt; std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_container_as_vector_3_01std_1_1tuple_3_4_01_4.html">ContainerAsVector&lt; std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_default_equals.html">DefaultEquals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_eq_visitor.html">EqVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_expand_visitor.html">ExpandVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_hash_impl.html">HashImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_hash_select.html">HashSelect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabsl_1_1hash__internal_1_1_hash_state_base.html">HashStateBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented.html">is_uniquely_represented</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented_3_01bool_01_4.html">is_uniquely_represented&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented_3_01_custom_hash_type_3_01_tags_8_8_8_3c8edc83d75eda6aa80196f190000955.html">is_uniquely_represented&lt; CustomHashType&lt; Tags... &gt;, typename EnableIfContained&lt; InvokeTag::kUniquelyRepresented, Tags... &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented_3_01_integral_00_01typename_01std_1_1e31a1920c348d42de1d205b9cfc0cf24a.html">is_uniquely_represented&lt; Integral, typename std::enable_if&lt; std::is_integral&lt; Integral &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented_3_01unsigned_01char_01_4.html">is_uniquely_represented&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_make_type_set.html">MakeTypeSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_make_type_set_3_01_t_00_01_ts_8_8_8_01_4.html">MakeTypeSet&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabsl_1_1hash__internal_1_1_mixing_hash_state.html">MixingHashState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_odr_use.html">OdrUse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabsl_1_1hash__internal_1_1_piecewise_combiner.html">PiecewiseCombiner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_poisoned_hash.html">PoisonedHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_print_visitor.html">PrintVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_run_on_startup.html">RunOnStartup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html">SpyHashStateImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_type_set.html">TypeSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsl_1_1hash__internal_1_1_variant_visitor.html">VariantVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2055a3c56eb8f8ba123f105f639782e8" id="r_a2055a3c56eb8f8ba123f105f639782e8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a2055a3c56eb8f8ba123f105f639782e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2055a3c56eb8f8ba123f105f639782e8">VariantForTypes</a></td></tr>
<tr class="separator:a2055a3c56eb8f8ba123f105f639782e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb752656767e96b5117d7698dcab913" id="r_a2cb752656767e96b5117d7698dcab913"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb752656767e96b5117d7698dcab913">SpyHashState</a> = <a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html">SpyHashStateImpl</a>&lt;void&gt;</td></tr>
<tr class="separator:a2cb752656767e96b5117d7698dcab913"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa4f5bf8fd7a4ceabb447e385f62068a1" id="r_aa4f5bf8fd7a4ceabb447e385f62068a1"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Eq &gt; </td></tr>
<tr class="memitem:aa4f5bf8fd7a4ceabb447e385f62068a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#ad3388ffb9a4b2443a11d3ab2dee6ef4e">ABSL_MUST_USE_RESULT</a> testing::AssertionResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4f5bf8fd7a4ceabb447e385f62068a1">VerifyTypeImplementsAbslHashCorrectly</a> (const Container &amp;values, Eq equals)</td></tr>
<tr class="separator:aa4f5bf8fd7a4ceabb447e385f62068a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e099ea4c363c004555aa1cfc4e7f777" id="r_a3e099ea4c363c004555aa1cfc4e7f777"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e099ea4c363c004555aa1cfc4e7f777">CityHash32</a> (const char *<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>, size_t <a class="el" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>)</td></tr>
<tr class="separator:a3e099ea4c363c004555aa1cfc4e7f777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1da018501bd61ed957b52398e085c8f" id="r_ab1da018501bd61ed957b52398e085c8f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1da018501bd61ed957b52398e085c8f">CityHash64</a> (const char *<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>, size_t <a class="el" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>)</td></tr>
<tr class="separator:ab1da018501bd61ed957b52398e085c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68505edf296a496957b8284926f8828f" id="r_a68505edf296a496957b8284926f8828f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68505edf296a496957b8284926f8828f">CityHash64WithSeed</a> (const char *<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>, size_t <a class="el" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>, uint64_t seed)</td></tr>
<tr class="separator:a68505edf296a496957b8284926f8828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e59ea59852b67aad22cbd4634340952" id="r_a8e59ea59852b67aad22cbd4634340952"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e59ea59852b67aad22cbd4634340952">CityHash64WithSeeds</a> (const char *<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>, size_t <a class="el" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>, uint64_t seed0, uint64_t seed1)</td></tr>
<tr class="separator:a8e59ea59852b67aad22cbd4634340952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d2040071eac12e8c09824e6ae27d67" id="r_a48d2040071eac12e8c09824e6ae27d67"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48d2040071eac12e8c09824e6ae27d67">PiecewiseChunkSize</a> ()</td></tr>
<tr class="separator:a48d2040071eac12e8c09824e6ae27d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57eec8498f929d0a5ed8623e3ceef7da" id="r_a57eec8498f929d0a5ed8623e3ceef7da"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:a57eec8498f929d0a5ed8623e3ceef7da"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57eec8498f929d0a5ed8623e3ceef7da">hash_bytes</a> (H hash_state, const T &amp;value)</td></tr>
<tr class="separator:a57eec8498f929d0a5ed8623e3ceef7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1818b140c04152893dc5312994c657aa" id="r_a1818b140c04152893dc5312994c657aa"><td class="memTemplParams" colspan="2">template&lt;typename H , typename B &gt; </td></tr>
<tr class="memitem:a1818b140c04152893dc5312994c657aa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; B, bool &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1818b140c04152893dc5312994c657aa">AbslHashValue</a> (H hash_state, B value)</td></tr>
<tr class="separator:a1818b140c04152893dc5312994c657aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221db7a4bf11c111ba020220207ad74c" id="r_a221db7a4bf11c111ba020220207ad74c"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Enum &gt; </td></tr>
<tr class="memitem:a221db7a4bf11c111ba020220207ad74c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_enum&lt; Enum &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a221db7a4bf11c111ba020220207ad74c">AbslHashValue</a> (H hash_state, Enum <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acae1671797c52e15f763380b45e841ec32">e</a>)</td></tr>
<tr class="separator:a221db7a4bf11c111ba020220207ad74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bc1ac44a4f7dd32453282a8619b17d" id="r_ac3bc1ac44a4f7dd32453282a8619b17d"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Float &gt; </td></tr>
<tr class="memitem:ac3bc1ac44a4f7dd32453282a8619b17d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; Float, float &gt;::value||std::is_same&lt; Float, double &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3bc1ac44a4f7dd32453282a8619b17d">AbslHashValue</a> (H hash_state, Float value)</td></tr>
<tr class="separator:ac3bc1ac44a4f7dd32453282a8619b17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173309951d32772a7410018e15ac502" id="r_a1173309951d32772a7410018e15ac502"><td class="memTemplParams" colspan="2">template&lt;typename H , typename LongDouble &gt; </td></tr>
<tr class="memitem:a1173309951d32772a7410018e15ac502"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; LongDouble, longdouble &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1173309951d32772a7410018e15ac502">AbslHashValue</a> (H hash_state, LongDouble value)</td></tr>
<tr class="separator:a1173309951d32772a7410018e15ac502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc817f287dc6bffb9c5c547cd976735" id="r_a5cc817f287dc6bffb9c5c547cd976735"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:a5cc817f287dc6bffb9c5c547cd976735"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cc817f287dc6bffb9c5c547cd976735">AbslHashValue</a> (H hash_state, T *<a class="el" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>)</td></tr>
<tr class="separator:a5cc817f287dc6bffb9c5c547cd976735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c8a2cb204f7e8d7c867923cb9159a" id="r_a7c7c8a2cb204f7e8d7c867923cb9159a"><td class="memTemplParams" colspan="2">template&lt;typename H &gt; </td></tr>
<tr class="memitem:a7c7c8a2cb204f7e8d7c867923cb9159a"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c7c8a2cb204f7e8d7c867923cb9159a">AbslHashValue</a> (H hash_state, std::nullptr_t)</td></tr>
<tr class="separator:a7c7c8a2cb204f7e8d7c867923cb9159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed7e88d20984cb3327b61eab436a273" id="r_a2ed7e88d20984cb3327b61eab436a273"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename <a class="el" href="city__test_8cc.html#ac54ae397901fe700628cafadea3c5208">C</a> &gt; </td></tr>
<tr class="memitem:a2ed7e88d20984cb3327b61eab436a273"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ed7e88d20984cb3327b61eab436a273">AbslHashValue</a> (H hash_state, T C::*<a class="el" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>)</td></tr>
<tr class="separator:a2ed7e88d20984cb3327b61eab436a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9bde41e3f3a59e23d79d4fc0a9f2b1" id="r_a2d9bde41e3f3a59e23d79d4fc0a9f2b1"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2d9bde41e3f3a59e23d79d4fc0a9f2b1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T2 &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d9bde41e3f3a59e23d79d4fc0a9f2b1">AbslHashValue</a> (H hash_state, const std::pair&lt; T1, T2 &gt; &amp;<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca83878c91171338902e0fe0fb97a8c47a">p</a>)</td></tr>
<tr class="separator:a2d9bde41e3f3a59e23d79d4fc0a9f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548044220cbac0d63276446f15777208" id="r_a548044220cbac0d63276446f15777208"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Tuple , size_t... Is&gt; </td></tr>
<tr class="memitem:a548044220cbac0d63276446f15777208"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a548044220cbac0d63276446f15777208">hash_tuple</a> (H hash_state, const Tuple &amp;t, <a class="el" href="namespaceabsl.html#ad87d6a123442e30a05fa3204aee60f60">absl::index_sequence</a>&lt; Is... &gt;)</td></tr>
<tr class="separator:a548044220cbac0d63276446f15777208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca07bce0d8952a1bf82d7fb81654c3a" id="r_a7ca07bce0d8952a1bf82d7fb81654c3a"><td class="memTemplParams" colspan="2">template&lt;typename H , typename... Ts&gt; </td></tr>
<tr class="memitem:a7ca07bce0d8952a1bf82d7fb81654c3a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1conjunction.html">absl::conjunction</a>&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Ts &gt;... &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ca07bce0d8952a1bf82d7fb81654c3a">AbslHashValue</a> (H hash_state, const std::tuple&lt; Ts... &gt; &amp;t)</td></tr>
<tr class="separator:a7ca07bce0d8952a1bf82d7fb81654c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a87e0dfdd9ee9c04f61006b960fc92" id="r_a55a87e0dfdd9ee9c04f61006b960fc92"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename D &gt; </td></tr>
<tr class="memitem:a55a87e0dfdd9ee9c04f61006b960fc92"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55a87e0dfdd9ee9c04f61006b960fc92">AbslHashValue</a> (H hash_state, const std::unique_ptr&lt; T, D &gt; &amp;<a class="el" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>)</td></tr>
<tr class="separator:a55a87e0dfdd9ee9c04f61006b960fc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae261d509d7730a982dbcc5d645f22891" id="r_ae261d509d7730a982dbcc5d645f22891"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:ae261d509d7730a982dbcc5d645f22891"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae261d509d7730a982dbcc5d645f22891">AbslHashValue</a> (H hash_state, const std::shared_ptr&lt; T &gt; &amp;<a class="el" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>)</td></tr>
<tr class="separator:ae261d509d7730a982dbcc5d645f22891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053db7fdbe08069af1a9d2ccec2f67bb" id="r_a053db7fdbe08069af1a9d2ccec2f67bb"><td class="memTemplParams" colspan="2">template&lt;typename H &gt; </td></tr>
<tr class="memitem:a053db7fdbe08069af1a9d2ccec2f67bb"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a053db7fdbe08069af1a9d2ccec2f67bb">AbslHashValue</a> (H hash_state, <a class="el" href="classabsl_1_1string__view.html">absl::string_view</a> str)</td></tr>
<tr class="separator:a053db7fdbe08069af1a9d2ccec2f67bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bfab8278240293acc83094e759a670" id="r_ab6bfab8278240293acc83094e759a670"><td class="memTemplParams" colspan="2">template&lt;typename Char , typename Alloc , typename H , typename  = absl::enable_if_t&lt;std::is_same&lt;Char, wchar_t&gt;::value ||                                       std::is_same&lt;Char, char16_t&gt;::value ||                                       std::is_same&lt;Char, char32_t&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab6bfab8278240293acc83094e759a670"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6bfab8278240293acc83094e759a670">AbslHashValue</a> (H hash_state, const std::basic_string&lt; Char, std::char_traits&lt; Char &gt;, Alloc &gt; &amp;str)</td></tr>
<tr class="separator:ab6bfab8278240293acc83094e759a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0462072fdf8c97ba9a25cfef24b58f06" id="r_a0462072fdf8c97ba9a25cfef24b58f06"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , size_t N&gt; </td></tr>
<tr class="memitem:a0462072fdf8c97ba9a25cfef24b58f06"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0462072fdf8c97ba9a25cfef24b58f06">AbslHashValue</a> (H hash_state, const std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="separator:a0462072fdf8c97ba9a25cfef24b58f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace577c5bcfc639b44df83e7bcd270d2d" id="r_ace577c5bcfc639b44df83e7bcd270d2d"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:ace577c5bcfc639b44df83e7bcd270d2d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace577c5bcfc639b44df83e7bcd270d2d">AbslHashValue</a> (H hash_state, const std::deque&lt; T, Allocator &gt; &amp;deque)</td></tr>
<tr class="separator:ace577c5bcfc639b44df83e7bcd270d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33cfad301d1c65b6b0460a5469bdc2b" id="r_ad33cfad301d1c65b6b0460a5469bdc2b"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:ad33cfad301d1c65b6b0460a5469bdc2b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad33cfad301d1c65b6b0460a5469bdc2b">AbslHashValue</a> (H hash_state, const std::forward_list&lt; T, Allocator &gt; &amp;list)</td></tr>
<tr class="separator:ad33cfad301d1c65b6b0460a5469bdc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4155dd1af78fc586e6ea7db45e157ad0" id="r_a4155dd1af78fc586e6ea7db45e157ad0"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a4155dd1af78fc586e6ea7db45e157ad0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4155dd1af78fc586e6ea7db45e157ad0">AbslHashValue</a> (H hash_state, const std::list&lt; T, Allocator &gt; &amp;list)</td></tr>
<tr class="separator:a4155dd1af78fc586e6ea7db45e157ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a7b8f4a22479a56f5cc63e93ac146e" id="r_af9a7b8f4a22479a56f5cc63e93ac146e"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:af9a7b8f4a22479a56f5cc63e93ac146e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9a7b8f4a22479a56f5cc63e93ac146e">AbslHashValue</a> (H hash_state, const std::vector&lt; T, Allocator &gt; &amp;vector)</td></tr>
<tr class="separator:af9a7b8f4a22479a56f5cc63e93ac146e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8c0d545dbfa7047d2a5aa33ef48fbe" id="r_a2b8c0d545dbfa7047d2a5aa33ef48fbe"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a2b8c0d545dbfa7047d2a5aa33ef48fbe"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value &amp;&amp;std::is_same&lt; T, bool &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b8c0d545dbfa7047d2a5aa33ef48fbe">AbslHashValue</a> (H hash_state, const std::vector&lt; T, Allocator &gt; &amp;vector)</td></tr>
<tr class="separator:a2b8c0d545dbfa7047d2a5aa33ef48fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa4455b2262c895c27662952dc1e77f" id="r_a0aa4455b2262c895c27662952dc1e77f"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename T , typename Compare , typename Allocator &gt; </td></tr>
<tr class="memitem:a0aa4455b2262c895c27662952dc1e77f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0aa4455b2262c895c27662952dc1e77f">AbslHashValue</a> (H hash_state, const std::map&lt; Key, T, Compare, Allocator &gt; &amp;map)</td></tr>
<tr class="separator:a0aa4455b2262c895c27662952dc1e77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b530aa3cab81105bd1810371ec8a3bd" id="r_a8b530aa3cab81105bd1810371ec8a3bd"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename T , typename Compare , typename Allocator &gt; </td></tr>
<tr class="memitem:a8b530aa3cab81105bd1810371ec8a3bd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b530aa3cab81105bd1810371ec8a3bd">AbslHashValue</a> (H hash_state, const std::multimap&lt; Key, T, Compare, Allocator &gt; &amp;map)</td></tr>
<tr class="separator:a8b530aa3cab81105bd1810371ec8a3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dfa2dffcbcc492704a85e1b87899b9" id="r_a31dfa2dffcbcc492704a85e1b87899b9"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename Compare , typename Allocator &gt; </td></tr>
<tr class="memitem:a31dfa2dffcbcc492704a85e1b87899b9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a31dfa2dffcbcc492704a85e1b87899b9">AbslHashValue</a> (H hash_state, const std::set&lt; Key, Compare, Allocator &gt; &amp;set)</td></tr>
<tr class="separator:a31dfa2dffcbcc492704a85e1b87899b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756ceae5b535f9d2328dc2f190363035" id="r_a756ceae5b535f9d2328dc2f190363035"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename Compare , typename Allocator &gt; </td></tr>
<tr class="memitem:a756ceae5b535f9d2328dc2f190363035"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a756ceae5b535f9d2328dc2f190363035">AbslHashValue</a> (H hash_state, const std::multiset&lt; Key, Compare, Allocator &gt; &amp;set)</td></tr>
<tr class="separator:a756ceae5b535f9d2328dc2f190363035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb52c3b968b6302e8bede96bd0d8c03" id="r_a8fb52c3b968b6302e8bede96bd0d8c03"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </td></tr>
<tr class="memitem:a8fb52c3b968b6302e8bede96bd0d8c03"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8fb52c3b968b6302e8bede96bd0d8c03">AbslHashValue</a> (H hash_state, const std::unordered_set&lt; Key, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>)</td></tr>
<tr class="separator:a8fb52c3b968b6302e8bede96bd0d8c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae211afb3f7b8a608fc32d7654e61bf56" id="r_ae211afb3f7b8a608fc32d7654e61bf56"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </td></tr>
<tr class="memitem:ae211afb3f7b8a608fc32d7654e61bf56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae211afb3f7b8a608fc32d7654e61bf56">AbslHashValue</a> (H hash_state, const std::unordered_multiset&lt; Key, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>)</td></tr>
<tr class="separator:ae211afb3f7b8a608fc32d7654e61bf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d26f97a0cf592ce89640a8fdb842d0d" id="r_a4d26f97a0cf592ce89640a8fdb842d0d"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename T , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </td></tr>
<tr class="memitem:a4d26f97a0cf592ce89640a8fdb842d0d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d26f97a0cf592ce89640a8fdb842d0d">AbslHashValue</a> (H hash_state, const std::unordered_map&lt; Key, T, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>)</td></tr>
<tr class="separator:a4d26f97a0cf592ce89640a8fdb842d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa50083eb9a7344f1fb1e5fa3ec9d44" id="r_aefa50083eb9a7344f1fb1e5fa3ec9d44"><td class="memTemplParams" colspan="2">template&lt;typename H , typename Key , typename T , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </td></tr>
<tr class="memitem:aefa50083eb9a7344f1fb1e5fa3ec9d44"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefa50083eb9a7344f1fb1e5fa3ec9d44">AbslHashValue</a> (H hash_state, const std::unordered_multimap&lt; Key, T, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>)</td></tr>
<tr class="separator:aefa50083eb9a7344f1fb1e5fa3ec9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc220536fdfb0b020b608547dd23a66" id="r_accc220536fdfb0b020b608547dd23a66"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:accc220536fdfb0b020b608547dd23a66"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accc220536fdfb0b020b608547dd23a66">AbslHashValue</a> (H hash_state, std::reference_wrapper&lt; T &gt; opt)</td></tr>
<tr class="separator:accc220536fdfb0b020b608547dd23a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e1fe8e88fc54f69665b9d5a4419d53" id="r_a08e1fe8e88fc54f69665b9d5a4419d53"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:a08e1fe8e88fc54f69665b9d5a4419d53"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08e1fe8e88fc54f69665b9d5a4419d53">AbslHashValue</a> (H hash_state, const <a class="el" href="classabsl_1_1optional.html">absl::optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a08e1fe8e88fc54f69665b9d5a4419d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532b21e98160dcdec2b8965b6c2e3ae2" id="r_a532b21e98160dcdec2b8965b6c2e3ae2"><td class="memTemplParams" colspan="2">template&lt;typename H , typename... T&gt; </td></tr>
<tr class="memitem:a532b21e98160dcdec2b8965b6c2e3ae2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1conjunction.html">conjunction</a>&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;... &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a532b21e98160dcdec2b8965b6c2e3ae2">AbslHashValue</a> (H hash_state, const <a class="el" href="classabsl_1_1variant.html">absl::variant</a>&lt; T... &gt; &amp;<a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>)</td></tr>
<tr class="separator:a532b21e98160dcdec2b8965b6c2e3ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4639e60aa5d17afc706672233c957617" id="r_a4639e60aa5d17afc706672233c957617"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:a4639e60aa5d17afc706672233c957617"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented.html">is_uniquely_represented</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4639e60aa5d17afc706672233c957617">hash_range_or_bytes</a> (H hash_state, const T *data, size_t <a class="el" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a>)</td></tr>
<tr class="separator:a4639e60aa5d17afc706672233c957617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820cfc106c1c28816489a68864742b73" id="r_a820cfc106c1c28816489a68864742b73"><td class="memTemplParams" colspan="2">template&lt;typename H , typename T &gt; </td></tr>
<tr class="memitem:a820cfc106c1c28816489a68864742b73"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented.html">is_uniquely_represented</a>&lt; T &gt;::value, H &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a820cfc106c1c28816489a68864742b73">hash_range_or_bytes</a> (H hash_state, const T *data, size_t <a class="el" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a>)</td></tr>
<tr class="separator:a820cfc106c1c28816489a68864742b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb8400f869e77be8b51039426cb207b" id="r_aefb8400f869e77be8b51039426cb207b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb8400f869e77be8b51039426cb207b">LowLevelHash</a> (const void *data, size_t <a class="el" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>, uint64_t seed, const uint64_t salt[5])</td></tr>
<tr class="separator:aefb8400f869e77be8b51039426cb207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a06780435d5ce87c7f67047a1c2cb0" id="r_a00a06780435d5ce87c7f67047a1c2cb0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename  = absl::enable_if_t&lt;!std::is_same&lt;T, U&gt;::value&gt;, int  = RunOnStartup&lt;SpyHashStateImpl&lt;T&gt;::SetDirectAbslHashValueError&gt;::run&gt; </td></tr>
<tr class="memitem:a00a06780435d5ce87c7f67047a1c2cb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00a06780435d5ce87c7f67047a1c2cb0">AbslHashValue</a> (<a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html">SpyHashStateImpl</a>&lt; T &gt;, const U &amp;)</td></tr>
<tr class="separator:a00a06780435d5ce87c7f67047a1c2cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a43eef7e0755ad391094c5e0f19910714" id="r_a43eef7e0755ad391094c5e0f19910714"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43eef7e0755ad391094c5e0f19910714">kHashSalt</a> [5]</td></tr>
<tr class="separator:a43eef7e0755ad391094c5e0f19910714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2cb752656767e96b5117d7698dcab913" name="a2cb752656767e96b5117d7698dcab913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb752656767e96b5117d7698dcab913">&#9670;&#160;</a></span>SpyHashState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2cb752656767e96b5117d7698dcab913">absl::hash_internal::SpyHashState</a> = <a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html">SpyHashStateImpl</a>&lt;void&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="spy__hash__state_8h_source.html#l00260">260</a> of file <a class="el" href="spy__hash__state_8h_source.html">spy_hash_state.h</a>.</p>

</div>
</div>
<a id="a2055a3c56eb8f8ba123f105f639782e8" name="a2055a3c56eb8f8ba123f105f639782e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2055a3c56eb8f8ba123f105f639782e8">&#9670;&#160;</a></span>VariantForTypes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2055a3c56eb8f8ba123f105f639782e8">absl::hash_internal::VariantForTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <span class="keyword">typename</span> MakeTypeSet&lt;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> std::decay&lt;T&gt;::type*...&gt;::template <a class="code hl_variable" href="hash__policy__traits__test_8cc.html#ae678cc9e768190695b10aa9f37166c73">apply&lt;absl::variant&gt;</a></div>
<div class="ttc" id="ahash__policy__traits__test_8cc_html_ae678cc9e768190695b10aa9f37166c73"><div class="ttname"><a href="hash__policy__traits__test_8cc.html#ae678cc9e768190695b10aa9f37166c73">apply</a></div><div class="ttdeci">MockFunction&lt; int(int)&gt; apply</div><div class="ttdef"><b>Definition</b> <a href="hash__policy__traits__test_8cc_source.html#l00062">hash_policy_traits_test.cc:62</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="hash__testing_8h_source.html#l00299">299</a> of file <a class="el" href="hash__testing_8h_source.html">hash_testing.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a053db7fdbe08069af1a9d2ccec2f67bb" name="a053db7fdbe08069af1a9d2ccec2f67bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053db7fdbe08069af1a9d2ccec2f67bb">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[1/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classabsl_1_1string__view.html">absl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00528">528</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  528</span>                                                   {</div>
<div class="line"><span class="lineno">  529</span>  <span class="keywordflow">return</span> H::combine(</div>
<div class="line"><span class="lineno">  530</span>      H::combine_contiguous(std::move(hash_state), str.data(), str.size()),</div>
<div class="line"><span class="lineno">  531</span>      str.size());</div>
<div class="line"><span class="lineno">  532</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1818b140c04152893dc5312994c657aa" name="a1818b140c04152893dc5312994c657aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1818b140c04152893dc5312994c657aa">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[2/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; B, bool &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00345">345</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  346</span>                           {</div>
<div class="line"><span class="lineno">  347</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state),</div>
<div class="line"><span class="lineno">  348</span>                    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(value ? 1 : 0));</div>
<div class="line"><span class="lineno">  349</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a08e1fe8e88fc54f69665b9d5a4419d53" name="a08e1fe8e88fc54f69665b9d5a4419d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e1fe8e88fc54f69665b9d5a4419d53">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[3/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classabsl_1_1optional.html">absl::optional</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00756">756</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  757</span>                                              {</div>
<div class="line"><span class="lineno">  758</span>  <span class="keywordflow">if</span> (opt) hash_state = H::combine(std::move(hash_state), *opt);</div>
<div class="line"><span class="lineno">  759</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), opt.<a class="code hl_function" href="classabsl_1_1optional.html#a555a8b13b6842ed5f7b1de07f1b42162">has_value</a>());</div>
<div class="line"><span class="lineno">  760</span>}</div>
<div class="ttc" id="aclassabsl_1_1optional_html_a555a8b13b6842ed5f7b1de07f1b42162"><div class="ttname"><a href="classabsl_1_1optional.html#a555a8b13b6842ed5f7b1de07f1b42162">absl::optional::has_value</a></div><div class="ttdeci">constexpr bool has_value() const noexcept</div><div class="ttdef"><b>Definition</b> <a href="optional_8h_source.html#l00461">optional.h:461</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="optional_8h_source.html#l00461">absl::optional&lt; T &gt;::has_value()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a08e1fe8e88fc54f69665b9d5a4419d53_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a08e1fe8e88fc54f69665b9d5a4419d53_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a08e1fe8e88fc54f69665b9d5a4419d53_cgraph" id="anamespaceabsl_1_1hash__internal_a08e1fe8e88fc54f69665b9d5a4419d53_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,136,46"/>
<area shape="rect" href="classabsl_1_1optional.html#a555a8b13b6842ed5f7b1de07f1b42162" title=" " alt="" coords="184,5,311,46"/>
<area shape="poly" title=" " alt="" coords="136,23,168,23,168,28,136,28"/>
</map>
</div>

</div>
</div>
<a id="a532b21e98160dcdec2b8965b6c2e3ae2" name="a532b21e98160dcdec2b8965b6c2e3ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532b21e98160dcdec2b8965b6c2e3ae2">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[4/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1conjunction.html">conjunction</a>&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;... &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classabsl_1_1variant.html">absl::variant</a>&lt; T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00775">775</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  775</span>                                                        {</div>
<div class="line"><span class="lineno">  776</span>  <span class="keywordflow">if</span> (!<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.valueless_by_exception()) {</div>
<div class="line"><span class="lineno">  777</span>    hash_state = <a class="code hl_function" href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92">absl::visit</a>(<a class="code hl_struct" href="structabsl_1_1hash__internal_1_1_variant_visitor.html">VariantVisitor&lt;H&gt;</a>{std::move(hash_state)}, <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>);</div>
<div class="line"><span class="lineno">  778</span>  }</div>
<div class="line"><span class="lineno">  779</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), v.index());</div>
<div class="line"><span class="lineno">  780</span>}</div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">absl::FormatConversionChar::v</a></div><div class="ttdeci">@ v</div></div>
<div class="ttc" id="anamespaceabsl_html_ae516527e96422ca1eb82d851b1b9fe92"><div class="ttname"><a href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92">absl::visit</a></div><div class="ttdeci">variant_internal::VisitResult&lt; Visitor, Variants... &gt; visit(Visitor &amp;&amp;vis, Variants &amp;&amp;... vars)</div><div class="ttdef"><b>Definition</b> <a href="variant_8h_source.html#l00430">variant.h:430</a></div></div>
<div class="ttc" id="astructabsl_1_1hash__internal_1_1_variant_visitor_html"><div class="ttname"><a href="structabsl_1_1hash__internal_1_1_variant_visitor.html">absl::hash_internal::VariantVisitor</a></div><div class="ttdef"><b>Definition</b> <a href="internal_2hash_8h_source.html#l00764">hash.h:764</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">absl::v</a>, and <a class="el" href="variant_8h_source.html#l00430">absl::visit()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a532b21e98160dcdec2b8965b6c2e3ae2_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a532b21e98160dcdec2b8965b6c2e3ae2_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a532b21e98160dcdec2b8965b6c2e3ae2_cgraph" id="anamespaceabsl_1_1hash__internal_a532b21e98160dcdec2b8965b6c2e3ae2_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,136,46"/>
<area shape="rect" href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92" title=" " alt="" coords="184,13,261,38"/>
<area shape="poly" title=" " alt="" coords="136,23,168,23,168,28,136,28"/>
<area shape="rect" href="namespaceabsl.html#a03ebb53df1ff18fef1fe76732a670187" title=" " alt="" coords="309,13,405,38"/>
<area shape="poly" title=" " alt="" coords="262,23,293,23,293,28,262,28"/>
</map>
</div>

</div>
</div>
<a id="a0462072fdf8c97ba9a25cfef24b58f06" name="a0462072fdf8c97ba9a25cfef24b58f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0462072fdf8c97ba9a25cfef24b58f06">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[5/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00553">553</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  554</span>                                               {</div>
<div class="line"><span class="lineno">  555</span>  <span class="keywordflow">return</span> H::combine_contiguous(std::move(hash_state), array.data(),</div>
<div class="line"><span class="lineno">  556</span>                               array.size());</div>
<div class="line"><span class="lineno">  557</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab6bfab8278240293acc83094e759a670" name="ab6bfab8278240293acc83094e759a670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bfab8278240293acc83094e759a670">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[6/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , typename Alloc , typename H , typename  = absl::enable_if_t&lt;std::is_same&lt;Char, wchar_t&gt;::value ||                                       std::is_same&lt;Char, char16_t&gt;::value ||                                       std::is_same&lt;Char, char32_t&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; Char, std::char_traits&lt; Char &gt;, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00539">539</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  541</span>                                                                   {</div>
<div class="line"><span class="lineno">  542</span>  <span class="keywordflow">return</span> H::combine(</div>
<div class="line"><span class="lineno">  543</span>      H::combine_contiguous(std::move(hash_state), str.data(), str.size()),</div>
<div class="line"><span class="lineno">  544</span>      str.size());</div>
<div class="line"><span class="lineno">  545</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ace577c5bcfc639b44df83e7bcd270d2d" name="ace577c5bcfc639b44df83e7bcd270d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace577c5bcfc639b44df83e7bcd270d2d">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[7/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::deque&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>deque</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00561">561</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  562</span>                                                       {</div>
<div class="line"><span class="lineno">  563</span>  <span class="comment">// TODO(gromer): investigate a more efficient implementation taking</span></div>
<div class="line"><span class="lineno">  564</span>  <span class="comment">// advantage of the chunk structure.</span></div>
<div class="line"><span class="lineno">  565</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : deque) {</div>
<div class="line"><span class="lineno">  566</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  567</span>  }</div>
<div class="line"><span class="lineno">  568</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), deque.size());</div>
<div class="line"><span class="lineno">  569</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad33cfad301d1c65b6b0460a5469bdc2b" name="ad33cfad301d1c65b6b0460a5469bdc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33cfad301d1c65b6b0460a5469bdc2b">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[8/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::forward_list&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00573">573</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  574</span>                                                             {</div>
<div class="line"><span class="lineno">  575</span>  <span class="keywordtype">size_t</span> <a class="code hl_variable" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a> = 0;</div>
<div class="line"><span class="lineno">  576</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> T&amp; t : list) {</div>
<div class="line"><span class="lineno">  577</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  578</span>    ++<a class="code hl_variable" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a>;</div>
<div class="line"><span class="lineno">  579</span>  }</div>
<div class="line"><span class="lineno">  580</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), <a class="code hl_variable" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a>);</div>
<div class="line"><span class="lineno">  581</span>}</div>
<div class="ttc" id="alow__level__alloc_8cc_html_aad9b71a31372d5c0ab9c23163efe9544"><div class="ttname"><a href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a></div><div class="ttdeci">uintptr_t size</div><div class="ttdef"><b>Definition</b> <a href="low__level__alloc_8cc_source.html#l00080">low_level_alloc.cc:80</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="low__level__alloc_8cc_source.html#l00080">size</a>.</p>

</div>
</div>
<a id="a4155dd1af78fc586e6ea7db45e157ad0" name="a4155dd1af78fc586e6ea7db45e157ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4155dd1af78fc586e6ea7db45e157ad0">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[9/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00585">585</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  586</span>                                                     {</div>
<div class="line"><span class="lineno">  587</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : list) {</div>
<div class="line"><span class="lineno">  588</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  589</span>  }</div>
<div class="line"><span class="lineno">  590</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), list.size());</div>
<div class="line"><span class="lineno">  591</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0aa4455b2262c895c27662952dc1e77f" name="a0aa4455b2262c895c27662952dc1e77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa4455b2262c895c27662952dc1e77f">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[10/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename T , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, T, Compare, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00654">654</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  654</span>                                                                           {</div>
<div class="line"><span class="lineno">  655</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : map) {</div>
<div class="line"><span class="lineno">  656</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  657</span>  }</div>
<div class="line"><span class="lineno">  658</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), map.size());</div>
<div class="line"><span class="lineno">  659</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b530aa3cab81105bd1810371ec8a3bd" name="a8b530aa3cab81105bd1810371ec8a3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b530aa3cab81105bd1810371ec8a3bd">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[11/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename T , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; Key, T, Compare, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00666">666</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  667</span>                                                                  {</div>
<div class="line"><span class="lineno">  668</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : map) {</div>
<div class="line"><span class="lineno">  669</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  670</span>  }</div>
<div class="line"><span class="lineno">  671</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), map.size());</div>
<div class="line"><span class="lineno">  672</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a756ceae5b535f9d2328dc2f190363035" name="a756ceae5b535f9d2328dc2f190363035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756ceae5b535f9d2328dc2f190363035">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[12/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multiset&lt; Key, Compare, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00686">686</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  687</span>                                                                   {</div>
<div class="line"><span class="lineno">  688</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : set) {</div>
<div class="line"><span class="lineno">  689</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  690</span>  }</div>
<div class="line"><span class="lineno">  691</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), set.size());</div>
<div class="line"><span class="lineno">  692</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2d9bde41e3f3a59e23d79d4fc0a9f2b1" name="a2d9bde41e3f3a59e23d79d4fc0a9f2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9bde41e3f3a59e23d79d4fc0a9f2b1">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[13/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T2 &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00466">466</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  466</span>                                                      {</div>
<div class="line"><span class="lineno">  467</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca83878c91171338902e0fe0fb97a8c47a">p</a>.first, <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca83878c91171338902e0fe0fb97a8c47a">p</a>.second);</div>
<div class="line"><span class="lineno">  468</span>}</div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca83878c91171338902e0fe0fb97a8c47a"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca83878c91171338902e0fe0fb97a8c47a">absl::FormatConversionChar::p</a></div><div class="ttdeci">@ p</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca83878c91171338902e0fe0fb97a8c47a">absl::p</a>.</p>

</div>
</div>
<a id="a31dfa2dffcbcc492704a85e1b87899b9" name="a31dfa2dffcbcc492704a85e1b87899b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dfa2dffcbcc492704a85e1b87899b9">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[14/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Key, Compare, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00676">676</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  677</span>                                                              {</div>
<div class="line"><span class="lineno">  678</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : set) {</div>
<div class="line"><span class="lineno">  679</span>    hash_state = H::combine(std::move(hash_state), t);</div>
<div class="line"><span class="lineno">  680</span>  }</div>
<div class="line"><span class="lineno">  681</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), set.size());</div>
<div class="line"><span class="lineno">  682</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae261d509d7730a982dbcc5d645f22891" name="ae261d509d7730a982dbcc5d645f22891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae261d509d7730a982dbcc5d645f22891">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[15/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00505">505</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  505</span>                                                           {</div>
<div class="line"><span class="lineno">  506</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>.get());</div>
<div class="line"><span class="lineno">  507</span>}</div>
<div class="ttc" id="alow__level__alloc__test_8cc_html_a935adc2e417a61d7eb6f04efb18ba031"><div class="ttname"><a href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a></div><div class="ttdeci">char * ptr</div><div class="ttdef"><b>Definition</b> <a href="low__level__alloc__test_8cc_source.html#l00045">low_level_alloc_test.cc:45</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="low__level__alloc__test_8cc_source.html#l00045">ptr</a>.</p>

</div>
</div>
<a id="a7ca07bce0d8952a1bf82d7fb81654c3a" name="a7ca07bce0d8952a1bf82d7fb81654c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca07bce0d8952a1bf82d7fb81654c3a">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[16/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1conjunction.html">absl::conjunction</a>&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Ts &gt;... &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00488">488</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  488</span>                                                      {</div>
<div class="line"><span class="lineno">  489</span>  <span class="keywordflow">return</span> hash_internal::hash_tuple(std::move(hash_state), t,</div>
<div class="line"><span class="lineno">  490</span>                                   <a class="code hl_typedef" href="namespaceabsl.html#a96eff94f564552ec5e225e71487e81c9">absl::make_index_sequence</a>&lt;<span class="keyword">sizeof</span>...(Ts)&gt;());</div>
<div class="line"><span class="lineno">  491</span>}</div>
<div class="ttc" id="anamespaceabsl_html_a96eff94f564552ec5e225e71487e81c9"><div class="ttname"><a href="namespaceabsl.html#a96eff94f564552ec5e225e71487e81c9">absl::make_index_sequence</a></div><div class="ttdeci">make_integer_sequence&lt; size_t, N &gt; make_index_sequence</div><div class="ttdef"><b>Definition</b> <a href="utility_8h_source.html#l00150">utility.h:150</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="internal_2hash_8h_source.html#l00475">hash_tuple()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a7ca07bce0d8952a1bf82d7fb81654c3a_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a7ca07bce0d8952a1bf82d7fb81654c3a_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a7ca07bce0d8952a1bf82d7fb81654c3a_cgraph" id="anamespaceabsl_1_1hash__internal_a7ca07bce0d8952a1bf82d7fb81654c3a_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,136,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a548044220cbac0d63276446f15777208" title=" " alt="" coords="184,5,314,46"/>
<area shape="poly" title=" " alt="" coords="136,23,168,23,168,28,136,28"/>
</map>
</div>

</div>
</div>
<a id="a55a87e0dfdd9ee9c04f61006b960fc92" name="a55a87e0dfdd9ee9c04f61006b960fc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a87e0dfdd9ee9c04f61006b960fc92">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[17/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00499">499</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  499</span>                                                              {</div>
<div class="line"><span class="lineno">  500</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>.get());</div>
<div class="line"><span class="lineno">  501</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="low__level__alloc__test_8cc_source.html#l00045">ptr</a>.</p>

</div>
</div>
<a id="a4d26f97a0cf592ce89640a8fdb842d0d" name="a4d26f97a0cf592ce89640a8fdb842d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d26f97a0cf592ce89640a8fdb842d0d">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[18/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename T , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; Key, T, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00724">724</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  725</span>                                                                        {</div>
<div class="line"><span class="lineno">  726</span>  <span class="keywordflow">return</span> H::combine(</div>
<div class="line"><span class="lineno">  727</span>      H::combine_unordered(std::move(hash_state), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.begin(), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.end()),</div>
<div class="line"><span class="lineno">  728</span>      <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.size());</div>
<div class="line"><span class="lineno">  729</span>}</div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::FormatConversionChar::s</a></div><div class="ttdeci">@ s</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>

</div>
</div>
<a id="aefa50083eb9a7344f1fb1e5fa3ec9d44" name="aefa50083eb9a7344f1fb1e5fa3ec9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa50083eb9a7344f1fb1e5fa3ec9d44">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[19/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename T , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value &amp;&amp;<a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_multimap&lt; Key, T, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00736">736</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  737</span>                                                                             {</div>
<div class="line"><span class="lineno">  738</span>  <span class="keywordflow">return</span> H::combine(</div>
<div class="line"><span class="lineno">  739</span>      H::combine_unordered(std::move(hash_state), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.begin(), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.end()),</div>
<div class="line"><span class="lineno">  740</span>      <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.size());</div>
<div class="line"><span class="lineno">  741</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>

</div>
</div>
<a id="ae211afb3f7b8a608fc32d7654e61bf56" name="ae211afb3f7b8a608fc32d7654e61bf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae211afb3f7b8a608fc32d7654e61bf56">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[20/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_multiset&lt; Key, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00711">711</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  713</span>                                                                {</div>
<div class="line"><span class="lineno">  714</span>  <span class="keywordflow">return</span> H::combine(</div>
<div class="line"><span class="lineno">  715</span>      H::combine_unordered(std::move(hash_state), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.begin(), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.end()),</div>
<div class="line"><span class="lineno">  716</span>      <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.size());</div>
<div class="line"><span class="lineno">  717</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>

</div>
</div>
<a id="a8fb52c3b968b6302e8bede96bd0d8c03" name="a8fb52c3b968b6302e8bede96bd0d8c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb52c3b968b6302e8bede96bd0d8c03">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[21/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Key , typename <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a> , typename KeyEqual , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; Key &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; Key, <a class="el" href="structabsl_1_1hash__internal_1_1_hash.html">Hash</a>, KeyEqual, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00701">701</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  702</span>                                                                         {</div>
<div class="line"><span class="lineno">  703</span>  <span class="keywordflow">return</span> H::combine(</div>
<div class="line"><span class="lineno">  704</span>      H::combine_unordered(std::move(hash_state), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.begin(), <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.end()),</div>
<div class="line"><span class="lineno">  705</span>      <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>.size());</div>
<div class="line"><span class="lineno">  706</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>

</div>
</div>
<a id="af9a7b8f4a22479a56f5cc63e93ac146e" name="af9a7b8f4a22479a56f5cc63e93ac146e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a7b8f4a22479a56f5cc63e93ac146e">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[22/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00601">601</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  601</span>                                                                   {</div>
<div class="line"><span class="lineno">  602</span>  <span class="keywordflow">return</span> H::combine(H::combine_contiguous(std::move(hash_state), vector.data(),</div>
<div class="line"><span class="lineno">  603</span>                                          vector.size()),</div>
<div class="line"><span class="lineno">  604</span>                    vector.size());</div>
<div class="line"><span class="lineno">  605</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b8c0d545dbfa7047d2a5aa33ef48fbe" name="a2b8c0d545dbfa7047d2a5aa33ef48fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8c0d545dbfa7047d2a5aa33ef48fbe">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[23/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value &amp;&amp;std::is_same&lt; T, bool &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00638">638</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  638</span>                                                                   {</div>
<div class="line"><span class="lineno">  639</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state),</div>
<div class="line"><span class="lineno">  640</span>                    std::hash&lt;std::vector&lt;T, Allocator&gt;&gt;{}(vector),</div>
<div class="line"><span class="lineno">  641</span>                    vector.size());</div>
<div class="line"><span class="lineno">  642</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a221db7a4bf11c111ba020220207ad74c" name="a221db7a4bf11c111ba020220207ad74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221db7a4bf11c111ba020220207ad74c">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[24/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Enum &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_enum&lt; Enum &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Enum</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00353">353</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  354</span>                          {</div>
<div class="line"><span class="lineno">  355</span>  <span class="comment">// In practice, we could almost certainly just invoke hash_bytes directly,</span></div>
<div class="line"><span class="lineno">  356</span>  <span class="comment">// but it&#39;s possible that a sanitizer might one day want to</span></div>
<div class="line"><span class="lineno">  357</span>  <span class="comment">// store data in the unused bits of an enum. To avoid that risk, we</span></div>
<div class="line"><span class="lineno">  358</span>  <span class="comment">// convert to the underlying type before hashing. Hopefully this will get</span></div>
<div class="line"><span class="lineno">  359</span>  <span class="comment">// optimized away; if not, we can reopen discussion with c-toolchain-team.</span></div>
<div class="line"><span class="lineno">  360</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state),</div>
<div class="line"><span class="lineno">  361</span>                    <span class="keyword">static_cast&lt;</span>typename std::underlying_type&lt;Enum&gt;::type<span class="keyword">&gt;</span>(e));</div>
<div class="line"><span class="lineno">  362</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acae1671797c52e15f763380b45e841ec32">absl::e</a>.</p>

</div>
</div>
<a id="ac3bc1ac44a4f7dd32453282a8619b17d" name="ac3bc1ac44a4f7dd32453282a8619b17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bc1ac44a4f7dd32453282a8619b17d">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[25/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Float &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; Float, float &gt;::value||std::is_same&lt; Float, double &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00368">368</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  368</span>                                         {</div>
<div class="line"><span class="lineno">  369</span>  <span class="keywordflow">return</span> hash_internal::hash_bytes(std::move(hash_state),</div>
<div class="line"><span class="lineno">  370</span>                                   value == 0 ? 0 : value);</div>
<div class="line"><span class="lineno">  371</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="internal_2hash_8h_source.html#l00326">hash_bytes()</a>, and <a class="el" href="flat__hash__map__test_8cc_source.html#l00134">value</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_ac3bc1ac44a4f7dd32453282a8619b17d_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_ac3bc1ac44a4f7dd32453282a8619b17d_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_ac3bc1ac44a4f7dd32453282a8619b17d_cgraph" id="anamespaceabsl_1_1hash__internal_ac3bc1ac44a4f7dd32453282a8619b17d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,136,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a57eec8498f929d0a5ed8623e3ceef7da" title=" " alt="" coords="184,5,314,46"/>
<area shape="poly" title=" " alt="" coords="136,23,168,23,168,28,136,28"/>
</map>
</div>

</div>
</div>
<a id="a1173309951d32772a7410018e15ac502" name="a1173309951d32772a7410018e15ac502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173309951d32772a7410018e15ac502">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[26/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename LongDouble &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; LongDouble, longdouble &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LongDouble</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00379">379</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  379</span>                                              {</div>
<div class="line"><span class="lineno">  380</span>  <span class="keyword">const</span> <span class="keywordtype">int</span> category = std::fpclassify(value);</div>
<div class="line"><span class="lineno">  381</span>  <span class="keywordflow">switch</span> (category) {</div>
<div class="line"><span class="lineno">  382</span>    <span class="keywordflow">case</span> FP_INFINITE:</div>
<div class="line"><span class="lineno">  383</span>      <span class="comment">// Add the sign bit to differentiate between +Inf and -Inf</span></div>
<div class="line"><span class="lineno">  384</span>      hash_state = H::combine(std::move(hash_state), std::signbit(value));</div>
<div class="line"><span class="lineno">  385</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span>    <span class="keywordflow">case</span> FP_NAN:</div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">case</span> FP_ZERO:</div>
<div class="line"><span class="lineno">  389</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  390</span>      <span class="comment">// Category is enough for these.</span></div>
<div class="line"><span class="lineno">  391</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">case</span> FP_NORMAL:</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">case</span> FP_SUBNORMAL:</div>
<div class="line"><span class="lineno">  395</span>      <span class="comment">// We can&#39;t convert `value` directly to double because this would have</span></div>
<div class="line"><span class="lineno">  396</span>      <span class="comment">// undefined behavior if the value is out of range.</span></div>
<div class="line"><span class="lineno">  397</span>      <span class="comment">// std::frexp gives us a value in the range (-1, -.5] or [.5, 1) that is</span></div>
<div class="line"><span class="lineno">  398</span>      <span class="comment">// guaranteed to be in range for `double`. The truncation is</span></div>
<div class="line"><span class="lineno">  399</span>      <span class="comment">// implementation defined, but that works as long as it is deterministic.</span></div>
<div class="line"><span class="lineno">  400</span>      <span class="keywordtype">int</span> exp;</div>
<div class="line"><span class="lineno">  401</span>      <span class="keyword">auto</span> <a class="code hl_variable" href="float__conversion_8cc.html#a54ef396dc89fc42314f1439dd087e421">mantissa</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(std::frexp(value, &amp;exp));</div>
<div class="line"><span class="lineno">  402</span>      hash_state = H::combine(std::move(hash_state), <a class="code hl_variable" href="float__conversion_8cc.html#a54ef396dc89fc42314f1439dd087e421">mantissa</a>, exp);</div>
<div class="line"><span class="lineno">  403</span>  }</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), category);</div>
<div class="line"><span class="lineno">  406</span>}</div>
<div class="ttc" id="afloat__conversion_8cc_html_a54ef396dc89fc42314f1439dd087e421"><div class="ttname"><a href="float__conversion_8cc.html#a54ef396dc89fc42314f1439dd087e421">mantissa</a></div><div class="ttdeci">MantissaType mantissa</div><div class="ttdef"><b>Definition</b> <a href="float__conversion_8cc_source.html#l01121">float_conversion.cc:1121</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="float__conversion_8cc_source.html#l01121">mantissa</a>.</p>

</div>
</div>
<a id="a7c7c8a2cb204f7e8d7c867923cb9159a" name="a7c7c8a2cb204f7e8d7c867923cb9159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c8a2cb204f7e8d7c867923cb9159a">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[27/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00421">421</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  421</span>                                            {</div>
<div class="line"><span class="lineno">  422</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>));</div>
<div class="line"><span class="lineno">  423</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="accc220536fdfb0b020b608547dd23a66" name="accc220536fdfb0b020b608547dd23a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc220536fdfb0b020b608547dd23a66">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[28/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__hashable.html">is_hashable</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::reference_wrapper&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00749">749</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  750</span>                                               {</div>
<div class="line"><span class="lineno">  751</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), opt.get());</div>
<div class="line"><span class="lineno">  752</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5cc817f287dc6bffb9c5c547cd976735" name="a5cc817f287dc6bffb9c5c547cd976735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc817f287dc6bffb9c5c547cd976735">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[29/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00410">410</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  410</span>                                      {</div>
<div class="line"><span class="lineno">  411</span>  <span class="keyword">auto</span> <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a> = <span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>);</div>
<div class="line"><span class="lineno">  412</span>  <span class="comment">// Due to alignment, pointers tend to have low bits as zero, and the next few</span></div>
<div class="line"><span class="lineno">  413</span>  <span class="comment">// bits follow a pattern since they are also multiples of some base value.</span></div>
<div class="line"><span class="lineno">  414</span>  <span class="comment">// Mixing the pointer twice helps prevent stuck low bits for certain alignment</span></div>
<div class="line"><span class="lineno">  415</span>  <span class="comment">// values.</span></div>
<div class="line"><span class="lineno">  416</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), v, v);</div>
<div class="line"><span class="lineno">  417</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="low__level__alloc__test_8cc_source.html#l00045">ptr</a>, and <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">absl::v</a>.</p>

</div>
</div>
<a id="a2ed7e88d20984cb3327b61eab436a273" name="a2ed7e88d20984cb3327b61eab436a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed7e88d20984cb3327b61eab436a273">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[30/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T , typename <a class="el" href="city__test_8cc.html#ac54ae397901fe700628cafadea3c5208">C</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T C::*</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00427">427</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  427</span>                                        {</div>
<div class="line"><span class="lineno">  428</span>  <span class="keyword">auto</span> salient_ptm_size = [](std::size_t <a class="code hl_variable" href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) -&gt; std::size_t {</div>
<div class="line"><span class="lineno">  429</span><span class="preprocessor">#if defined(_MSC_VER)</span></div>
<div class="line"><span class="lineno">  430</span>    <span class="comment">// Pointers-to-member-function on MSVC consist of one pointer plus 0, 1, 2,</span></div>
<div class="line"><span class="lineno">  431</span>    <span class="comment">// or 3 ints. In 64-bit mode, they are 8-byte aligned and thus can contain</span></div>
<div class="line"><span class="lineno">  432</span>    <span class="comment">// padding (namely when they have 1 or 3 ints). The value below is a lower</span></div>
<div class="line"><span class="lineno">  433</span>    <span class="comment">// bound on the number of salient, non-padding bytes that we use for</span></div>
<div class="line"><span class="lineno">  434</span>    <span class="comment">// hashing.</span></div>
<div class="line"><span class="lineno">  435</span>    <span class="keywordflow">if</span> (<span class="keyword">alignof</span>(T <a class="code hl_define" href="city__test_8cc.html#ac54ae397901fe700628cafadea3c5208">C</a>::*) == alignof(int)) {</div>
<div class="line"><span class="lineno">  436</span>      <span class="comment">// No padding when all subobjects have the same size as the total</span></div>
<div class="line"><span class="lineno">  437</span>      <span class="comment">// alignment. This happens in 32-bit mode.</span></div>
<div class="line"><span class="lineno">  438</span>      <span class="keywordflow">return</span> <a class="code hl_variable" href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>;</div>
<div class="line"><span class="lineno">  439</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  440</span>      <span class="comment">// Padding for 1 int (size 16) or 3 ints (size 24).</span></div>
<div class="line"><span class="lineno">  441</span>      <span class="comment">// With 2 ints, the size is 16 with no padding, which we pessimize.</span></div>
<div class="line"><span class="lineno">  442</span>      <span class="keywordflow">return</span> <a class="code hl_variable" href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> == 24 ? 20 : <a class="code hl_variable" href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> == 16 ? 12 : <a class="code hl_variable" href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>;</div>
<div class="line"><span class="lineno">  443</span>    }</div>
<div class="line"><span class="lineno">  444</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  445</span>    <span class="comment">// On other platforms, we assume that pointers-to-members do not have</span></div>
<div class="line"><span class="lineno">  446</span>    <span class="comment">// padding.</span></div>
<div class="line"><span class="lineno">  447</span><span class="preprocessor">#ifdef __cpp_lib_has_unique_object_representations</span></div>
<div class="line"><span class="lineno">  448</span>    <span class="keyword">static_assert</span>(std::has_unique_object_representations&lt;T C::*&gt;::value);</div>
<div class="line"><span class="lineno">  449</span><span class="preprocessor">#endif  </span><span class="comment">// __cpp_lib_has_unique_object_representations</span></div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>;</div>
<div class="line"><span class="lineno">  451</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  452</span>  };</div>
<div class="line"><span class="lineno">  453</span>  <span class="keywordflow">return</span> H::combine_contiguous(std::move(hash_state),</div>
<div class="line"><span class="lineno">  454</span>                               <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>),</div>
<div class="line"><span class="lineno">  455</span>                               salient_ptm_size(<span class="keyword">sizeof</span> <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>));</div>
<div class="line"><span class="lineno">  456</span>}</div>
<div class="ttc" id="abtree__test_8cc_html_a76f11d9a0a47b94f72c2d0e77fb32240"><div class="ttname"><a href="btree__test_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a></div><div class="ttdeci">int n</div><div class="ttdef"><b>Definition</b> <a href="btree__test_8cc_source.html#l01093">btree_test.cc:1093</a></div></div>
<div class="ttc" id="acity__test_8cc_html_ac54ae397901fe700628cafadea3c5208"><div class="ttname"><a href="city__test_8cc.html#ac54ae397901fe700628cafadea3c5208">C</a></div><div class="ttdeci">#define C(x)</div><div class="ttdef"><b>Definition</b> <a href="city__test_8cc_source.html#l00049">city_test.cc:49</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="city__test_8cc_source.html#l00049">C</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca7b8b965ad4bca0e41ab51de7b31363a1">absl::n</a>, and <a class="el" href="low__level__alloc__test_8cc_source.html#l00045">ptr</a>.</p>

</div>
</div>
<a id="a00a06780435d5ce87c7f67047a1c2cb0" name="a00a06780435d5ce87c7f67047a1c2cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a06780435d5ce87c7f67047a1c2cb0">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[31/31]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename  = absl::enable_if_t&lt;!std::is_same&lt;T, U&gt;::value&gt;, int  = RunOnStartup&lt;SpyHashStateImpl&lt;T&gt;::SetDirectAbslHashValueError&gt;::run&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void absl::hash_internal::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html">SpyHashStateImpl</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e099ea4c363c004555aa1cfc4e7f777" name="a3e099ea4c363c004555aa1cfc4e7f777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e099ea4c363c004555aa1cfc4e7f777">&#9670;&#160;</a></span>CityHash32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t absl::hash_internal::CityHash32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="city_8cc_source.html#l00124">124</a> of file <a class="el" href="city_8cc_source.html">city.cc</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  124</span>                                               {</div>
<div class="line"><span class="lineno">  125</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &lt;= 24) {</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &lt;= 12</div>
<div class="line"><span class="lineno">  127</span>               ? (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &lt;= 4 ? Hash32Len0to4(s, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>) : Hash32Len5to12(<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>))</div>
<div class="line"><span class="lineno">  128</span>               : Hash32Len13to24(<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a>, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>);</div>
<div class="line"><span class="lineno">  129</span>  }</div>
<div class="line"><span class="lineno">  130</span> </div>
<div class="line"><span class="lineno">  131</span>  <span class="comment">// len &gt; 24</span></div>
<div class="line"><span class="lineno">  132</span>  uint32_t h = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>), g = c1 * h, f = g;</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>  uint32_t a0 = Rotate32(Fetch32(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 4) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  135</span>  uint32_t <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a57de565397d6cdb8f80d5a9f938c4653">a1</a> = Rotate32(Fetch32(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 8) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  136</span>  uint32_t <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a3bda233f2ae6bf005d10325972502a26">a2</a> = Rotate32(Fetch32(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 16) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  137</span>  uint32_t a3 = Rotate32(Fetch32(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 12) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  138</span>  uint32_t a4 = Rotate32(Fetch32(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 20) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  139</span>  h ^= a0;</div>
<div class="line"><span class="lineno">  140</span>  h = Rotate32(h, 19);</div>
<div class="line"><span class="lineno">  141</span>  h = h * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  142</span>  h ^= <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a3bda233f2ae6bf005d10325972502a26">a2</a>;</div>
<div class="line"><span class="lineno">  143</span>  h = Rotate32(h, 19);</div>
<div class="line"><span class="lineno">  144</span>  h = h * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  145</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> ^= <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a57de565397d6cdb8f80d5a9f938c4653">a1</a>;</div>
<div class="line"><span class="lineno">  146</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = Rotate32(g, 19);</div>
<div class="line"><span class="lineno">  147</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  148</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> ^= a3;</div>
<div class="line"><span class="lineno">  149</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = Rotate32(g, 19);</div>
<div class="line"><span class="lineno">  150</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  151</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> += a4;</div>
<div class="line"><span class="lineno">  152</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> = Rotate32(f, 19);</div>
<div class="line"><span class="lineno">  153</span>  <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  154</span>  <span class="keywordtype">size_t</span> iters = (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 1) / 20;</div>
<div class="line"><span class="lineno">  155</span>  <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">  156</span>    uint32_t b0 = Rotate32(Fetch32(s) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  157</span>    uint32_t <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a0e88857c4dcd488bc40bf2b77af65462">b1</a> = Fetch32(s + 4);</div>
<div class="line"><span class="lineno">  158</span>    uint32_t <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a5a6a0ab24cf39b2f1691c5a91dec1d6c">b2</a> = Rotate32(Fetch32(s + 8) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  159</span>    uint32_t b3 = Rotate32(Fetch32(s + 12) * c1, 17) * c2;</div>
<div class="line"><span class="lineno">  160</span>    uint32_t b4 = Fetch32(s + 16);</div>
<div class="line"><span class="lineno">  161</span>    h ^= b0;</div>
<div class="line"><span class="lineno">  162</span>    h = Rotate32(h, 18);</div>
<div class="line"><span class="lineno">  163</span>    h = h * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  164</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> += <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a0e88857c4dcd488bc40bf2b77af65462">b1</a>;</div>
<div class="line"><span class="lineno">  165</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> = Rotate32(f, 19);</div>
<div class="line"><span class="lineno">  166</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> * c1;</div>
<div class="line"><span class="lineno">  167</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> += <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a5a6a0ab24cf39b2f1691c5a91dec1d6c">b2</a>;</div>
<div class="line"><span class="lineno">  168</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = Rotate32(g, 18);</div>
<div class="line"><span class="lineno">  169</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  170</span>    h ^= b3 + <a class="code hl_variable" href="hash__function__defaults__test_8cc.html#a0e88857c4dcd488bc40bf2b77af65462">b1</a>;</div>
<div class="line"><span class="lineno">  171</span>    h = Rotate32(h, 19);</div>
<div class="line"><span class="lineno">  172</span>    h = h * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  173</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> ^= b4;</div>
<div class="line"><span class="lineno">  174</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = <a class="code hl_function" href="namespaceabsl.html#acd3a40d701928eed5d6068b413531ab0">absl::gbswap_32</a>(g) * 5;</div>
<div class="line"><span class="lineno">  175</span>    h += b4 * 5;</div>
<div class="line"><span class="lineno">  176</span>    h = <a class="code hl_function" href="namespaceabsl.html#acd3a40d701928eed5d6068b413531ab0">absl::gbswap_32</a>(h);</div>
<div class="line"><span class="lineno">  177</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> += b0;</div>
<div class="line"><span class="lineno">  178</span>    <a class="code hl_define" href="city_8cc.html#a6b854d47c10d6bfe9674b07cc48660dc">PERMUTE3</a>(f, h, g);</div>
<div class="line"><span class="lineno">  179</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a> += 20;</div>
<div class="line"><span class="lineno">  180</span>  } <span class="keywordflow">while</span> (--iters != 0);</div>
<div class="line"><span class="lineno">  181</span>  g = Rotate32(g, 11) * c1;</div>
<div class="line"><span class="lineno">  182</span>  g = Rotate32(g, 17) * c1;</div>
<div class="line"><span class="lineno">  183</span>  f = Rotate32(f, 11) * c1;</div>
<div class="line"><span class="lineno">  184</span>  f = Rotate32(f, 17) * c1;</div>
<div class="line"><span class="lineno">  185</span>  h = Rotate32(h + g, 19);</div>
<div class="line"><span class="lineno">  186</span>  h = h * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  187</span>  h = Rotate32(h, 17) * c1;</div>
<div class="line"><span class="lineno">  188</span>  h = Rotate32(h + f, 19);</div>
<div class="line"><span class="lineno">  189</span>  h = h * 5 + 0xe6546b64;</div>
<div class="line"><span class="lineno">  190</span>  h = Rotate32(h, 17) * c1;</div>
<div class="line"><span class="lineno">  191</span>  <span class="keywordflow">return</span> h;</div>
<div class="line"><span class="lineno">  192</span>}</div>
<div class="ttc" id="acity_8cc_html_a6b854d47c10d6bfe9674b07cc48660dc"><div class="ttname"><a href="city_8cc.html#a6b854d47c10d6bfe9674b07cc48660dc">PERMUTE3</a></div><div class="ttdeci">#define PERMUTE3(a, b, c)</div><div class="ttdef"><b>Definition</b> <a href="city_8cc_source.html#l00077">city.cc:77</a></div></div>
<div class="ttc" id="ahash__function__defaults__test_8cc_html_a0e88857c4dcd488bc40bf2b77af65462"><div class="ttname"><a href="hash__function__defaults__test_8cc.html#a0e88857c4dcd488bc40bf2b77af65462">b1</a></div><div class="ttdeci">T::second_type b1</div><div class="ttdef"><b>Definition</b> <a href="hash__function__defaults__test_8cc_source.html#l00306">hash_function_defaults_test.cc:306</a></div></div>
<div class="ttc" id="ahash__function__defaults__test_8cc_html_a3bda233f2ae6bf005d10325972502a26"><div class="ttname"><a href="hash__function__defaults__test_8cc.html#a3bda233f2ae6bf005d10325972502a26">a2</a></div><div class="ttdeci">T::first_type a2</div><div class="ttdef"><b>Definition</b> <a href="hash__function__defaults__test_8cc_source.html#l00307">hash_function_defaults_test.cc:307</a></div></div>
<div class="ttc" id="ahash__function__defaults__test_8cc_html_a57de565397d6cdb8f80d5a9f938c4653"><div class="ttname"><a href="hash__function__defaults__test_8cc.html#a57de565397d6cdb8f80d5a9f938c4653">a1</a></div><div class="ttdeci">T::first_type a1</div><div class="ttdef"><b>Definition</b> <a href="hash__function__defaults__test_8cc_source.html#l00305">hash_function_defaults_test.cc:305</a></div></div>
<div class="ttc" id="ahash__function__defaults__test_8cc_html_a5a6a0ab24cf39b2f1691c5a91dec1d6c"><div class="ttname"><a href="hash__function__defaults__test_8cc.html#a5a6a0ab24cf39b2f1691c5a91dec1d6c">b2</a></div><div class="ttdeci">T::second_type b2</div><div class="ttdef"><b>Definition</b> <a href="hash__function__defaults__test_8cc_source.html#l00308">hash_function_defaults_test.cc:308</a></div></div>
<div class="ttc" id="alow__level__alloc__test_8cc_html_afed088663f8704004425cdae2120b9b3"><div class="ttname"><a href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a></div><div class="ttdeci">int len</div><div class="ttdef"><b>Definition</b> <a href="low__level__alloc__test_8cc_source.html#l00046">low_level_alloc_test.cc:46</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">absl::FormatConversionChar::f</a></div><div class="ttdeci">@ f</div></div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">absl::FormatConversionChar::g</a></div><div class="ttdeci">@ g</div></div>
<div class="ttc" id="anamespaceabsl_html_acd3a40d701928eed5d6068b413531ab0"><div class="ttname"><a href="namespaceabsl.html#acd3a40d701928eed5d6068b413531ab0">absl::gbswap_32</a></div><div class="ttdeci">uint32_t gbswap_32(uint32_t host_int)</div><div class="ttdef"><b>Definition</b> <a href="endian_8h_source.html#l00047">endian.h:47</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="hash__function__defaults__test_8cc_source.html#l00305">a1</a>, <a class="el" href="hash__function__defaults__test_8cc_source.html#l00307">a2</a>, <a class="el" href="hash__function__defaults__test_8cc_source.html#l00306">b1</a>, <a class="el" href="hash__function__defaults__test_8cc_source.html#l00308">b2</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">absl::f</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">absl::g</a>, <a class="el" href="endian_8h_source.html#l00047">absl::gbswap_32()</a>, <a class="el" href="low__level__alloc__test_8cc_source.html#l00046">len</a>, <a class="el" href="city_8cc_source.html#l00077">PERMUTE3</a>, and <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a3e099ea4c363c004555aa1cfc4e7f777_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a3e099ea4c363c004555aa1cfc4e7f777_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a3e099ea4c363c004555aa1cfc4e7f777_cgraph" id="anamespaceabsl_1_1hash__internal_a3e099ea4c363c004555aa1cfc4e7f777_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,136,46"/>
<area shape="rect" href="namespaceabsl.html#acd3a40d701928eed5d6068b413531ab0" title=" " alt="" coords="184,13,303,38"/>
<area shape="poly" title=" " alt="" coords="136,23,168,23,168,28,136,28"/>
</map>
</div>

</div>
</div>
<a id="ab1da018501bd61ed957b52398e085c8f" name="ab1da018501bd61ed957b52398e085c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1da018501bd61ed957b52398e085c8f">&#9670;&#160;</a></span>CityHash64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t absl::hash_internal::CityHash64 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="city_8cc_source.html#l00298">298</a> of file <a class="el" href="city_8cc_source.html">city.cc</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  298</span>                                               {</div>
<div class="line"><span class="lineno">  299</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &lt;= 32) {</div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &lt;= 16) {</div>
<div class="line"><span class="lineno">  301</span>      <span class="keywordflow">return</span> HashLen0to16(s, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>);</div>
<div class="line"><span class="lineno">  302</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  303</span>      <span class="keywordflow">return</span> HashLen17to32(s, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>);</div>
<div class="line"><span class="lineno">  304</span>    }</div>
<div class="line"><span class="lineno">  305</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &lt;= 64) {</div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">return</span> HashLen33to64(s, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>);</div>
<div class="line"><span class="lineno">  307</span>  }</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span>  <span class="comment">// For strings over 64 bytes we hash the end first, and then as we</span></div>
<div class="line"><span class="lineno">  310</span>  <span class="comment">// loop we keep 56 bytes of state: v, w, x, y, and z.</span></div>
<div class="line"><span class="lineno">  311</span>  uint64_t <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> = Fetch64(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 40);</div>
<div class="line"><span class="lineno">  312</span>  uint64_t <a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> = Fetch64(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 16) + Fetch64(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 56);</div>
<div class="line"><span class="lineno">  313</span>  uint64_t <a class="code hl_enumvalue" href="namespaceabsl_1_1str__format__internal.html#a208aa9c1527b41e79ca80679ceeb9c38afbade9e36a3f36d3d676c1b808451dd7">z</a> = HashLen16(Fetch64(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 48) + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>, Fetch64(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 24));</div>
<div class="line"><span class="lineno">  314</span>  std::pair&lt;uint64_t, uint64_t&gt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a> =</div>
<div class="line"><span class="lineno">  315</span>      WeakHashLen32WithSeeds(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 64, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>, z);</div>
<div class="line"><span class="lineno">  316</span>  std::pair&lt;uint64_t, uint64_t&gt; w =</div>
<div class="line"><span class="lineno">  317</span>      WeakHashLen32WithSeeds(s + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 32, <a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> + k1, <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>);</div>
<div class="line"><span class="lineno">  318</span>  <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> = <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> * k1 + Fetch64(s);</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>  <span class="comment">// Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.</span></div>
<div class="line"><span class="lineno">  321</span>  <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> = (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 1) &amp; ~<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(63);</div>
<div class="line"><span class="lineno">  322</span>  <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">  323</span>    <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> = Rotate(<a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> + <a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> + <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.first + Fetch64(s + 8), 37) * k1;</div>
<div class="line"><span class="lineno">  324</span>    <a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> = Rotate(<a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> + <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.second + Fetch64(s + 48), 42) * k1;</div>
<div class="line"><span class="lineno">  325</span>    <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> ^= w.second;</div>
<div class="line"><span class="lineno">  326</span>    <a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> += <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.first + Fetch64(s + 40);</div>
<div class="line"><span class="lineno">  327</span>    <a class="code hl_enumvalue" href="namespaceabsl_1_1str__format__internal.html#a208aa9c1527b41e79ca80679ceeb9c38afbade9e36a3f36d3d676c1b808451dd7">z</a> = Rotate(z + w.first, 33) * k1;</div>
<div class="line"><span class="lineno">  328</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a> = WeakHashLen32WithSeeds(s, <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.second * k1, <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a> + w.first);</div>
<div class="line"><span class="lineno">  329</span>    w = WeakHashLen32WithSeeds(s + 32, z + w.second, <a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a> + Fetch64(s + 16));</div>
<div class="line"><span class="lineno">  330</span>    std::swap(z, <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>);</div>
<div class="line"><span class="lineno">  331</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">s</a> += 64;</div>
<div class="line"><span class="lineno">  332</span>    <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> -= 64;</div>
<div class="line"><span class="lineno">  333</span>  } <span class="keywordflow">while</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> != 0);</div>
<div class="line"><span class="lineno">  334</span>  <span class="keywordflow">return</span> HashLen16(HashLen16(<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.first, w.first) + ShiftMix(<a class="code hl_variable" href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a>) * k1 + z,</div>
<div class="line"><span class="lineno">  335</span>                   HashLen16(<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.second, w.second) + <a class="code hl_variable" href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>);</div>
<div class="line"><span class="lineno">  336</span>}</div>
<div class="ttc" id="anamespaceabsl_1_1str__format__internal_html_a208aa9c1527b41e79ca80679ceeb9c38afbade9e36a3f36d3d676c1b808451dd7"><div class="ttname"><a href="namespaceabsl_1_1str__format__internal.html#a208aa9c1527b41e79ca80679ceeb9c38afbade9e36a3f36d3d676c1b808451dd7">absl::str_format_internal::LengthMod::z</a></div><div class="ttdeci">@ z</div></div>
<div class="ttc" id="apentago_8cc_html_a0a2f84ed7838f07779ae24c5a9086d33"><div class="ttname"><a href="pentago_8cc.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a></div><div class="ttdeci">int y</div><div class="ttdef"><b>Definition</b> <a href="pentago_8cc_source.html#l00056">pentago.cc:56</a></div></div>
<div class="ttc" id="apentago_8cc_html_a6150e0515f7202e2fb518f7206ed97dc"><div class="ttname"><a href="pentago_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a></div><div class="ttdeci">int x</div><div class="ttdef"><b>Definition</b> <a href="pentago_8cc_source.html#l00056">pentago.cc:56</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="low__level__alloc__test_8cc_source.html#l00046">len</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">absl::v</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9dd4e461268c8034f5c8564e155c67a6">absl::x</a>, and <a class="el" href="pentago_8cc_source.html#l00056">y</a>.</p>

<p class="reference">Referenced by <a class="el" href="city_8cc_source.html#l00342">CityHash64WithSeeds()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_ab1da018501bd61ed957b52398e085c8f_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_ab1da018501bd61ed957b52398e085c8f_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_ab1da018501bd61ed957b52398e085c8f_icgraph" id="anamespaceabsl_1_1hash__internal_ab1da018501bd61ed957b52398e085c8f_icgraph">
<area shape="rect" title=" " alt="" coords="419,5,549,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a8e59ea59852b67aad22cbd4634340952" title=" " alt="" coords="209,5,371,46"/>
<area shape="poly" title=" " alt="" coords="403,28,371,28,371,23,403,23"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a68505edf296a496957b8284926f8828f" title=" " alt="" coords="5,5,161,46"/>
<area shape="poly" title=" " alt="" coords="193,28,161,28,161,23,193,23"/>
</map>
</div>

</div>
</div>
<a id="a68505edf296a496957b8284926f8828f" name="a68505edf296a496957b8284926f8828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68505edf296a496957b8284926f8828f">&#9670;&#160;</a></span>CityHash64WithSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t absl::hash_internal::CityHash64WithSeed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="city_8cc_source.html#l00338">338</a> of file <a class="el" href="city_8cc_source.html">city.cc</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  338</span>                                                                      {</div>
<div class="line"><span class="lineno">  339</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="#a8e59ea59852b67aad22cbd4634340952">CityHash64WithSeeds</a>(s, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>, k2, seed);</div>
<div class="line"><span class="lineno">  340</span>}</div>
<div class="ttc" id="anamespaceabsl_1_1hash__internal_html_a8e59ea59852b67aad22cbd4634340952"><div class="ttname"><a href="#a8e59ea59852b67aad22cbd4634340952">absl::hash_internal::CityHash64WithSeeds</a></div><div class="ttdeci">uint64_t CityHash64WithSeeds(const char *s, size_t len, uint64_t seed0, uint64_t seed1)</div><div class="ttdef"><b>Definition</b> <a href="city_8cc_source.html#l00342">city.cc:342</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="city_8cc_source.html#l00342">CityHash64WithSeeds()</a>, <a class="el" href="low__level__alloc__test_8cc_source.html#l00046">len</a>, and <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a68505edf296a496957b8284926f8828f_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a68505edf296a496957b8284926f8828f_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a68505edf296a496957b8284926f8828f_cgraph" id="anamespaceabsl_1_1hash__internal_a68505edf296a496957b8284926f8828f_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,161,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a8e59ea59852b67aad22cbd4634340952" title=" " alt="" coords="209,5,371,46"/>
<area shape="poly" title=" " alt="" coords="161,23,193,23,193,28,161,28"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#ab1da018501bd61ed957b52398e085c8f" title=" " alt="" coords="419,5,549,46"/>
<area shape="poly" title=" " alt="" coords="371,23,403,23,403,28,371,28"/>
</map>
</div>

</div>
</div>
<a id="a8e59ea59852b67aad22cbd4634340952" name="a8e59ea59852b67aad22cbd4634340952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e59ea59852b67aad22cbd4634340952">&#9670;&#160;</a></span>CityHash64WithSeeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t absl::hash_internal::CityHash64WithSeeds </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="city_8cc_source.html#l00342">342</a> of file <a class="el" href="city_8cc_source.html">city.cc</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  343</span>                                             {</div>
<div class="line"><span class="lineno">  344</span>  <span class="keywordflow">return</span> HashLen16(<a class="code hl_function" href="#ab1da018501bd61ed957b52398e085c8f">CityHash64</a>(s, <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>) - seed0, seed1);</div>
<div class="line"><span class="lineno">  345</span>}</div>
<div class="ttc" id="anamespaceabsl_1_1hash__internal_html_ab1da018501bd61ed957b52398e085c8f"><div class="ttname"><a href="#ab1da018501bd61ed957b52398e085c8f">absl::hash_internal::CityHash64</a></div><div class="ttdeci">uint64_t CityHash64(const char *s, size_t len)</div><div class="ttdef"><b>Definition</b> <a href="city_8cc_source.html#l00298">city.cc:298</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="city_8cc_source.html#l00298">CityHash64()</a>, <a class="el" href="low__level__alloc__test_8cc_source.html#l00046">len</a>, and <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca03c7c0ace395d80182db07ae2c30f034">absl::s</a>.</p>

<p class="reference">Referenced by <a class="el" href="city_8cc_source.html#l00338">CityHash64WithSeed()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_cgraph" id="anamespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,168,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#ab1da018501bd61ed957b52398e085c8f" title=" " alt="" coords="216,5,346,46"/>
<area shape="poly" title=" " alt="" coords="168,23,200,23,200,28,168,28"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_icgraph" id="anamespaceabsl_1_1hash__internal_a8e59ea59852b67aad22cbd4634340952_icgraph">
<area shape="rect" title=" " alt="" coords="209,5,371,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a68505edf296a496957b8284926f8828f" title=" " alt="" coords="5,5,161,46"/>
<area shape="poly" title=" " alt="" coords="193,28,161,28,161,23,193,23"/>
</map>
</div>

</div>
</div>
<a id="a57eec8498f929d0a5ed8623e3ceef7da" name="a57eec8498f929d0a5ed8623e3ceef7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57eec8498f929d0a5ed8623e3ceef7da">&#9670;&#160;</a></span>hash_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::hash_bytes </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00326">326</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  326</span>                                           {</div>
<div class="line"><span class="lineno">  327</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* start = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;<a class="code hl_variable" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a>);</div>
<div class="line"><span class="lineno">  328</span>  <span class="keywordflow">return</span> H::combine_contiguous(std::move(hash_state), start, <span class="keyword">sizeof</span>(value));</div>
<div class="line"><span class="lineno">  329</span>}</div>
<div class="ttc" id="aflat__hash__map__test_8cc_html_a54c2bae0f8aeed048a397b0618037252"><div class="ttname"><a href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a></div><div class="ttdeci">size_t value</div><div class="ttdef"><b>Definition</b> <a href="flat__hash__map__test_8cc_source.html#l00134">flat_hash_map_test.cc:134</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="flat__hash__map__test_8cc_source.html#l00134">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="internal_2hash_8h_source.html#l00368">AbslHashValue()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a57eec8498f929d0a5ed8623e3ceef7da_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a57eec8498f929d0a5ed8623e3ceef7da_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a57eec8498f929d0a5ed8623e3ceef7da_icgraph" id="anamespaceabsl_1_1hash__internal_a57eec8498f929d0a5ed8623e3ceef7da_icgraph">
<area shape="rect" title=" " alt="" coords="184,5,314,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#ac3bc1ac44a4f7dd32453282a8619b17d" title=" " alt="" coords="5,5,136,46"/>
<area shape="poly" title=" " alt="" coords="168,28,136,28,136,23,168,23"/>
</map>
</div>

</div>
</div>
<a id="a4639e60aa5d17afc706672233c957617" name="a4639e60aa5d17afc706672233c957617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4639e60aa5d17afc706672233c957617">&#9670;&#160;</a></span>hash_range_or_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented.html">is_uniquely_represented</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::hash_range_or_bytes </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00818">818</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  818</span>                                                              {</div>
<div class="line"><span class="lineno">  819</span>  <span class="keyword">const</span> <span class="keyword">auto</span>* bytes = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="float__conversion_8cc.html#adafb71d8f41ef4c3e3d3ccb46fe854c8">data</a>);</div>
<div class="line"><span class="lineno">  820</span>  <span class="keywordflow">return</span> H::combine_contiguous(std::move(hash_state), bytes, <span class="keyword">sizeof</span>(T) * <a class="code hl_variable" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a>);</div>
<div class="line"><span class="lineno">  821</span>}</div>
<div class="ttc" id="afloat__conversion_8cc_html_adafb71d8f41ef4c3e3d3ccb46fe854c8"><div class="ttname"><a href="float__conversion_8cc.html#adafb71d8f41ef4c3e3d3ccb46fe854c8">data</a></div><div class="ttdeci">char data[kBufferLength]</div><div class="ttdef"><b>Definition</b> <a href="float__conversion_8cc_source.html#l01027">float_conversion.cc:1027</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="float__conversion_8cc_source.html#l01027">data</a>, and <a class="el" href="low__level__alloc_8cc_source.html#l00080">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="internal_2hash_8h_source.html#l01249">absl::hash_internal::HashStateBase&lt; H &gt;::combine_contiguous()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a4639e60aa5d17afc706672233c957617_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a4639e60aa5d17afc706672233c957617_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a4639e60aa5d17afc706672233c957617_icgraph" id="anamespaceabsl_1_1hash__internal_a4639e60aa5d17afc706672233c957617_icgraph">
<area shape="rect" title=" " alt="" coords="232,13,385,54"/>
<area shape="rect" href="classabsl_1_1hash__internal_1_1_hash_state_base.html#a1c55fa4ea9b503f5790f801f77b6a1ff" title=" " alt="" coords="5,5,184,61"/>
<area shape="poly" title=" " alt="" coords="216,36,184,36,184,30,216,30"/>
</map>
</div>

</div>
</div>
<a id="a820cfc106c1c28816489a68864742b73" name="a820cfc106c1c28816489a68864742b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820cfc106c1c28816489a68864742b73">&#9670;&#160;</a></span>hash_range_or_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structabsl_1_1hash__internal_1_1is__uniquely__represented.html">is_uniquely_represented</a>&lt; T &gt;::value, H &gt;::type absl::hash_internal::hash_range_or_bytes </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00826">826</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  826</span>                                                              {</div>
<div class="line"><span class="lineno">  827</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> end = data + <a class="code hl_variable" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a>; data &lt; <a class="code hl_variable" href="float__conversion_8cc.html#a8fd806ad19b8f5513a4cf18cbf77532c">end</a>; ++<a class="code hl_variable" href="float__conversion_8cc.html#adafb71d8f41ef4c3e3d3ccb46fe854c8">data</a>) {</div>
<div class="line"><span class="lineno">  828</span>    hash_state = H::combine(std::move(hash_state), *data);</div>
<div class="line"><span class="lineno">  829</span>  }</div>
<div class="line"><span class="lineno">  830</span>  <span class="keywordflow">return</span> hash_state;</div>
<div class="line"><span class="lineno">  831</span>}</div>
<div class="ttc" id="afloat__conversion_8cc_html_a8fd806ad19b8f5513a4cf18cbf77532c"><div class="ttname"><a href="float__conversion_8cc.html#a8fd806ad19b8f5513a4cf18cbf77532c">end</a></div><div class="ttdeci">char * end</div><div class="ttdef"><b>Definition</b> <a href="float__conversion_8cc_source.html#l01029">float_conversion.cc:1029</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="float__conversion_8cc_source.html#l01027">data</a>, <a class="el" href="float__conversion_8cc_source.html#l01029">end</a>, and <a class="el" href="low__level__alloc_8cc_source.html#l00080">size</a>.</p>

</div>
</div>
<a id="a548044220cbac0d63276446f15777208" name="a548044220cbac0d63276446f15777208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548044220cbac0d63276446f15777208">&#9670;&#160;</a></span>hash_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename Tuple , size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H absl::hash_internal::hash_tuple </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>hash_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceabsl.html#ad87d6a123442e30a05fa3204aee60f60">absl::index_sequence</a>&lt; Is... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00475">475</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  475</span>                                                                      {</div>
<div class="line"><span class="lineno">  476</span>  <span class="keywordflow">return</span> H::combine(std::move(hash_state), std::get&lt;Is&gt;(t)...);</div>
<div class="line"><span class="lineno">  477</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="internal_2hash_8h_source.html#l00488">AbslHashValue()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a548044220cbac0d63276446f15777208_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a548044220cbac0d63276446f15777208_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a548044220cbac0d63276446f15777208_icgraph" id="anamespaceabsl_1_1hash__internal_a548044220cbac0d63276446f15777208_icgraph">
<area shape="rect" title=" " alt="" coords="184,5,314,46"/>
<area shape="rect" href="namespaceabsl_1_1hash__internal.html#a7ca07bce0d8952a1bf82d7fb81654c3a" title=" " alt="" coords="5,5,136,46"/>
<area shape="poly" title=" " alt="" coords="168,28,136,28,136,23,168,23"/>
</map>
</div>

</div>
</div>
<a id="aefb8400f869e77be8b51039426cb207b" name="aefb8400f869e77be8b51039426cb207b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb8400f869e77be8b51039426cb207b">&#9670;&#160;</a></span>LowLevelHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t absl::hash_internal::LowLevelHash </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>[5]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="low__level__hash_8cc_source.html#l00030">30</a> of file <a class="el" href="low__level__hash_8cc_source.html">low_level_hash.cc</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   31</span>                                              {</div>
<div class="line"><span class="lineno">   32</span>  <span class="keyword">const</span> uint8_t* <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="float__conversion_8cc.html#adafb71d8f41ef4c3e3d3ccb46fe854c8">data</a>);</div>
<div class="line"><span class="lineno">   33</span>  uint64_t starting_length = <span class="keyword">static_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a>);</div>
<div class="line"><span class="lineno">   34</span>  uint64_t current_state = seed ^ salt[0];</div>
<div class="line"><span class="lineno">   35</span> </div>
<div class="line"><span class="lineno">   36</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt; 64) {</div>
<div class="line"><span class="lineno">   37</span>    <span class="comment">// If we have more than 64 bytes, we&#39;re going to handle chunks of 64</span></div>
<div class="line"><span class="lineno">   38</span>    <span class="comment">// bytes at a time. We&#39;re going to build up two separate hash states</span></div>
<div class="line"><span class="lineno">   39</span>    <span class="comment">// which we will then hash together.</span></div>
<div class="line"><span class="lineno">   40</span>    uint64_t duplicated_state = current_state;</div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span>    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">   43</span>      uint64_t <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>);</div>
<div class="line"><span class="lineno">   44</span>      uint64_t <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 8);</div>
<div class="line"><span class="lineno">   45</span>      uint64_t <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 16);</div>
<div class="line"><span class="lineno">   46</span>      uint64_t <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8277e0910d750195b448797616e091ad">d</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 24);</div>
<div class="line"><span class="lineno">   47</span>      uint64_t <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acae1671797c52e15f763380b45e841ec32">e</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 32);</div>
<div class="line"><span class="lineno">   48</span>      uint64_t <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">f</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 40);</div>
<div class="line"><span class="lineno">   49</span>      uint64_t <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">g</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 48);</div>
<div class="line"><span class="lineno">   50</span>      uint64_t h = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 56);</div>
<div class="line"><span class="lineno">   51</span> </div>
<div class="line"><span class="lineno">   52</span>      uint64_t cs0 = Mix(<a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> ^ salt[1], <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> ^ current_state);</div>
<div class="line"><span class="lineno">   53</span>      uint64_t cs1 = Mix(c ^ salt[2], d ^ current_state);</div>
<div class="line"><span class="lineno">   54</span>      current_state = (cs0 ^ cs1);</div>
<div class="line"><span class="lineno">   55</span> </div>
<div class="line"><span class="lineno">   56</span>      uint64_t ds0 = Mix(e ^ salt[3], f ^ duplicated_state);</div>
<div class="line"><span class="lineno">   57</span>      uint64_t ds1 = Mix(g ^ salt[4], h ^ duplicated_state);</div>
<div class="line"><span class="lineno">   58</span>      duplicated_state = (ds0 ^ ds1);</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>      <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> += 64;</div>
<div class="line"><span class="lineno">   61</span>      <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> -= 64;</div>
<div class="line"><span class="lineno">   62</span>    } <span class="keywordflow">while</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt; 64);</div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span>    current_state = current_state ^ duplicated_state;</div>
<div class="line"><span class="lineno">   65</span>  }</div>
<div class="line"><span class="lineno">   66</span> </div>
<div class="line"><span class="lineno">   67</span>  <span class="comment">// We now have a data `ptr` with at most 64 bytes and the current state</span></div>
<div class="line"><span class="lineno">   68</span>  <span class="comment">// of the hashing state machine stored in current_state.</span></div>
<div class="line"><span class="lineno">   69</span>  <span class="keywordflow">while</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt; 16) {</div>
<div class="line"><span class="lineno">   70</span>    uint64_t <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>);</div>
<div class="line"><span class="lineno">   71</span>    uint64_t <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + 8);</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    current_state = Mix(<a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> ^ salt[1], <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> ^ current_state);</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span>    <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> += 16;</div>
<div class="line"><span class="lineno">   76</span>    <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> -= 16;</div>
<div class="line"><span class="lineno">   77</span>  }</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>  <span class="comment">// We now have a data `ptr` with at most 16 bytes.</span></div>
<div class="line"><span class="lineno">   80</span>  uint64_t <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = 0;</div>
<div class="line"><span class="lineno">   81</span>  uint64_t <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = 0;</div>
<div class="line"><span class="lineno">   82</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt; 8) {</div>
<div class="line"><span class="lineno">   83</span>    <span class="comment">// When we have at least 9 and at most 16 bytes, set A to the first 64</span></div>
<div class="line"><span class="lineno">   84</span>    <span class="comment">// bits of the input and B to the last 64 bits of the input. Yes, they will</span></div>
<div class="line"><span class="lineno">   85</span>    <span class="comment">// overlap in the middle if we are working with less than the full 16</span></div>
<div class="line"><span class="lineno">   86</span>    <span class="comment">// bytes.</span></div>
<div class="line"><span class="lineno">   87</span>    <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>);</div>
<div class="line"><span class="lineno">   88</span>    <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = absl::base_internal::UnalignedLoad64(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 8);</div>
<div class="line"><span class="lineno">   89</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt; 3) {</div>
<div class="line"><span class="lineno">   90</span>    <span class="comment">// If we have at least 4 and at most 8 bytes, set A to the first 32</span></div>
<div class="line"><span class="lineno">   91</span>    <span class="comment">// bits and B to the last 32 bits.</span></div>
<div class="line"><span class="lineno">   92</span>    <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = absl::base_internal::UnalignedLoad32(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>);</div>
<div class="line"><span class="lineno">   93</span>    <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = absl::base_internal::UnalignedLoad32(<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a> + <a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 4);</div>
<div class="line"><span class="lineno">   94</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt; 0) {</div>
<div class="line"><span class="lineno">   95</span>    <span class="comment">// If we have at least 1 and at most 3 bytes, read all of the provided</span></div>
<div class="line"><span class="lineno">   96</span>    <span class="comment">// bits into A, with some adjustments.</span></div>
<div class="line"><span class="lineno">   97</span>    <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = <span class="keyword">static_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>((<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>[0] &lt;&lt; 16) | (<a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>[<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> &gt;&gt; 1] &lt;&lt; 8) |</div>
<div class="line"><span class="lineno">   98</span>                              <a class="code hl_variable" href="low__level__alloc__test_8cc.html#a935adc2e417a61d7eb6f04efb18ba031">ptr</a>[<a class="code hl_variable" href="low__level__alloc__test_8cc.html#afed088663f8704004425cdae2120b9b3">len</a> - 1]);</div>
<div class="line"><span class="lineno">   99</span>    <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = 0;</div>
<div class="line"><span class="lineno">  100</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  101</span>    <a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> = 0;</div>
<div class="line"><span class="lineno">  102</span>    <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> = 0;</div>
<div class="line"><span class="lineno">  103</span>  }</div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span>  uint64_t w = Mix(<a class="code hl_variable" href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a> ^ salt[1], <a class="code hl_variable" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a> ^ current_state);</div>
<div class="line"><span class="lineno">  106</span>  uint64_t <a class="code hl_enumvalue" href="namespaceabsl_1_1str__format__internal.html#a208aa9c1527b41e79ca80679ceeb9c38afbade9e36a3f36d3d676c1b808451dd7">z</a> = salt[1] ^ starting_length;</div>
<div class="line"><span class="lineno">  107</span>  <span class="keywordflow">return</span> Mix(w, z);</div>
<div class="line"><span class="lineno">  108</span>}</div>
<div class="ttc" id="acommon__policy__traits__test_8cc_html_aa4c2a5552e9bc49b1816ff532f558c74"><div class="ttname"><a href="common__policy__traits__test_8cc.html#aa4c2a5552e9bc49b1816ff532f558c74">a</a></div><div class="ttdeci">int a</div><div class="ttdef"><b>Definition</b> <a href="common__policy__traits__test_8cc_source.html#l00076">common_policy_traits_test.cc:76</a></div></div>
<div class="ttc" id="alayout__test_8cc_html_ad66453096871179e6c6effe0df4b483b"><div class="ttname"><a href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a></div><div class="ttdeci">uint64_t b</div><div class="ttdef"><b>Definition</b> <a href="layout__test_8cc_source.html#l00053">layout_test.cc:53</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">absl::FormatConversionChar::c</a></div><div class="ttdeci">@ c</div></div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca8277e0910d750195b448797616e091ad"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8277e0910d750195b448797616e091ad">absl::FormatConversionChar::d</a></div><div class="ttdeci">@ d</div></div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8acae1671797c52e15f763380b45e841ec32"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acae1671797c52e15f763380b45e841ec32">absl::FormatConversionChar::e</a></div><div class="ttdeci">@ e</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca0cc175b9c0f1b6a831c399e269772661">absl::a</a>, <a class="el" href="layout__test_8cc_source.html#l00053">b</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">absl::c</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8277e0910d750195b448797616e091ad">absl::d</a>, <a class="el" href="float__conversion_8cc_source.html#l01027">data</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acae1671797c52e15f763380b45e841ec32">absl::e</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca8fa14cdd754f91cc6554c9e71929cce7">absl::f</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8acab2f5ff47436671b6e533d8dc3614845d">absl::g</a>, <a class="el" href="low__level__alloc__test_8cc_source.html#l00046">len</a>, and <a class="el" href="low__level__alloc__test_8cc_source.html#l00045">ptr</a>.</p>

</div>
</div>
<a id="a48d2040071eac12e8c09824e6ae27d67" name="a48d2040071eac12e8c09824e6ae27d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d2040071eac12e8c09824e6ae27d67">&#9670;&#160;</a></span>PiecewiseChunkSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t absl::hash_internal::PiecewiseChunkSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="internal_2hash_8h_source.html#l00068">68</a> of file <a class="el" href="internal_2hash_8h_source.html">hash.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   68</span>{ <span class="keywordflow">return</span> 1024; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="internal_2hash_8h_source.html#l01263">absl::hash_internal::PiecewiseCombiner::add_buffer()</a>, and <a class="el" href="spy__hash__state_8h_source.html#l00148">absl::hash_internal::SpyHashStateImpl&lt; T &gt;::combine_contiguous()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_a48d2040071eac12e8c09824e6ae27d67_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_a48d2040071eac12e8c09824e6ae27d67_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_a48d2040071eac12e8c09824e6ae27d67_icgraph" id="anamespaceabsl_1_1hash__internal_a48d2040071eac12e8c09824e6ae27d67_icgraph">
<area shape="rect" title=" " alt="" coords="394,65,547,106"/>
<area shape="rect" href="classabsl_1_1hash__internal_1_1_piecewise_combiner.html#a306232c35b86fd9b724d614b8a0229b9" title=" " alt="" coords="200,5,345,61"/>
<area shape="poly" title=" " alt="" coords="378,64,345,55,346,50,380,59"/>
<area shape="rect" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html#a0a2ebae4a4c378fd208fb221c94d9cf9" title=" " alt="" coords="199,109,346,165"/>
<area shape="poly" title=" " alt="" coords="380,112,347,120,346,115,378,107"/>
<area shape="rect" href="classabsl_1_1hash__internal_1_1_piecewise_combiner.html#ae7f829dbc19e07289f26fbe8620789fd" title=" " alt="" coords="5,5,151,61"/>
<area shape="poly" title=" " alt="" coords="184,36,151,36,151,30,184,30"/>
<area shape="poly" title=" " alt="" coords="303,97,291,90,272,88,255,90,244,95,239,101,239,109,234,109,234,99,241,90,254,85,272,83,293,85,306,92"/>
</map>
</div>

</div>
</div>
<a id="aa4f5bf8fd7a4ceabb447e385f62068a1" name="aa4f5bf8fd7a4ceabb447e385f62068a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f5bf8fd7a4ceabb447e385f62068a1">&#9670;&#160;</a></span>VerifyTypeImplementsAbslHashCorrectly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Eq &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#ad3388ffb9a4b2443a11d3ab2dee6ef4e">ABSL_MUST_USE_RESULT</a> testing::AssertionResult absl::hash_internal::VerifyTypeImplementsAbslHashCorrectly </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eq</td>          <td class="paramname"><span class="paramname"><em>equals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hash__testing_8h_source.html#l00188">188</a> of file <a class="el" href="hash__testing_8h_source.html">hash_testing.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  188</span>                                                                          {</div>
<div class="line"><span class="lineno">  189</span>  <span class="keyword">using </span>V = <span class="keyword">typename</span> Container::value_type;</div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>  <span class="keyword">struct </span>Info {</div>
<div class="line"><span class="lineno">  192</span>    <span class="keyword">const</span> V&amp; <a class="code hl_variable" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a>;</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordtype">size_t</span> index;</div>
<div class="line"><span class="lineno">  194</span>    std::string ToString()<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  195</span>      <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92">absl::visit</a>(<a class="code hl_struct" href="structabsl_1_1hash__internal_1_1_print_visitor.html">PrintVisitor</a>{index}, <a class="code hl_variable" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a>);</div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span>    SpyHashState expand()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92">absl::visit</a>(ExpandVisitor{}, <a class="code hl_variable" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a>); }</div>
<div class="line"><span class="lineno">  198</span>  };</div>
<div class="line"><span class="lineno">  199</span> </div>
<div class="line"><span class="lineno">  200</span>  <span class="keyword">using </span>EqClass = std::vector&lt;Info&gt;;</div>
<div class="line"><span class="lineno">  201</span>  std::vector&lt;EqClass&gt; classes;</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>  <span class="comment">// Gather the values in equivalence classes.</span></div>
<div class="line"><span class="lineno">  204</span>  <span class="keywordtype">size_t</span> <a class="code hl_variable" href="btree__benchmark_8cc.html#a717c50cfde3924051c279a89096afd3d">i</a> = 0;</div>
<div class="line"><span class="lineno">  205</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value : <a class="code hl_variable" href="btree__benchmark_8cc.html#aebb4d6d7e0b8636f5d395185b123a626">values</a>) {</div>
<div class="line"><span class="lineno">  206</span>    EqClass* <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  207</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; eqclass : classes) {</div>
<div class="line"><span class="lineno">  208</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92">absl::visit</a>(EqVisitor&lt;Eq&gt;{equals}, <a class="code hl_variable" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a>, eqclass[0].value)) {</div>
<div class="line"><span class="lineno">  209</span>        <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a> = &amp;eqclass;</div>
<div class="line"><span class="lineno">  210</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  211</span>      }</div>
<div class="line"><span class="lineno">  212</span>    }</div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">if</span> (c == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  214</span>      classes.emplace_back();</div>
<div class="line"><span class="lineno">  215</span>      <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a> = &amp;classes.back();</div>
<div class="line"><span class="lineno">  216</span>    }</div>
<div class="line"><span class="lineno">  217</span>    <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>-&gt;push_back({<a class="code hl_variable" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a>, <a class="code hl_variable" href="btree__benchmark_8cc.html#a717c50cfde3924051c279a89096afd3d">i</a>});</div>
<div class="line"><span class="lineno">  218</span>    ++<a class="code hl_variable" href="btree__benchmark_8cc.html#a717c50cfde3924051c279a89096afd3d">i</a>;</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>    <span class="comment">// Verify potential errors captured by SpyHashState.</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">if</span> (<span class="keyword">auto</span> error = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>-&gt;back().expand().error()) {</div>
<div class="line"><span class="lineno">  222</span>      <span class="keywordflow">return</span> testing::AssertionFailure() &lt;&lt; *error;</div>
<div class="line"><span class="lineno">  223</span>    }</div>
<div class="line"><span class="lineno">  224</span>  }</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span>  <span class="keywordflow">if</span> (classes.size() &lt; 2) {</div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">return</span> testing::AssertionFailure()</div>
<div class="line"><span class="lineno">  228</span>           &lt;&lt; <span class="stringliteral">&quot;At least two equivalence classes are expected.&quot;</span>;</div>
<div class="line"><span class="lineno">  229</span>  }</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span>  <span class="comment">// We assume that equality is correctly implemented.</span></div>
<div class="line"><span class="lineno">  232</span>  <span class="comment">// Now we verify that AbslHashValue is also correctly implemented.</span></div>
<div class="line"><span class="lineno">  233</span> </div>
<div class="line"><span class="lineno">  234</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : classes) {</div>
<div class="line"><span class="lineno">  235</span>    <span class="comment">// All elements of the equivalence class must have the same hash</span></div>
<div class="line"><span class="lineno">  236</span>    <span class="comment">// expansion.</span></div>
<div class="line"><span class="lineno">  237</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="#a2cb752656767e96b5117d7698dcab913">SpyHashState</a> expected = <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>[0].expand();</div>
<div class="line"><span class="lineno">  238</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> Info&amp; v : <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>) {</div>
<div class="line"><span class="lineno">  239</span>      <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.expand() != <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.expand()) {</div>
<div class="line"><span class="lineno">  240</span>        <span class="keywordflow">return</span> testing::AssertionFailure()</div>
<div class="line"><span class="lineno">  241</span>               &lt;&lt; <span class="stringliteral">&quot;Hash expansion for &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.ToString()</div>
<div class="line"><span class="lineno">  242</span>               &lt;&lt; <span class="stringliteral">&quot; is non-deterministic.&quot;</span>;</div>
<div class="line"><span class="lineno">  243</span>      }</div>
<div class="line"><span class="lineno">  244</span>      <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.expand() != expected) {</div>
<div class="line"><span class="lineno">  245</span>        <span class="keywordflow">return</span> testing::AssertionFailure()</div>
<div class="line"><span class="lineno">  246</span>               &lt;&lt; <span class="stringliteral">&quot;Values &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>[0].ToString() &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">v</a>.ToString()</div>
<div class="line"><span class="lineno">  247</span>               &lt;&lt; <span class="stringliteral">&quot; evaluate as equal but have an unequal hash expansion.&quot;</span>;</div>
<div class="line"><span class="lineno">  248</span>      }</div>
<div class="line"><span class="lineno">  249</span>    }</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="comment">// Elements from other classes must have different hash expansion.</span></div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c2 : classes) {</div>
<div class="line"><span class="lineno">  253</span>      <span class="keywordflow">if</span> (&amp;c == &amp;c2) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  254</span>      <span class="keyword">const</span> <a class="code hl_typedef" href="#a2cb752656767e96b5117d7698dcab913">SpyHashState</a> c2_hash = c2[0].expand();</div>
<div class="line"><span class="lineno">  255</span>      <span class="keywordflow">switch</span> (SpyHashState::Compare(expected, c2_hash)) {</div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">case</span> SpyHashState::CompareResult::kEqual:</div>
<div class="line"><span class="lineno">  257</span>          <span class="keywordflow">return</span> testing::AssertionFailure()</div>
<div class="line"><span class="lineno">  258</span>                 &lt;&lt; <span class="stringliteral">&quot;Values &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>[0].ToString() &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; c2[0].ToString()</div>
<div class="line"><span class="lineno">  259</span>                 &lt;&lt; <span class="stringliteral">&quot; evaluate as unequal but have an equal hash expansion.&quot;</span>;</div>
<div class="line"><span class="lineno">  260</span>        <span class="keywordflow">case</span> SpyHashState::CompareResult::kBSuffixA:</div>
<div class="line"><span class="lineno">  261</span>          <span class="keywordflow">return</span> testing::AssertionFailure()</div>
<div class="line"><span class="lineno">  262</span>                 &lt;&lt; <span class="stringliteral">&quot;Hash expansion of &quot;</span> &lt;&lt; c2[0].ToString()</div>
<div class="line"><span class="lineno">  263</span>                 &lt;&lt; <span class="stringliteral">&quot; is a suffix of the hash expansion of &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>[0].ToString()</div>
<div class="line"><span class="lineno">  264</span>                 &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><span class="lineno">  265</span>        <span class="keywordflow">case</span> SpyHashState::CompareResult::kASuffixB:</div>
<div class="line"><span class="lineno">  266</span>          <span class="keywordflow">return</span> testing::AssertionFailure()</div>
<div class="line"><span class="lineno">  267</span>                 &lt;&lt; <span class="stringliteral">&quot;Hash expansion of &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>[0].ToString()</div>
<div class="line"><span class="lineno">  268</span>                 &lt;&lt; <span class="stringliteral">&quot; is a suffix of the hash expansion of &quot;</span> &lt;&lt; c2[0].ToString()</div>
<div class="line"><span class="lineno">  269</span>                 &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordflow">case</span> SpyHashState::CompareResult::kUnequal:</div>
<div class="line"><span class="lineno">  271</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  272</span>      }</div>
<div class="line"><span class="lineno">  273</span>    }</div>
<div class="line"><span class="lineno">  274</span>  }</div>
<div class="line"><span class="lineno">  275</span>  <span class="keywordflow">return</span> testing::AssertionSuccess();</div>
<div class="line"><span class="lineno">  276</span>}</div>
<div class="ttc" id="abtree__benchmark_8cc_html_a717c50cfde3924051c279a89096afd3d"><div class="ttname"><a href="btree__benchmark_8cc.html#a717c50cfde3924051c279a89096afd3d">i</a></div><div class="ttdeci">uint64_t i</div><div class="ttdef"><b>Definition</b> <a href="btree__benchmark_8cc_source.html#l00232">btree_benchmark.cc:232</a></div></div>
<div class="ttc" id="abtree__benchmark_8cc_html_aebb4d6d7e0b8636f5d395185b123a626"><div class="ttname"><a href="btree__benchmark_8cc.html#aebb4d6d7e0b8636f5d395185b123a626">values</a></div><div class="ttdeci">std::array&lt; int64_t, Size &gt; values</div><div class="ttdef"><b>Definition</b> <a href="btree__benchmark_8cc_source.html#l00610">btree_benchmark.cc:610</a></div></div>
<div class="ttc" id="anamespaceabsl_1_1hash__internal_html_a2cb752656767e96b5117d7698dcab913"><div class="ttname"><a href="#a2cb752656767e96b5117d7698dcab913">absl::hash_internal::SpyHashState</a></div><div class="ttdeci">SpyHashStateImpl&lt; void &gt; SpyHashState</div><div class="ttdef"><b>Definition</b> <a href="spy__hash__state_8h_source.html#l00260">spy_hash_state.h:260</a></div></div>
<div class="ttc" id="astructabsl_1_1hash__internal_1_1_print_visitor_html"><div class="ttname"><a href="structabsl_1_1hash__internal_1_1_print_visitor.html">absl::hash_internal::PrintVisitor</a></div><div class="ttdef"><b>Definition</b> <a href="hash__testing_8h_source.html#l00162">hash_testing.h:162</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">absl::c</a>, <a class="el" href="spy__hash__state_8h_source.html#l00114">absl::hash_internal::SpyHashStateImpl&lt; T &gt;::Compare()</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741">absl::i</a>, <a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html#a64cee0dae9abcc790b3375232babfd4baa93557ab7c1f64032189c27b185f3759">absl::hash_internal::SpyHashStateImpl&lt; T &gt;::kASuffixB</a>, <a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html#a64cee0dae9abcc790b3375232babfd4ba90bd17ae0569e675c433232d15814c91">absl::hash_internal::SpyHashStateImpl&lt; T &gt;::kBSuffixA</a>, <a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html#a64cee0dae9abcc790b3375232babfd4ba10580bbb0df84a6b318eee68fd772d43">absl::hash_internal::SpyHashStateImpl&lt; T &gt;::kEqual</a>, <a class="el" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html#a64cee0dae9abcc790b3375232babfd4ba26bd388b1e3a439f48799e675ae95f4f">absl::hash_internal::SpyHashStateImpl&lt; T &gt;::kUnequal</a>, <a class="el" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca9e3669d19b675bd57058fd4664205d2a">absl::v</a>, <a class="el" href="flat__hash__map__test_8cc_source.html#l00134">value</a>, <a class="el" href="btree__benchmark_8cc_source.html#l00610">values</a>, and <a class="el" href="variant_8h_source.html#l00430">absl::visit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hash__testing_8h_source.html#l00345">absl::VerifyTypeImplementsAbslHashCorrectly()</a>, <a class="el" href="hash__testing_8h_source.html#l00353">absl::VerifyTypeImplementsAbslHashCorrectly()</a>, <a class="el" href="hash__testing_8h_source.html#l00360">absl::VerifyTypeImplementsAbslHashCorrectly()</a>, and <a class="el" href="hash__testing_8h_source.html#l00368">absl::VerifyTypeImplementsAbslHashCorrectly()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_cgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_cgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_cgraph" id="anamespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_cgraph">
<area shape="rect" title=" " alt="" coords="5,65,191,121"/>
<area shape="rect" href="classabsl_1_1hash__internal_1_1_spy_hash_state_impl.html#a74446ca5d30e014896ac8fd7abcb83dc" title=" " alt="" coords="239,32,386,87"/>
<area shape="poly" title=" " alt="" coords="191,76,223,71,224,76,191,81"/>
<area shape="rect" href="namespaceabsl.html#ae516527e96422ca1eb82d851b1b9fe92" title=" " alt="" coords="274,112,351,138"/>
<area shape="poly" title=" " alt="" coords="191,104,259,114,258,120,191,109"/>
<area shape="rect" href="namespaceabsl.html#aa0f35b453d2c6860ec08ccc0e94f6cf3" title=" " alt="" coords="434,5,544,31"/>
<area shape="poly" title=" " alt="" coords="386,40,418,32,420,37,387,45"/>
<area shape="rect" href="namespaceabsl.html#a66735d042e8e255930c66b67f3b39244" title=" " alt="" coords="442,55,536,80"/>
<area shape="poly" title=" " alt="" coords="387,60,426,62,426,67,386,66"/>
<area shape="rect" href="namespaceabsl_1_1strings__internal.html#ad5b694c25b0f1ab42df683172f72e1ce" title=" " alt="" coords="592,47,734,88"/>
<area shape="poly" title=" " alt="" coords="537,65,577,65,577,70,537,70"/>
<area shape="rect" href="classabsl_1_1string__view.html#acdd63d87adecc9cb89e3bb2c4efedf47" title=" " alt="" coords="782,29,934,55"/>
<area shape="poly" title=" " alt="" coords="734,56,766,51,766,57,735,61"/>
<area shape="rect" href="classabsl_1_1string__view.html#a3950f228eccec8f88e34b9a90ad94428" title=" " alt="" coords="782,79,934,104"/>
<area shape="poly" title=" " alt="" coords="735,74,767,78,766,83,734,79"/>
<area shape="rect" href="namespaceabsl.html#a03ebb53df1ff18fef1fe76732a670187" title=" " alt="" coords="441,112,537,138"/>
<area shape="poly" title=" " alt="" coords="351,122,425,122,425,128,351,128"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_icgraph.png" border="0" usemap="#anamespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_icgraph" alt=""/></div>
<map name="anamespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_icgraph" id="anamespaceabsl_1_1hash__internal_aa4f5bf8fd7a4ceabb447e385f62068a1_icgraph">
<area shape="rect" title=" " alt="" coords="237,96,422,152"/>
<area shape="rect" href="namespaceabsl.html#adee14c2e62ea40ceb8e835bd01fb0c77" title=" " alt="" coords="5,5,189,46"/>
<area shape="poly" title=" " alt="" coords="255,92,188,61,156,49,158,44,190,57,257,87"/>
<area shape="rect" href="namespaceabsl.html#aafec3c188e859d1570950d292ed5d230" title=" " alt="" coords="5,71,189,111"/>
<area shape="poly" title=" " alt="" coords="221,112,189,107,189,102,222,106"/>
<area shape="rect" href="namespaceabsl.html#a649627f16f6b794c8fe019ca09e856f4" title=" " alt="" coords="5,136,189,177"/>
<area shape="poly" title=" " alt="" coords="222,142,189,146,189,141,221,137"/>
<area shape="rect" href="namespaceabsl.html#aa3aacdb6778851d73e2aaacd37cdc6db" title=" " alt="" coords="5,201,189,242"/>
<area shape="poly" title=" " alt="" coords="256,162,190,191,158,203,156,198,188,186,254,157"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a43eef7e0755ad391094c5e0f19910714" name="a43eef7e0755ad391094c5e0f19910714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eef7e0755ad391094c5e0f19910714">&#9670;&#160;</a></span>kHashSalt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t absl::hash_internal::kHashSalt[5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    uint64_t{0x243F6A8885A308D3}, uint64_t{0x13198A2E03707344},</div>
<div class="line">    uint64_t{0xA4093822299F31D0}, uint64_t{0x082EFA98EC4E6C89},</div>
<div class="line">    uint64_t{0x452821E638D01377},</div>
<div class="line">}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="hash_8cc_source.html#l00056">56</a> of file <a class="el" href="hash_8cc_source.html">hash.cc</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   56</span>                                  {</div>
<div class="line"><span class="lineno">   57</span>    uint64_t{0x243F6A8885A308D3}, uint64_t{0x13198A2E03707344},</div>
<div class="line"><span class="lineno">   58</span>    uint64_t{0xA4093822299F31D0}, uint64_t{0x082EFA98EC4E6C89},</div>
<div class="line"><span class="lineno">   59</span>    uint64_t{0x452821E638D01377},</div>
<div class="line"><span class="lineno">   60</span>};</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
