<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SonMu: Pybind11 bindings for the Abseil C++ Common Libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SonMu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_open_spiel_pybind11_abseil__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Pybind11 bindings for the Abseil C++ Common Libraries </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md87">Overview</a></li>
<li class="level1"><a href="#autotoc_md88">Installation</a></li>
<li class="level1"><a href="#autotoc_md89">absl::Duration</a></li>
<li class="level1"><a href="#autotoc_md90">absl::Time</a><ul><li class="level2"><a href="#autotoc_md91">Time zones</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md92">absl::CivilTime</a></li>
<li class="level1"><a href="#autotoc_md93">absl::Span</a><ul><li class="level2"><a href="#autotoc_md94">Loading</a></li>
<li class="level2"><a href="#autotoc_md95">Casting</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md96">absl::string_view</a></li>
<li class="level1"><a href="#autotoc_md97">absl::optional</a></li>
<li class="level1"><a href="#autotoc_md98">absl::flat_hash_map and absl::btree_map</a></li>
<li class="level1"><a href="#autotoc_md99">absl::flat_hash_set</a></li>
<li class="level1"><a href="#autotoc_md100">absl::Status[Or]</a><ul><li class="level2"><a href="#autotoc_md101">absl::StatusOr</a></li>
<li class="level2"><a href="#autotoc_md102">absl::StatusCode</a></li>
<li class="level2"><a href="#autotoc_md103">Aliasing parts of the status module</a></li>
<li class="level2"><a href="#autotoc_md104">Importing the status module</a></li>
<li class="level2"><a href="#autotoc_md105">Use Outside of Google3</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><img src="https://github.com/pybind/pybind11_abseil/workflows/build_and_test/badge.svg" alt="build_and_test" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md87"></a>
Overview</h1>
<p>These adapters make Abseil types work with Pybind11 bindings. For more information on using Pybind11, see g3doc/third_party/pybind11/google3_utils/README.md.</p>
<p>To use the converters listed below, just include the header in the .cc file with your bindings:</p>
<div class="fragment"><div class="line">#include &quot;pybind11_abseil/absl_casters.h&quot;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md88"></a>
Installation</h1>
<p>You will need to depend on <code><a class="el" href="namespacepybind11.html">pybind11</a></code>, <code>pybind11_bazel</code>(see <a href="https://github.com/pybind/pybind11_bazel#installation">doc</a>, and on <code>pybind11_abseil</code>, e.g.</p>
<div class="fragment"><div class="line">git_repository(</div>
<div class="line">    name = &quot;pybind11_bazel&quot;,</div>
<div class="line">    remote = &quot;https://github.com/pybind/pybind11_bazel.git&quot;,</div>
<div class="line">    branch = &quot;master&quot;,</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">http_archive(</div>
<div class="line">  name = &quot;pybind11&quot;,</div>
<div class="line">  build_file = &quot;@pybind11_bazel//:pybind11.BUILD&quot;,</div>
<div class="line">  strip_prefix = &quot;pybind11-2.6.2&quot;,</div>
<div class="line">  sha256 = &quot;8ff2fff22df038f5cd02cea8af56622bc67f5b64534f1b83b9f133b8366acff2&quot;,</div>
<div class="line">  urls = [&quot;https://github.com/pybind/pybind11/archive/v2.6.2.tar.gz&quot;],</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">load(&quot;@pybind11_bazel//:python_configure.bzl&quot;, &quot;python_configure&quot;)</div>
<div class="line">python_configure(name = &quot;local_config_python&quot;)</div>
<div class="line"> </div>
<div class="line">git_repository(</div>
<div class="line">    name = &quot;pybind11_abseil&quot;,</div>
<div class="line">    remote = &quot;https://github.com/pybind/pybind11_abseil.git&quot;,</div>
<div class="line">    branch = &quot;master&quot;,</div>
<div class="line">)</div>
</div><!-- fragment --><p>Then, in your BUILD file:</p>
<div class="fragment"><div class="line">load(&quot;@pybind11_bazel//:build_defs.bzl&quot;, &quot;pybind_extension&quot;)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md89"></a>
absl::Duration</h1>
<p><code><a class="el" href="classabsl_1_1_duration.html">absl::Duration</a></code> objects are converted to/ from python datetime.timedelta objects. Therefore, C code cannot mutate any datetime.timedelta objects from python.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
absl::Time</h1>
<p><code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> objects are converted to/from python datetime.datetime objects. Additionally, datetime.date objects can be converted to <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> objects. C code cannot mutate any datetime.datetime objects from python.</p>
<p>Python date objects effectively truncate the time to 0 (i.e., midnight). Python time objects are not supported because <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> would implicitly assume a year, which could be confusing.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
Time zones</h2>
<p>Python <code>datetime</code> objects include timezone information, while <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> does not. When converting from Python to C++, if a timezone is specified then it will be used to determine the <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> instant. If no timezone is specified by the Python <code>datetime</code> object, the local timezone is assumed.</p>
<p>When converting back from C++ to Python, the resultant time will be presented in the local timezone and the <code>tzinfo</code> property set on the <code>datetime</code> object to reflect that. This means that the caller may receive a datetime formatted in a different timezone to the one they passed in. To handle this safely, the caller should take care to check the <code>tzinfo</code> of any returned <code>datetime</code>s.</p>
<h1><a class="anchor" id="autotoc_md92"></a>
absl::CivilTime</h1>
<p><code>absl::CivilTime</code> objects are converted to/from Python datetime.datetime objects. Fractional Python datetime components are truncated when converting to less granular C++ types, and time zone information is ignored.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
absl::Span</h1>
<h2><a class="anchor" id="autotoc_md94"></a>
Loading</h2>
<p>Some python types can be loaded (Python-&gt;C++) without copying or converting the list, while some require copying/ converting the list. The non-converting load methods will be tried first, and, if the span elements are const, the converting load methods will be tried next.</p>
<p>Arguments cast to a span with <em>non-const</em> elements can never be copied/converted. To prevent an argument cast to a span with <em>const</em> elements from being copied or converted, mark it as <code>noconvert()</code> (see go/pybind11-non-converting-arguments).</p>
<p>The following python types can be loaded <em>without</em> copying or converting:</p>
<ul>
<li>Numpy array (or anything else that supports <a href="https://docs.python.org/3/c-api/buffer.htm">buffer protocol</a>) =&gt; <code>Span&lt;{const or non-const} T&gt;</code> if <em>all</em> of the following conditions are satisfied:<ul>
<li>The buffer is 1-D.</li>
<li>T is a numeric type.</li>
<li>The array dtype matches T exactly.</li>
<li>If T is not const, the buffer allows writing.</li>
<li>The stride does not indicate to skip elements or go in reverse order.</li>
</ul>
</li>
<li><a href="go/pybind11-opaque-types">Opaque</a> <code>std::vector&lt;T&gt;</code> =&gt; <code>Span&lt;{const or non-const} T&gt;</code>.<ul>
<li>T can be any type, including converted or pointer types, but must match exactly between C++ and python.</li>
<li>Opaque vectors are <em>not</em> currently compatible with the smart holder.</li>
</ul>
</li>
</ul>
<p>The following python types must be copied/converted to be loaded:</p>
<ul>
<li>Python sequence of elements that require conversion (numbers, strings, datetimes, etc) =&gt; <code>Span&lt;const T&gt;</code>.<ul>
<li>The elements will be copied/ converted, so that conversion must be legal.</li>
<li>T <em>cannot</em> be a pointer.</li>
</ul>
</li>
<li>Python sequence of elements that do <em>not</em> require conversion (ie, classes wrapped with py::class_) =&gt; <code>Span&lt;const T&gt;</code> (elements <em>will</em> be copied) or <code>Span&lt;{const or non-const} T* const&gt;</code> (elements will <em>not</em> be copied).</li>
</ul>
<p>Specifically, this conversion will <em>fail</em> if any of the following are true:</p>
<ul>
<li><code>noconvert()</code> was specified (see go/pybind11-non-converting-arguments).</li>
<li>The element conversion is not allowed (eg, floating point to integer).</li>
<li>The sequence is being loaded into a <code>Span&lt;{non-const} T&gt;</code> or <code>Span&lt;{const or non-const} T* {non-const}&gt;</code>.</li>
<li>The elements require conversion <em>and</em> the sequence is being loaded into a <code>Span&lt;T*&gt;</code> (regardless of any <code>const</code>s; the element caster which owns the converted value would be destroyed before <code>load</code> is complete, resulting in dangling references).</li>
<li>The span is nested (ie, <code><a class="el" href="classabsl_1_1_span.html">absl::Span</a>&lt;<a class="el" href="classabsl_1_1_span.html">absl::Span</a>&lt;T&gt;&gt;</code>, regardless of any <code>const</code>s).</li>
</ul>
<p>Note: These failure conditions only apply to <em>converted</em> python types.</p>
<h2><a class="anchor" id="autotoc_md95"></a>
Casting</h2>
<p>Spans are cast (C++-&gt;Python) with the standard list caster, which always converts the list. This could be changed in the future (eg, using <a href="https://pybind11.readthedocs.io/en/stable/advanced/pycpp/numpy.html#buffer-protocol">buffer protocol</a>) but generally using spans as return values is not recommended.</p>
<h1><a class="anchor" id="autotoc_md96"></a>
absl::string_view</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::string_view</code>.</p>
<h1><a class="anchor" id="autotoc_md97"></a>
absl::optional</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::optional</code>.</p>
<h1><a class="anchor" id="autotoc_md98"></a>
absl::flat_hash_map and absl::btree_map</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::map</code>.</p>
<h1><a class="anchor" id="autotoc_md99"></a>
absl::flat_hash_set</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::set</code>.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
absl::Status[Or]</h1>
<p>To use the Status[Or] casters:</p>
<ol type="1">
<li>Include the header file <code><a class="el" href="status__casters_8h.html">pybind11_abseil/status_casters.h</a></code> in the .cc file with your bindings.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule()</a>;</code> in your <code>PYBIND11_MODULE</code> definition.</li>
</ol>
<p>By default, an ok status will be converted into <code>None</code>, and a non-ok status will raise a <code>status.StatusNotOk</code> exception. This has a <code>status</code> attribute which can be used to access the status object and check the code/ message.</p>
<p>To get a <code>status.Status</code> object rather than having an exception thrown, pass either the <code>Status</code> object or a function returning a <code>Status</code> to <code><a class="el" href="namespacepybind11_1_1google.html#afd335ba9018badf7f5987b66a3c08670">pybind11::google::DoNotThrowStatus</a></code> before casting or binding. This works with references and pointers to <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> objects too.</p>
<p>It isn't possible to specify separate return value policies for a <code>StatusOr</code> object and its payload. Since <code>StatusOr</code> is processed and not ever actually represented in Python, the return value policy applies to the payload. E.g., if you return a StatusOr&lt;MyObject*&gt; (note the * is inside the <code>StatusOr</code>) with a take_ownership return val policy and the status is OK (i.e., it has a payload), Python will take ownership of that payload and free it when it is garbage collected.</p>
<p>However, if you return a <code>StatusOr&lt;MyObject&gt;*</code> (note: the <code>*</code> is outside the <code>StatusOr</code> rather than inside it now) with a <code>take_ownership</code> return val policy, Python does not take ownership of the <code>StatusOr</code> and will not free it (because again, that policy applies to <code>MyObject</code>, not <code>StatusOr</code>).</p>
<p>See <code>status_utils.cc</code> in this directory for details about what methods are available in wrapped <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> objects.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="status__casters_8h.html">pybind11_abseil/status_casters.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classabsl_1_1_status.html">absl::Status</a> StatusReturningFunction() {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceabsl.html#a0eae05137690e1e57dc9840e5a3cda92">absl::Status</a>(...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">pybind11::object StatusHandlingFunction() {</div>
<div class="line">  <span class="keywordflow">return</span> pybind11::cast(<a class="code" href="namespacepybind11_1_1google.html#afd335ba9018badf7f5987b66a3c08670">pybind11::google::DoNotThrowStatus</a>(StatusReturningFunction()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacepybind11_1_1google.html#a20dd5098a40cc581b16504071968a745">PYBIND11_MODULE</a>(test_bindings, m) {</div>
<div class="line">  <a class="code" href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule</a>();</div>
<div class="line"> </div>
<div class="line">  m.def(<span class="stringliteral">&quot;return_status&quot;</span>, &amp;StatusReturningFunction,</div>
<div class="line">        <span class="stringliteral">&quot;Return None if StatusCode is OK, otherwise raise an error.&quot;</span>);</div>
<div class="line">  m.def(<span class="stringliteral">&quot;make_status&quot;</span>, <a class="code" href="namespacepybind11_1_1google.html#afd335ba9018badf7f5987b66a3c08670">google::DoNotThrowStatus</a>(&amp;StatusReturningFunction),</div>
<div class="line">        <span class="stringliteral">&quot;Return a wrapped status object without raising an error.&quot;</span>);</div>
<div class="line">  m.def(<span class="stringliteral">&quot;status_handling_function&quot;</span>, &amp;StatusHandlingFunction,</div>
<div class="line">        <span class="stringliteral">&quot;Same effect as make_status, but cast is done internally.&quot;</span>);</div>
<div class="line">};</div>
<div class="ttc" id="aclassabsl_1_1_status_html"><div class="ttname"><a href="classabsl_1_1_status.html">absl::Status</a></div><div class="ttdef"><b>Definition:</b> <a href="status_8h_source.html#l00424">status.h:424</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a0eae05137690e1e57dc9840e5a3cda92"><div class="ttname"><a href="namespaceabsl.html#a0eae05137690e1e57dc9840e5a3cda92">absl::Status</a></div><div class="ttdeci">ABSL_NAMESPACE_BEGIN class ABSL_MUST_USE_RESULT Status</div><div class="ttdef"><b>Definition:</b> <a href="status__internal_8h_source.html#l00028">status_internal.h:37</a></div></div>
<div class="ttc" id="anamespacepybind11_1_1google_html_a20dd5098a40cc581b16504071968a745"><div class="ttname"><a href="namespacepybind11_1_1google.html#a20dd5098a40cc581b16504071968a745">pybind11::google::PYBIND11_MODULE</a></div><div class="ttdeci">PYBIND11_MODULE(status, m)</div><div class="ttdef"><b>Definition:</b> <a href="pybind11__abseil_2pybind11__abseil_2status_8cc_source.html#l00008">status.cc:8</a></div></div>
<div class="ttc" id="anamespacepybind11_1_1google_html_a7e51f5be47ec8d1d31b1b3c4971d0f27"><div class="ttname"><a href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule</a></div><div class="ttdeci">module_ ImportStatusModule(bool bypass_regular_import)</div><div class="ttdef"><b>Definition:</b> <a href="import__status__module_8cc_source.html#l00012">import_status_module.cc:12</a></div></div>
<div class="ttc" id="anamespacepybind11_1_1google_html_afd335ba9018badf7f5987b66a3c08670"><div class="ttname"><a href="namespacepybind11_1_1google.html#afd335ba9018badf7f5987b66a3c08670">pybind11::google::DoNotThrowStatus</a></div><div class="ttdeci">NoThrowStatus&lt; StatusType &gt; DoNotThrowStatus(StatusType status)</div><div class="ttdef"><b>Definition:</b> <a href="no__throw__status_8h_source.html#l00026">no_throw_status.h:26</a></div></div>
<div class="ttc" id="astatus__casters_8h_html"><div class="ttname"><a href="status__casters_8h.html">status_casters.h</a></div></div>
</div><!-- fragment --><p>Python:</p>
<div class="fragment"><div class="line">from pybind11_abseil import status</div>
<div class="line">import test_bindings</div>
<div class="line"> </div>
<div class="line">my_status = make_status()</div>
<div class="line">if my_status.code():</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">try:</div>
<div class="line">  return_status()</div>
<div class="line">except status.StatusNotOk as e:</div>
<div class="line">  print(e.status)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md101"></a>
absl::StatusOr</h2>
<p><code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> objects behave exactly like <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> objects, except:</p>
<ul>
<li>There is no support for passing StatusOr objects. You can only return them.</li>
<li>Instead of returning None or a wrapped status with OK, this casts and returns the payload when there is no error.</li>
</ul>
<p>As with <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code>, the default behavior is to throw an error when casting a non-ok status. You may pass a StatusOr object or StatusOr returning function to <code><a class="el" href="namespacepybind11_1_1google.html#afd335ba9018badf7f5987b66a3c08670">pybind11::google::DoNotThrowStatus</a></code> in exactly the same way as with <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> to change this behavior.</p>
<p><code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> objects must be returned by value (not reference or pointer). Why? Because the implementation takes advantage of the fact that python is a dynamically typed language to cast and return the payload <em>or</em> the <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> object (or raise an exeception). Python has no concept of a <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> object, so it's also impossible to apply the return_value_policy to a <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code>. Therefore returning a reference or pointer to a <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> is meaningless.</p>
<p>Pointers <em>can</em> be used as the payload type, and the return_value_policy will be applied to the payload if the status is OK. However, references cannot be used as the payload type, because that's a restriction on <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> in general, not <a class="el" href="namespacepybind11.html">pybind11</a> (see <a href="https://yaqs/5903163345338368">https://yaqs/5903163345338368</a>).</p>
<p>This can handle any type of payload that pybind knows about. unique_ptrs (i.e., <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a>&lt;std::unique_ptr&lt;...&gt;&gt;</code>) to wrapped classes or structs (i.e., any type which you created bindings for using <code>pybind11::class_&lt;...&gt;</code>) can be used, but unique_ptrs to converted types (e.g., <code>int</code>, <code>string</code>, <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code>, <code><a class="el" href="classabsl_1_1_duration.html">absl::Duration</a></code>, etc.) cannot be used.</p>
<h2><a class="anchor" id="autotoc_md102"></a>
absl::StatusCode</h2>
<p>The <code>status</code> module provides <code>pybind11::enum_</code> bindings for <code><a class="el" href="namespaceabsl.html#a6928184af6359d080e561c3a78cce371">absl::StatusCode</a></code>. These use python constant style, e.g. <code>status.StatusCode.OK</code>, <code>status.StatusCode.CANCELLED</code>, etc.</p>
<p>Warning: Pybind enums are their own type, and will never compare equally to integers due to being a different type, regardless of their value. In particular, note that the <a href="http://google3/util/task/status.proto">status proto</a> <code>code</code> field is an integer, so it will never directly compare as equal to a <code>StatusCode</code>. To fix this, convert an integer to a <code>StatusCode</code> or vice-versa.</p>
<div class="fragment"><div class="line">status_code = 0  # An integer.</div>
<div class="line"> </div>
<div class="line">if status_code == status.StatusCode.OK:  # Wrong: always evaluates to false.</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">if status.StatusCode(status_code) == status.StatusCode.OK:  # Correct.</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">if status_code == int(status.StatusCode.OK):  # Also correct.</div>
<div class="line">  ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Aliasing parts of the status module</h2>
<p>The need to import the <code>status</code> module can be eliminated by aliasing the parts of the status module that are needed in your own module:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepybind11_1_1google.html#a20dd5098a40cc581b16504071968a745">PYBIND11_MODULE</a>(test_bindings, m) {</div>
<div class="line">  <span class="keyword">auto</span> status_module = <a class="code" href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule</a>();</div>
<div class="line">  m.attr(<span class="stringliteral">&quot;StatusNotOk&quot;</span>) = status_module.attr(<span class="stringliteral">&quot;StatusNotOk&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Python:</p>
<div class="fragment"><div class="line">import test_bindings</div>
<div class="line"> </div>
<div class="line">try:</div>
<div class="line">  return_status()</div>
<div class="line">except test_bindings.StatusNotOk as e:</div>
<div class="line">  print(e.status)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md104"></a>
Importing the status module</h2>
<p>The status module uses the same import mechansim as the proto module; see <a href="../pybind11_protobuf/README.md#importing-the-proto-module">its documentation</a> for details. For now there is a <code>#ifdef</code> to allow <code>ImportStatusModule</code> to work with python 2 rather than giving an error, but this will be removed eventually.</p>
<p>If modifying the following functions, make the same changes in the corresponding proto functions:</p><ul>
<li>ImportStatusModule</li>
<li>IsStatusModuleImported</li>
<li>CheckStatusModuleImported</li>
</ul>
<h2><a class="anchor" id="autotoc_md105"></a>
Use Outside of Google3</h2>
<p>The path used for the status module may be changed by altering the value of <code>PYBIND11_ABSEIL_STATUS_MODULE_PATH</code> defined in <code><a class="el" href="status__casters_8h.html">status_casters.h</a></code>. This uses the same mechanism as the proto module, so see <a href="../pybind11_protobuf/README.md?cl=head#use-outside-of-google3">its documentation</a> for details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
