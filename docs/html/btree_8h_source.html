<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SonMu: open_spiel/abseil-cpp/absl/container/internal/btree.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SonMu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('btree_8h_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">btree.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="btree_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Copyright 2018 The Abseil Authors.</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// you may not use this file except in compliance with the License.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// You may obtain a copy of the License at</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//      https://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Unless required by applicable law or agreed to in writing, software</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">// See the License for the specific language governing permissions and</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// limitations under the License.</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// A btree implementation of the STL set and map interfaces. A btree is smaller</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">// and generally also faster than STL set/map (refer to the benchmarks below).</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// The red-black tree implementation of STL set/map has an overhead of 3</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">// pointers (left, right and parent) plus the node color information for each</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// stored value. So a set&lt;int32_t&gt; consumes 40 bytes for each value stored in</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// 64-bit mode. This btree implementation stores multiple values on fixed</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">// size nodes (usually 256 bytes) and doesn&#39;t store child pointers for leaf</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">// nodes. The result is that a btree_set&lt;int32_t&gt; may use much less memory per</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">// stored value. For the random insertion benchmark in btree_bench.cc, a</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">// btree_set&lt;int32_t&gt; with node-size of 256 uses 5.1 bytes per stored value.</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">// The packing of multiple values on to each node of a btree has another effect</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">// besides better space utilization: better cache locality due to fewer cache</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">// lines being accessed. Better cache locality translates into faster</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">// operations.</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">// CAVEATS</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">// Insertions and deletions on a btree can cause splitting, merging or</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">// rebalancing of btree nodes. And even without these operations, insertions</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">// and deletions on a btree will move values around within a node. In both</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// cases, the result is that insertions and deletions can invalidate iterators</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// pointing to values other than the one being inserted/deleted. Therefore, this</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// container does not provide pointer stability. This is notably different from</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">// STL set/map which takes care to not invalidate iterators on insert/erase</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// except, of course, for iterators pointing to the value being erased.  A</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">// partial workaround when erasing is available: erase() returns an iterator</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">// pointing to the item just after the one that was erased (or end() if none</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">// exists).</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160; </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#ifndef ABSL_CONTAINER_INTERNAL_BTREE_H_</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#define ABSL_CONTAINER_INTERNAL_BTREE_H_</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor">#include &lt;cstddef&gt;</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="preprocessor">#include &lt;new&gt;</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="raw__logging_8h.html">absl/base/internal/raw_logging.h</a>&quot;</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="macros_8h.html">absl/base/macros.h</a>&quot;</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="common_8h.html">absl/container/internal/common.h</a>&quot;</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="common__policy__traits_8h.html">absl/container/internal/common_policy_traits.h</a>&quot;</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="compressed__tuple_8h.html">absl/container/internal/compressed_tuple.h</a>&quot;</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="container__memory_8h.html">absl/container/internal/container_memory.h</a>&quot;</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="layout_8h.html">absl/container/internal/layout.h</a>&quot;</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="abseil-cpp_2absl_2memory_2memory_8h.html">absl/memory/memory.h</a>&quot;</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="type__traits_8h.html">absl/meta/type_traits.h</a>&quot;</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="cord_8h.html">absl/strings/cord.h</a>&quot;</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="string__view_8h.html">absl/strings/string_view.h</a>&quot;</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="abseil-cpp_2absl_2types_2compare_8h.html">absl/types/compare.h</a>&quot;</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="utility_8h.html">absl/utility/utility.h</a>&quot;</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160; </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceabsl.html">absl</a> {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<a class="code" href="base_2config_8h.html#a1426209ed359f780778edc8975b23f07">ABSL_NAMESPACE_BEGIN</a></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="keyword">namespace </span>container_internal {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="preprocessor">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="preprocessor">#error ABSL_BTREE_ENABLE_GENERATIONS cannot be directly set</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="preprocessor">#elif defined(ABSL_HAVE_ADDRESS_SANITIZER) || \</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="preprocessor">    defined(ABSL_HAVE_MEMORY_SANITIZER)</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">// When compiled in sanitizer mode, we add generation integers to the nodes and</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">// iterators. When iterators are used, we validate that the container has not</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">// been mutated since the iterator was constructed.</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="preprocessor">#define ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div>
<div class="line"><a name="l00090"></a><span class="lineno"><a class="line" href="namespaceabsl_1_1container__internal.html#a9cb1e35ef64969fb752e7b217bd18d14">   90</a></span>&#160;<span class="keyword">using</span> <a class="code" href="namespaceabsl_1_1container__internal.html#a9cb1e35ef64969fb752e7b217bd18d14">compare_result_t</a> = <a class="code" href="namespaceabsl.html#a8a7cf6a75e931e10ad158e992dc456d4">absl::result_of_t</a>&lt;<span class="keyword">const</span> <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a>(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> U &amp;)&gt;;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160; </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">// A helper class that indicates if the Compare parameter is a key-compare-to</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">// comparator.</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00095"></a><span class="lineno"><a class="line" href="namespaceabsl_1_1container__internal.html#a8b4e048c216bebee3486e4ebeaf57963">   95</a></span>&#160;<span class="keyword">using</span> <a class="code" href="namespaceabsl_1_1container__internal.html#a8b4e048c216bebee3486e4ebeaf57963">btree_is_key_compare_to</a> =</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    std::is_convertible&lt;compare_result_t&lt;Compare, T, T&gt;, <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a>&gt;;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160; </div>
<div class="line"><a name="l00098"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html">   98</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html">StringBtreeDefaultLess</a> {</div>
<div class="line"><a name="l00099"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#aa057a8e8688e7ccba9c9240dcfc31d13">   99</a></span>&#160;  <span class="keyword">using</span> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#aa057a8e8688e7ccba9c9240dcfc31d13">is_transparent</a> = void;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160; </div>
<div class="line"><a name="l00101"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a58a4e176dda17f66cce24e3c30a3fb67">  101</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a58a4e176dda17f66cce24e3c30a3fb67">StringBtreeDefaultLess</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160; </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="comment">// Compatibility constructor.</span></div>
<div class="line"><a name="l00104"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a5261735ce35ae50de8034075088cf407">  104</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a5261735ce35ae50de8034075088cf407">StringBtreeDefaultLess</a>(std::less&lt;std::string&gt;) {}        <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00105"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a34904a408b028a178c2469850f12b5c4">  105</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a34904a408b028a178c2469850f12b5c4">StringBtreeDefaultLess</a>(std::less&lt;absl::string_view&gt;) {}  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160; </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// Allow converting to std::less for use in key_comp()/value_comp().</span></div>
<div class="line"><a name="l00108"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a9bd83b86d1a4ea8dbbeb8cc9e01a0385">  108</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> std::less&lt;std::string&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {}; }</div>
<div class="line"><a name="l00109"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a1962e542c387e5f7608037ca03a5a27a">  109</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> std::less&lt;absl::string_view&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {}; }</div>
<div class="line"><a name="l00110"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a1eeb77691a38004972dff032cd53ccff">  110</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> std::less&lt;absl::Cord&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {}; }</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160; </div>
<div class="line"><a name="l00112"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a4ec55d10d838f23ca050618aeb4c4541">  112</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a4ec55d10d838f23ca050618aeb4c4541">operator()</a>(<a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> lhs,</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                                 <a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(lhs.<a class="code" href="classabsl_1_1string__view.html#afdca90e80a4ea2e2d63133074fe4229e">compare</a>(rhs));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  }</div>
<div class="line"><a name="l00116"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a8bb6af879940fa761fa34b6665cd762c">  116</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a8bb6af879940fa761fa34b6665cd762c">StringBtreeDefaultLess</a>(std::less&lt;absl::Cord&gt;) {}  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00117"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a2f39528be4d68fc163e8133dc6bf0662">  117</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a2f39528be4d68fc163e8133dc6bf0662">operator()</a>(<span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;lhs,</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                 <span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(lhs.<a class="code" href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">Compare</a>(rhs));</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  }</div>
<div class="line"><a name="l00121"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a05012294e4d2041151b2634197cdbb3d">  121</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a05012294e4d2041151b2634197cdbb3d">operator()</a>(<span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;lhs,</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                                 <a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(lhs.<a class="code" href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">Compare</a>(rhs));</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  }</div>
<div class="line"><a name="l00125"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a825ee59e2e36b12ca5333ecf997f77ae">  125</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a825ee59e2e36b12ca5333ecf997f77ae">operator()</a>(<a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> lhs,</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                                 <span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(-rhs.<a class="code" href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">Compare</a>(lhs));</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;};</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160; </div>
<div class="line"><a name="l00131"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html">  131</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html">StringBtreeDefaultGreater</a> {</div>
<div class="line"><a name="l00132"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a3f4a3aa5c92ba4806dd66376bfc58a2c">  132</a></span>&#160;  <span class="keyword">using</span> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a3f4a3aa5c92ba4806dd66376bfc58a2c">is_transparent</a> = void;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160; </div>
<div class="line"><a name="l00134"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a203e48d49598f1c6b7197c66fbbba422">  134</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a203e48d49598f1c6b7197c66fbbba422">StringBtreeDefaultGreater</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160; </div>
<div class="line"><a name="l00136"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a282010671103d613245764424d23f9c0">  136</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a282010671103d613245764424d23f9c0">StringBtreeDefaultGreater</a>(std::greater&lt;std::string&gt;) {}        <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00137"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a084fd6e71b16f03048928525847751b7">  137</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a084fd6e71b16f03048928525847751b7">StringBtreeDefaultGreater</a>(std::greater&lt;absl::string_view&gt;) {}  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160; </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="comment">// Allow converting to std::greater for use in key_comp()/value_comp().</span></div>
<div class="line"><a name="l00140"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#aa0ab6c4c9c79b26d970f5165fe57768b">  140</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> std::greater&lt;std::string&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {}; }</div>
<div class="line"><a name="l00141"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a3546892cd6bf0aafb5c2eb7f5c238bb8">  141</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> std::greater&lt;absl::string_view&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {}; }</div>
<div class="line"><a name="l00142"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab501d859fd066cf63902d555eb8f5f0c">  142</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> std::greater&lt;absl::Cord&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {}; }</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160; </div>
<div class="line"><a name="l00144"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#abbb9e493da91367e2f43c8d14edcb47b">  144</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#abbb9e493da91367e2f43c8d14edcb47b">operator()</a>(<a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> lhs,</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                                 <a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(rhs.<a class="code" href="classabsl_1_1string__view.html#afdca90e80a4ea2e2d63133074fe4229e">compare</a>(lhs));</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  }</div>
<div class="line"><a name="l00148"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#aba96a4cedf9b21e7322f489eb64cd9ba">  148</a></span>&#160;  <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#aba96a4cedf9b21e7322f489eb64cd9ba">StringBtreeDefaultGreater</a>(std::greater&lt;absl::Cord&gt;) {}  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00149"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a53aaa856bc754e43594e5f21d2ed7525">  149</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a53aaa856bc754e43594e5f21d2ed7525">operator()</a>(<span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;lhs,</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                                 <span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(rhs.<a class="code" href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">Compare</a>(lhs));</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  }</div>
<div class="line"><a name="l00153"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab433e38ac862e40a7670a74a7de41b0b">  153</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab433e38ac862e40a7670a74a7de41b0b">operator()</a>(<span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;lhs,</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                                 <a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(-lhs.<a class="code" href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">Compare</a>(rhs));</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  }</div>
<div class="line"><a name="l00157"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab3a056b507c8e44f0e02fd85a1d26d9f">  157</a></span>&#160;  <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab3a056b507c8e44f0e02fd85a1d26d9f">operator()</a>(<a class="code" href="classabsl_1_1string__view.html">absl::string_view</a> lhs,</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                                 <span class="keyword">const</span> <a class="code" href="classabsl_1_1_cord.html">absl::Cord</a> &amp;rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">compare_internal::compare_result_as_ordering</a>(rhs.<a class="code" href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">Compare</a>(lhs));</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;};</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160; </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">// See below comments for checked_compare.</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<a class="code" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">template &lt;typename Compare, bool is_class = std::is_class&lt;Compare&gt;::value</a>&gt;</div>
<div class="line"><a name="l00165"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base.html">  165</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html">checked_compare_base</a> : <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="keyword">using</span> <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare::Compare</a>;</div>
<div class="line"><a name="l00167"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base.html#a9eabdf8e1cf5b681c332a5b0c86857a4">  167</a></span>&#160;  <span class="keyword">explicit</span> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#a9eabdf8e1cf5b681c332a5b0c86857a4">checked_compare_base</a>(<a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> c) : <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a>(<a class="code" href="namespacestd.html">std</a>::<a class="code" href="namespaceabsl.html#ab937fb37eb7d60210fe910bd43ab2654">move</a>(<a class="code" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>)) {}</div>
<div class="line"><a name="l00168"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">  168</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> &amp;<a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;};</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare&gt;</div>
<div class="line"><a name="l00171"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html">  171</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html">checked_compare_base</a>&lt;<a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a>, false&gt; {</div>
<div class="line"><a name="l00172"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#a15b8cb22c39bc02c124f3fa7ff746690">  172</a></span>&#160;  <span class="keyword">explicit</span> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#a15b8cb22c39bc02c124f3fa7ff746690">checked_compare_base</a>(<a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> c) : compare(<a class="code" href="namespacestd.html">std</a>::<a class="code" href="namespaceabsl.html#ab937fb37eb7d60210fe910bd43ab2654">move</a>(<a class="code" href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">c</a>)) {}</div>
<div class="line"><a name="l00173"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#a8355ec766d4613008f9ba02efb010628">  173</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> &amp;<a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#a8355ec766d4613008f9ba02efb010628">comp</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> compare; }</div>
<div class="line"><a name="l00174"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#aa8c8c1187d0a8e432ec115712256ae7e">  174</a></span>&#160;  <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#aa8c8c1187d0a8e432ec115712256ae7e">compare</a>;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;};</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160; </div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">// A mechanism for opting out of checked_compare for use only in btree_test.cc.</span></div>
<div class="line"><a name="l00178"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_btree_test_only_checked_compare_opt_out_base.html">  178</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1_btree_test_only_checked_compare_opt_out_base.html">BtreeTestOnlyCheckedCompareOptOutBase</a> {};</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160; </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">// A helper class to adapt the specified comparator for two use cases:</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">// (1) When using common Abseil string types with common comparison functors,</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">// convert a boolean comparison into a three-way comparison that returns an</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">// `absl::weak_ordering`. This helper class is specialized for</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">// less&lt;std::string&gt;, greater&lt;std::string&gt;, less&lt;string_view&gt;,</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">// greater&lt;string_view&gt;, less&lt;absl::Cord&gt;, and greater&lt;absl::Cord&gt;.</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">// (2) Adapt the comparator to diagnose cases of non-strict-weak-ordering (see</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">// https://en.cppreference.com/w/cpp/named_req/Compare) in debug mode. Whenever</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">// a comparison is made, we will make assertions to verify that the comparator</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">// is valid.</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Key&gt;</div>
<div class="line"><a name="l00191"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter.html">  191</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1key__compare__adapter.html">key_compare_adapter</a> {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="comment">// Inherit from checked_compare_base to support function pointers and also</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="comment">// keep empty-base-optimization (EBO) support for classes.</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="comment">// Note: we can&#39;t use CompressedTuple here because that would interfere</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// with the EBO for `btree::rightmost_`. `btree::rightmost_` is itself a</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="comment">// CompressedTuple and nested `CompressedTuple`s don&#39;t support EBO.</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <span class="comment">// TODO(b/214288561): use CompressedTuple instead once it supports EBO for</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="comment">// nested `CompressedTuple`s.</span></div>
<div class="line"><a name="l00199"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html">  199</a></span>&#160;  <span class="keyword">struct </span><a class="code" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html">checked_compare</a> : <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html">checked_compare_base</a>&lt;Compare&gt; {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;   <span class="keyword">private</span>:</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keyword">using</span> Base = <span class="keyword">typename</span> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#a9eabdf8e1cf5b681c332a5b0c86857a4">checked_compare::checked_compare_base</a>;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keyword">using</span> Base::comp;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160; </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">// If possible, returns whether `t` is equivalent to itself. We can only do</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">// this for `Key`s because we can&#39;t be sure that it&#39;s safe to call</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="comment">// `comp()(k, k)` otherwise. Even if SFINAE allows it, there could be a</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="comment">// compilation failure inside the implementation of the comparison operator.</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="keywordtype">bool</span> is_self_equivalent(<span class="keyword">const</span> Key &amp;k)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      <span class="comment">// Note: this works for both boolean and three-way comparators.</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>()(k, k) == 0;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="comment">// If we can&#39;t compare `t` with itself, returns true unconditionally.</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordtype">bool</span> is_self_equivalent(<span class="keyword">const</span> T &amp;)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    }</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160; </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;   <span class="keyword">public</span>:</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keyword">using</span> Base::Base;</div>
<div class="line"><a name="l00220"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a856a8a5cd32c909425e9979e08888137">  220</a></span>&#160;    <a class="code" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a856a8a5cd32c909425e9979e08888137">checked_compare</a>(<a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>) : Base(<a class="code" href="namespacestd.html">std</a>::<a class="code" href="namespaceabsl.html#ab937fb37eb7d60210fe910bd43ab2654">move</a>(<a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>)) {}  <span class="comment">// NOLINT</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160; </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">// Allow converting to Compare for use in key_comp()/value_comp().</span></div>
<div class="line"><a name="l00223"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a8ed4858e722bea527428b7a3aba12c8b">  223</a></span>&#160;    <span class="keyword">explicit</span> <span class="keyword">operator</span> <a class="code" href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">Compare</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>(); }</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160; </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U,</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;              <a class="code" href="namespaceabsl.html#a3b0d790d5d90487eb74e72e46bd68d60">absl::enable_if_t</a>&lt;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                  std::is_same&lt;bool, compare_result_t&lt;Compare, T, U&gt;&gt;<a class="code" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">::value</a>,</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                  <span class="keywordtype">int</span>&gt; = 0&gt;</div>
<div class="line"><a name="l00229"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a4866980272aeb23431d874ef76e59318">  229</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a4866980272aeb23431d874ef76e59318">operator()</a>(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> U &amp;rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="comment">// NOTE: if any of these assertions fail, then the comparator does not</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <span class="comment">// establish a strict-weak-ordering (see</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      <span class="comment">// https://en.cppreference.com/w/cpp/named_req/Compare).</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      assert(is_self_equivalent(lhs));</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      assert(is_self_equivalent(rhs));</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">bool</span> lhs_comp_rhs = <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>()(lhs, rhs);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      assert(!lhs_comp_rhs || !<a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>()(rhs, lhs));</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;      <span class="keywordflow">return</span> lhs_comp_rhs;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160; </div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keyword">template</span> &lt;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keyword">typename</span> T, <span class="keyword">typename</span> U,</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <a class="code" href="namespaceabsl.html#a3b0d790d5d90487eb74e72e46bd68d60">absl::enable_if_t&lt;std::is_convertible&lt;compare_result_t&lt;Compare, T, U&gt;</a>,</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                                              <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a>&gt;<a class="code" href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">::value</a>,</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                          <span class="keywordtype">int</span>&gt; = 0&gt;</div>
<div class="line"><a name="l00245"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a8cc2fad7a99a268788711694c885d36c">  245</a></span>&#160;    <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> <a class="code" href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a8cc2fad7a99a268788711694c885d36c">operator()</a>(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> U &amp;rhs)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;      <span class="comment">// NOTE: if any of these assertions fail, then the comparator does not</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="comment">// establish a strict-weak-ordering (see</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <span class="comment">// https://en.cppreference.com/w/cpp/named_req/Compare).</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      assert(is_self_equivalent(lhs));</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      assert(is_self_equivalent(rhs));</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      <span class="keyword">const</span> <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> lhs_comp_rhs = <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>()(lhs, rhs);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="keyword">const</span> <a class="code" href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a> rhs_comp_lhs = <a class="code" href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">comp</a>()(rhs, lhs);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      <span class="keywordflow">if</span> (lhs_comp_rhs &gt; 0) {</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        assert(rhs_comp_lhs &lt; 0 &amp;&amp; &quot;lhs_comp_rhs &gt; 0 -&gt; rhs_comp_lhs &lt; 0<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="stringliteral">      } else if (lhs_comp_rhs == 0) {</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="stringliteral">        assert(rhs_comp_lhs == 0 &amp;&amp; &quot;</span>lhs_comp_rhs == 0 -&gt; rhs_comp_lhs == 0<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="stringliteral">      } else {</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="stringliteral">        assert(rhs_comp_lhs &gt; 0 &amp;&amp; &quot;</span>lhs_comp_rhs &lt; 0 -&gt; rhs_comp_lhs &gt; 0<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="stringliteral">      return lhs_comp_rhs;</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="stringliteral">  };</span></div>
<div class="line"><a name="l00265"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter.html#af99ac249bd516219a4922ed17d3d33bf">  265</a></span>&#160;<span class="stringliteral">  using type = absl::conditional_t&lt;</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="stringliteral">      std::is_base_of&lt;BtreeTestOnlyCheckedCompareOptOutBase, Compare&gt;::value,</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="stringliteral">      Compare, checked_compare&gt;;</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="stringliteral">template &lt;&gt;</span></div>
<div class="line"><a name="l00271"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1less_3_01std_1_1string_01_4_00_01std_1_1string_01_4.html">  271</a></span>&#160;<span class="stringliteral">struct key_compare_adapter&lt;std::less&lt;std::string&gt;, std::string&gt; {</span></div>
<div class="line"><a name="l00272"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1less_3_01std_1_1string_01_4_00_01std_1_1string_01_4.html#a3b712263abe9235c7e3b622c68592857">  272</a></span>&#160;<span class="stringliteral">  using type = StringBtreeDefaultLess;</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="stringliteral">template &lt;&gt;</span></div>
<div class="line"><a name="l00276"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1greater_3_01std_1_1string_01_4_00_01std_1_1string_01_4.html">  276</a></span>&#160;<span class="stringliteral">struct key_compare_adapter&lt;std::greater&lt;std::string&gt;, std::string&gt; {</span></div>
<div class="line"><a name="l00277"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1greater_3_01std_1_1string_01_4_00_01std_1_1string_01_4.html#a97828959de099315e85e3b3e63943f70">  277</a></span>&#160;<span class="stringliteral">  using type = StringBtreeDefaultGreater;</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="stringliteral">template &lt;&gt;</span></div>
<div class="line"><a name="l00281"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1less_3_01absl_1_1string__va7aeaf34752b0e07ec2dd68f76da4dec.html">  281</a></span>&#160;<span class="stringliteral">struct key_compare_adapter&lt;std::less&lt;absl::string_view&gt;, absl::string_view&gt; {</span></div>
<div class="line"><a name="l00282"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1less_3_01absl_1_1string__va7aeaf34752b0e07ec2dd68f76da4dec.html#ab0ac1a3bd26804dd1443436039dae695">  282</a></span>&#160;<span class="stringliteral">  using type = StringBtreeDefaultLess;</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="stringliteral">template &lt;&gt;</span></div>
<div class="line"><a name="l00286"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1greater_3_01absl_1_1string8ca2c5b800149fae8bc3a1da06d077a1.html">  286</a></span>&#160;<span class="stringliteral">struct key_compare_adapter&lt;std::greater&lt;absl::string_view&gt;, absl::string_view&gt; {</span></div>
<div class="line"><a name="l00287"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1greater_3_01absl_1_1string8ca2c5b800149fae8bc3a1da06d077a1.html#a8a508a8baedcb0fd1cafc3d1fa30a4e9">  287</a></span>&#160;<span class="stringliteral">  using type = StringBtreeDefaultGreater;</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="stringliteral">template &lt;&gt;</span></div>
<div class="line"><a name="l00291"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1less_3_01absl_1_1_cord_01_4_00_01absl_1_1_cord_01_4.html">  291</a></span>&#160;<span class="stringliteral">struct key_compare_adapter&lt;std::less&lt;absl::Cord&gt;, absl::Cord&gt; {</span></div>
<div class="line"><a name="l00292"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1less_3_01absl_1_1_cord_01_4_00_01absl_1_1_cord_01_4.html#ab729fc932e64ad39100d251ef9cf6754">  292</a></span>&#160;<span class="stringliteral">  using type = StringBtreeDefaultLess;</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="stringliteral">template &lt;&gt;</span></div>
<div class="line"><a name="l00296"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1greater_3_01absl_1_1_cord_01_4_00_01absl_1_1_cord_01_4.html">  296</a></span>&#160;<span class="stringliteral">struct key_compare_adapter&lt;std::greater&lt;absl::Cord&gt;, absl::Cord&gt; {</span></div>
<div class="line"><a name="l00297"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1key__compare__adapter_3_01std_1_1greater_3_01absl_1_1_cord_01_4_00_01absl_1_1_cord_01_4.html#ad0ee1502cfad024a78a6205eeb9e6c66">  297</a></span>&#160;<span class="stringliteral">  using type = StringBtreeDefaultGreater;</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="stringliteral">// Detects an &#39;absl_btree_prefer_linear_node_search&#39; member. This is</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="stringliteral">// a protocol used as an opt-in or opt-out of linear search.</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="stringliteral">//</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="stringliteral">//  For example, this would be useful for key types that wrap an integer</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="stringliteral">//  and define their own cheap operator&lt;(). For example:</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="stringliteral">//</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="stringliteral">//   class K {</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="stringliteral">//    public:</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral">//     using absl_btree_prefer_linear_node_search = std::true_type;</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="stringliteral">//     ...</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="stringliteral">//    private:</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="stringliteral">//     friend bool operator&lt;(K a, K b) { return a.k_ &lt; b.k_; }</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="stringliteral">//     int k_;</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="stringliteral">//   };</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="stringliteral">//</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="stringliteral">//   btree_map&lt;K, V&gt; m;  // Uses linear search</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="stringliteral">//</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="stringliteral">// If T has the preference tag, then it has a preference.</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="stringliteral">// Btree will use the tag&#39;s truth value.</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="stringliteral">template &lt;typename T, typename = void&gt;</span></div>
<div class="line"><a name="l00320"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1has__linear__node__search__preference.html">  320</a></span>&#160;<span class="stringliteral">struct has_linear_node_search_preference : std::false_type {};</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="stringliteral">template &lt;typename T, typename = void&gt;</span></div>
<div class="line"><a name="l00322"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1prefers__linear__node__search.html">  322</a></span>&#160;<span class="stringliteral">struct prefers_linear_node_search : std::false_type {};</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="stringliteral">template &lt;typename T&gt;</span></div>
<div class="line"><a name="l00324"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1has__linear__node__search__preference_3_01_t_00_01absl_1_1v20f146870934890f385bb084418e41e3.html">  324</a></span>&#160;<span class="stringliteral">struct has_linear_node_search_preference&lt;</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="stringliteral">    T, absl::void_t&lt;typename T::absl_btree_prefer_linear_node_search&gt;&gt;</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="stringliteral">    : std::true_type {};</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="stringliteral">template &lt;typename T&gt;</span></div>
<div class="line"><a name="l00328"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1prefers__linear__node__search_3_01_t_00_01absl_1_1void__t_3fe82d645788b9d24b5cc6c1135f49415.html">  328</a></span>&#160;<span class="stringliteral">struct prefers_linear_node_search&lt;</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="stringliteral">    T, absl::void_t&lt;typename T::absl_btree_prefer_linear_node_search&gt;&gt;</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="stringliteral">    : T::absl_btree_prefer_linear_node_search {};</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="stringliteral">template &lt;typename Compare, typename Key&gt;</span></div>
<div class="line"><a name="l00333"></a><span class="lineno"><a class="line" href="namespaceabsl_1_1container__internal.html#a3fd511b5ed0867bf72049c0492514a33">  333</a></span>&#160;<span class="stringliteral">constexpr bool compare_has_valid_result_type() {</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral">  using compare_result_type = compare_result_t&lt;Compare, Key, Key&gt;;</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral">  return std::is_same&lt;compare_result_type, bool&gt;::value ||</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="stringliteral">         std::is_convertible&lt;compare_result_type, absl::weak_ordering&gt;::value;</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="stringliteral">template &lt;typename original_key_compare, typename value_type&gt;</span></div>
<div class="line"><a name="l00340"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1map__value__compare.html">  340</a></span>&#160;<span class="stringliteral">class map_value_compare {</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="stringliteral">  template &lt;typename Params&gt;</span></div>
<div class="line"><a name="l00342"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1map__value__compare.html#a3890c9c76b2785f6397396f3a7420c12">  342</a></span>&#160;<span class="stringliteral">  friend class btree;</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral">  // Note: this `protected` is part of the API of std::map::value_compare. See</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="stringliteral">  // https://en.cppreference.com/w/cpp/container/map/value_compare.</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="stringliteral"> protected:</span></div>
<div class="line"><a name="l00347"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1map__value__compare.html#ac0d03fc7fb63e55f9f102c6a401c7343">  347</a></span>&#160;<span class="stringliteral">  explicit map_value_compare(original_key_compare c) : comp(std::move(c)) {}</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00349"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1map__value__compare.html#a39d7b8882d8a1f6381ee9afc644f71e3">  349</a></span>&#160;<span class="stringliteral">  original_key_compare comp;  // NOLINT</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l00352"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1map__value__compare.html#a1c7d8a48bfd86b34662aa4b594b720a6">  352</a></span>&#160;<span class="stringliteral">  auto operator()(const value_type &amp;lhs, const value_type &amp;rhs) const</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="stringliteral">      -&gt; decltype(comp(lhs.first, rhs.first)) {</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="stringliteral">    return comp(lhs.first, rhs.first);</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="stringliteral">template &lt;typename Key, typename Compare, typename Alloc, int TargetNodeSize,</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="stringliteral">          bool IsMulti, bool IsMap, typename SlotPolicy&gt;</span></div>
<div class="line"><a name="l00360"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html">  360</a></span>&#160;<span class="stringliteral">struct common_params : common_policy_traits&lt;SlotPolicy&gt; {</span></div>
<div class="line"><a name="l00361"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a28f813e518ffd89b653fc00015f5e198">  361</a></span>&#160;<span class="stringliteral">  using original_key_compare = Compare;</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="stringliteral">  // If Compare is a common comparator for a string-like type, then we adapt it</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="stringliteral">  // to use heterogeneous lookup and to be a key-compare-to comparator.</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="stringliteral">  // We also adapt the comparator to diagnose invalid comparators in debug mode.</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="stringliteral">  // We disable this when `Compare` is invalid in a way that will cause</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="stringliteral">  // adaptation to fail (having invalid return type) so that we can give a</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="stringliteral">  // better compilation failure in static_assert_validation. If we don&#39;t do</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="stringliteral">  // this, then there will be cascading compilation failures that are confusing</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="stringliteral">  // for users.</span></div>
<div class="line"><a name="l00371"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a21965707f0616348673ce20524bcf926">  371</a></span>&#160;<span class="stringliteral">  using key_compare =</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="stringliteral">      absl::conditional_t&lt;!compare_has_valid_result_type&lt;Compare, Key&gt;(),</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="stringliteral">                          Compare,</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="stringliteral">                          typename key_compare_adapter&lt;Compare, Key&gt;::type&gt;;</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00376"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a8233602c6e71d61702f101f55d0b633b">  376</a></span>&#160;<span class="stringliteral">  static constexpr bool kIsKeyCompareStringAdapted =</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="stringliteral">      std::is_same&lt;key_compare, StringBtreeDefaultLess&gt;::value ||</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="stringliteral">      std::is_same&lt;key_compare, StringBtreeDefaultGreater&gt;::value;</span></div>
<div class="line"><a name="l00379"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#aba6c38e947b6abd7f965f06294b343d2">  379</a></span>&#160;<span class="stringliteral">  static constexpr bool kIsKeyCompareTransparent =</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="stringliteral">      IsTransparent&lt;original_key_compare&gt;::value || kIsKeyCompareStringAdapted;</span></div>
<div class="line"><a name="l00381"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a69600ddd5d7bff05c59bbdfa8aaddc2f">  381</a></span>&#160;<span class="stringliteral">  static constexpr bool kEnableGenerations =</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="stringliteral">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="stringliteral">      true;</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="stringliteral">#else</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="stringliteral">      false;</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="stringliteral">  // A type which indicates if we have a key-compare-to functor or a plain old</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="stringliteral">  // key-compare functor.</span></div>
<div class="line"><a name="l00390"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a97c52d88d00c267a1a8f788aa1b0cca7">  390</a></span>&#160;<span class="stringliteral">  using is_key_compare_to = btree_is_key_compare_to&lt;key_compare, Key&gt;;</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00392"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#ab58ffb514a1c8b7dc2737ebf23858d62">  392</a></span>&#160;<span class="stringliteral">  using allocator_type = Alloc;</span></div>
<div class="line"><a name="l00393"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a8dd278e9c375bcdaf1d4a7455bc8f6d3">  393</a></span>&#160;<span class="stringliteral">  using key_type = Key;</span></div>
<div class="line"><a name="l00394"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a0cb89a96bef730c16333f64e2ba14cb8">  394</a></span>&#160;<span class="stringliteral">  using size_type = size_t;</span></div>
<div class="line"><a name="l00395"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a54bbb63a0bf90792b915647db30dd0d5">  395</a></span>&#160;<span class="stringliteral">  using difference_type = ptrdiff_t;</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00397"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a2aa7dd22aab2c3f62b1e67dee8b90612">  397</a></span>&#160;<span class="stringliteral">  using slot_policy = SlotPolicy;</span></div>
<div class="line"><a name="l00398"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a319b5ea82df95383c9817e610052a949">  398</a></span>&#160;<span class="stringliteral">  using slot_type = typename slot_policy::slot_type;</span></div>
<div class="line"><a name="l00399"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#aaf7d6108812287c2d06522283a853e62">  399</a></span>&#160;<span class="stringliteral">  using value_type = typename slot_policy::value_type;</span></div>
<div class="line"><a name="l00400"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a4bab1a477235302fecc477eac5acf948">  400</a></span>&#160;<span class="stringliteral">  using init_type = typename slot_policy::mutable_value_type;</span></div>
<div class="line"><a name="l00401"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#acdc22b6eb53470ae44902ccc2a9e03f2">  401</a></span>&#160;<span class="stringliteral">  using pointer = value_type *;</span></div>
<div class="line"><a name="l00402"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a91bb601782a123b30f0eabbaaa419761">  402</a></span>&#160;<span class="stringliteral">  using const_pointer = const value_type *;</span></div>
<div class="line"><a name="l00403"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a2a4d3d73ab2ce0e1415cf1143b0a5ee3">  403</a></span>&#160;<span class="stringliteral">  using reference = value_type &amp;;</span></div>
<div class="line"><a name="l00404"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a7ef34cea550c3460eeacdabc08eb810a">  404</a></span>&#160;<span class="stringliteral">  using const_reference = const value_type &amp;;</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00406"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a21be7d83671e328cdf836b612b513c01">  406</a></span>&#160;<span class="stringliteral">  using value_compare =</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="stringliteral">      absl::conditional_t&lt;IsMap,</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="stringliteral">                          map_value_compare&lt;original_key_compare, value_type&gt;,</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="stringliteral">                          original_key_compare&gt;;</span></div>
<div class="line"><a name="l00410"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#ab9426c223755eaf7ccd5dd97b30a3c45">  410</a></span>&#160;<span class="stringliteral">  using is_map_container = std::integral_constant&lt;bool, IsMap&gt;;</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral">  // For the given lookup key type, returns whether we can have multiple</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral">  // equivalent keys in the btree. If this is a multi-container, then we can.</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="stringliteral">  // Otherwise, we can have multiple equivalent keys only if all of the</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="stringliteral">  // following conditions are met:</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="stringliteral">  // - The comparator is transparent.</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="stringliteral">  // - The lookup key type is not the same as key_type.</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="stringliteral">  // - The comparator is not a StringBtreeDefault{Less,Greater} comparator</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="stringliteral">  //   that we know has the same equivalence classes for all lookup types.</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="stringliteral">  template &lt;typename LookupKey&gt;</span></div>
<div class="line"><a name="l00421"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#a74d92f62c795a8870764d220d75d5362">  421</a></span>&#160;<span class="stringliteral">  constexpr static bool can_have_multiple_equivalent_keys() {</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="stringliteral">    return IsMulti || (IsTransparent&lt;key_compare&gt;::value &amp;&amp;</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="stringliteral">                       !std::is_same&lt;LookupKey, Key&gt;::value &amp;&amp;</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="stringliteral">                       !kIsKeyCompareStringAdapted);</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="stringliteral">  enum {</span></div>
<div class="line"><a name="l00428"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#ad2ecd948adb45d31c5174c387747bc00ae6c04f44e1d68ce1eca8e247ce145120">  428</a></span>&#160;<span class="stringliteral">    kTargetNodeSize = TargetNodeSize,</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="stringliteral">    // Upper bound for the available space for slots. This is largest for leaf</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="stringliteral">    // nodes, which have overhead of at least a pointer + 4 bytes (for storing</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="stringliteral">    // 3 field_types and an enum).</span></div>
<div class="line"><a name="l00433"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#ad2ecd948adb45d31c5174c387747bc00a342d76706390d273982aaa77877381c2">  433</a></span>&#160;<span class="stringliteral">    kNodeSlotSpace = TargetNodeSize - /*minimum overhead=*/(sizeof(void *) + 4),</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="stringliteral">  };</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="stringliteral">  // This is an integral type large enough to hold as many slots as will fit a</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="stringliteral">  // node of TargetNodeSize bytes.</span></div>
<div class="line"><a name="l00438"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1common__params.html#aad51d7a2a4665ddf07c9c2841d2ccc8a">  438</a></span>&#160;<span class="stringliteral">  using node_count_type =</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="stringliteral">      absl::conditional_t&lt;(kNodeSlotSpace / sizeof(slot_type) &gt;</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="stringliteral">                           (std::numeric_limits&lt;uint8_t&gt;::max)()),</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="stringliteral">                          uint16_t, uint8_t&gt;;  // NOLINT</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="stringliteral">// An adapter class that converts a lower-bound compare into an upper-bound</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="stringliteral">// compare. Note: there is no need to make a version of this adapter specialized</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="stringliteral">// for key-compare-to functors because the upper-bound (the first value greater</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="stringliteral">// than the input) is never an exact match.</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="stringliteral">template &lt;typename Compare&gt;</span></div>
<div class="line"><a name="l00449"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1upper__bound__adapter.html">  449</a></span>&#160;<span class="stringliteral">struct upper_bound_adapter {</span></div>
<div class="line"><a name="l00450"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1upper__bound__adapter.html#a63cb639320db132f9f3229406e492b1b">  450</a></span>&#160;<span class="stringliteral">  explicit upper_bound_adapter(const Compare &amp;c) : comp(c) {}</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="stringliteral">  template &lt;typename K1, typename K2&gt;</span></div>
<div class="line"><a name="l00452"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1upper__bound__adapter.html#a9824bd6cdfcfbcd310f9b71117fefda7">  452</a></span>&#160;<span class="stringliteral">  bool operator()(const K1 &amp;a, const K2 &amp;b) const {</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="stringliteral">    // Returns true when a is not greater than b.</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="stringliteral">    return !compare_internal::compare_result_as_less_than(comp(b, a));</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="stringliteral">  Compare comp;</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00461"></a><span class="lineno"><a class="line" href="namespaceabsl_1_1container__internal.html#af1e15c6a8cc6740050435f4a6719acbc">  461</a></span>&#160;<span class="stringliteral">enum class MatchKind : uint8_t { kEq, kNe };</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral">template &lt;typename V, bool IsCompareTo&gt;</span></div>
<div class="line"><a name="l00464"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result.html">  464</a></span>&#160;<span class="stringliteral">struct SearchResult {</span></div>
<div class="line"><a name="l00465"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result.html#ae07fce6061bf369ba4ae080871efaca6">  465</a></span>&#160;<span class="stringliteral">  V value;</span></div>
<div class="line"><a name="l00466"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result.html#a77fed91be272df7099b4509411016705">  466</a></span>&#160;<span class="stringliteral">  MatchKind match;</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00468"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result.html#a7db301010060cceb3599129b761303aa">  468</a></span>&#160;<span class="stringliteral">  static constexpr bool HasMatch() { return true; }</span></div>
<div class="line"><a name="l00469"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result.html#ab93bfec62f4c058a1765a6da746d8931">  469</a></span>&#160;<span class="stringliteral">  bool IsEq() const { return match == MatchKind::kEq; }</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="stringliteral">// When we don&#39;t use CompareTo, `match` is not present.</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="stringliteral">// This ensures that callers can&#39;t use it accidentally when it provides no</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral">// useful information.</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral">template &lt;typename V&gt;</span></div>
<div class="line"><a name="l00476"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html">  476</a></span>&#160;<span class="stringliteral">struct SearchResult&lt;V, false&gt; {</span></div>
<div class="line"><a name="l00477"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html#a0e3625df16149b52f6cf038af5a978db">  477</a></span>&#160;<span class="stringliteral">  SearchResult() {}</span></div>
<div class="line"><a name="l00478"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html#ad7b290fe0725c2482138bf79a2c6a1e1">  478</a></span>&#160;<span class="stringliteral">  explicit SearchResult(V v) : value(v) {}</span></div>
<div class="line"><a name="l00479"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html#a7a71adfdbef6003be4c0c31a8b1a3888">  479</a></span>&#160;<span class="stringliteral">  SearchResult(V v, MatchKind /*match*/) : value(v) {}</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00481"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html#aca5cd7322fb6253b5f9696cfd1954ed7">  481</a></span>&#160;<span class="stringliteral">  V value;</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00483"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html#a2beb0fda24017cafb3610fc44261683c">  483</a></span>&#160;<span class="stringliteral">  static constexpr bool HasMatch() { return false; }</span></div>
<div class="line"><a name="l00484"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1_search_result_3_01_v_00_01false_01_4.html#ab2445d97b3898a2d52628a9719652851">  484</a></span>&#160;<span class="stringliteral">  static constexpr bool IsEq() { return false; }</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="stringliteral">// A node in the btree holding. The same node type is used for both internal</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="stringliteral">// and leaf nodes in the btree, though the nodes are allocated in such a way</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="stringliteral">// that the children array is only valid in internal nodes.</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="stringliteral">template &lt;typename Params&gt;</span></div>
<div class="line"><a name="l00491"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html">  491</a></span>&#160;<span class="stringliteral">class btree_node {</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="stringliteral">  using is_key_compare_to = typename Params::is_key_compare_to;</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="stringliteral">  using field_type = typename Params::node_count_type;</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="stringliteral">  using allocator_type = typename Params::allocator_type;</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="stringliteral">  using slot_type = typename Params::slot_type;</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="stringliteral">  using original_key_compare = typename Params::original_key_compare;</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l00499"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a66773175c73247d0d6be9219652bd5aa">  499</a></span>&#160;<span class="stringliteral">  using params_type = Params;</span></div>
<div class="line"><a name="l00500"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a6a40f3ee99f46cd8f7699d6c96b204e0">  500</a></span>&#160;<span class="stringliteral">  using key_type = typename Params::key_type;</span></div>
<div class="line"><a name="l00501"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a284e7bbd5f95ca4f7488a0c8ac4be58b">  501</a></span>&#160;<span class="stringliteral">  using value_type = typename Params::value_type;</span></div>
<div class="line"><a name="l00502"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a812413cc693b790d7feca943d541e477">  502</a></span>&#160;<span class="stringliteral">  using pointer = typename Params::pointer;</span></div>
<div class="line"><a name="l00503"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a9f82f5f6391bd3655136c92ec173a181">  503</a></span>&#160;<span class="stringliteral">  using const_pointer = typename Params::const_pointer;</span></div>
<div class="line"><a name="l00504"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a614eb3fdfb01de1d5c22790d19405c20">  504</a></span>&#160;<span class="stringliteral">  using reference = typename Params::reference;</span></div>
<div class="line"><a name="l00505"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#acf2a6b299dbd603e893c1c3d62486556">  505</a></span>&#160;<span class="stringliteral">  using const_reference = typename Params::const_reference;</span></div>
<div class="line"><a name="l00506"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a431252c017022a5c4bfe958fd2331c83">  506</a></span>&#160;<span class="stringliteral">  using key_compare = typename Params::key_compare;</span></div>
<div class="line"><a name="l00507"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ac240ee430499543c3d3ba412c417f49e">  507</a></span>&#160;<span class="stringliteral">  using size_type = typename Params::size_type;</span></div>
<div class="line"><a name="l00508"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ac7ee663366b8acf8f7e62389411fea0d">  508</a></span>&#160;<span class="stringliteral">  using difference_type = typename Params::difference_type;</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="stringliteral">  // Btree decides whether to use linear node search as follows:</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="stringliteral">  //   - If the comparator expresses a preference, use that.</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="stringliteral">  //   - If the key expresses a preference, use that.</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="stringliteral">  //   - If the key is arithmetic and the comparator is std::less or</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="stringliteral">  //     std::greater, choose linear.</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="stringliteral">  //   - Otherwise, choose binary.</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="stringliteral">  // TODO(ezb): Might make sense to add condition(s) based on node-size.</span></div>
<div class="line"><a name="l00517"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ad52ad10524c911f570f691001373517b">  517</a></span>&#160;<span class="stringliteral">  using use_linear_search = std::integral_constant&lt;</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="stringliteral">      bool, has_linear_node_search_preference&lt;original_key_compare&gt;::value</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="stringliteral">                ? prefers_linear_node_search&lt;original_key_compare&gt;::value</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="stringliteral">            : has_linear_node_search_preference&lt;key_type&gt;::value</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="stringliteral">                ? prefers_linear_node_search&lt;key_type&gt;::value</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="stringliteral">                : std::is_arithmetic&lt;key_type&gt;::value &amp;&amp;</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="stringliteral">                      (std::is_same&lt;std::less&lt;key_type&gt;,</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="stringliteral">                                    original_key_compare&gt;::value ||</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="stringliteral">                       std::is_same&lt;std::greater&lt;key_type&gt;,</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="stringliteral">                                    original_key_compare&gt;::value)&gt;;</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="stringliteral">  // This class is organized by absl::container_internal::Layout as if it had</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="stringliteral">  // the following structure:</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="stringliteral">  //   // A pointer to the node&#39;s parent.</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="stringliteral">  //   btree_node *parent;</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="stringliteral">  //</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="stringliteral">  //   // When ABSL_BTREE_ENABLE_GENERATIONS is defined, we also have a</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="stringliteral">  //   // generation integer in order to check that when iterators are</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="stringliteral">  //   // used, they haven&#39;t been invalidated already. Only the generation on</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="stringliteral">  //   // the root is used, but we have one on each node because whether a node</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="stringliteral">  //   // is root or not can change.</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="stringliteral">  //   uint32_t generation;</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="stringliteral">  //</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="stringliteral">  //   // The position of the node in the node&#39;s parent.</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="stringliteral">  //   field_type position;</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="stringliteral">  //   // The index of the first populated value in `values`.</span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="stringliteral">  //   // TODO(ezb): right now, `start` is always 0. Update insertion/merge</span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="stringliteral">  //   // logic to allow for floating storage within nodes.</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="stringliteral">  //   field_type start;</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="stringliteral">  //   // The index after the last populated value in `values`. Currently, this</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="stringliteral">  //   // is the same as the count of values.</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="stringliteral">  //   field_type finish;</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="stringliteral">  //   // The maximum number of values the node can hold. This is an integer in</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="stringliteral">  //   // [1, kNodeSlots] for root leaf nodes, kNodeSlots for non-root leaf</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="stringliteral">  //   // nodes, and kInternalNodeMaxCount (as a sentinel value) for internal</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="stringliteral">  //   // nodes (even though there are still kNodeSlots values in the node).</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="stringliteral">  //   // TODO(ezb): make max_count use only 4 bits and record log2(capacity)</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="stringliteral">  //   // to free extra bits for is_root, etc.</span></div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="stringliteral">  //   field_type max_count;</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="stringliteral">  //</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="stringliteral">  //   // The array of values. The capacity is `max_count` for leaf nodes and</span></div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="stringliteral">  //   // kNodeSlots for internal nodes. Only the values in</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="stringliteral">  //   // [start, finish) have been initialized and are valid.</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="stringliteral">  //   slot_type values[max_count];</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="stringliteral">  //</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="stringliteral">  //   // The array of child pointers. The keys in children[i] are all less</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="stringliteral">  //   // than key(i). The keys in children[i + 1] are all greater than key(i).</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="stringliteral">  //   // There are 0 children for leaf nodes and kNodeSlots + 1 children for</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="stringliteral">  //   // internal nodes.</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="stringliteral">  //   btree_node *children[kNodeSlots + 1];</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="stringliteral">  //</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="stringliteral">  // This class is only constructed by EmptyNodeType. Normally, pointers to the</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="stringliteral">  // layout above are allocated, cast to btree_node*, and de-allocated within</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="stringliteral">  // the btree implementation.</span></div>
<div class="line"><a name="l00571"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a9edb856d17e9c0dd0eae471b931f20c4">  571</a></span>&#160;<span class="stringliteral">  ~btree_node() = default;</span></div>
<div class="line"><a name="l00572"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a2dbc7335db3b069a42ab5b2e9a233b33">  572</a></span>&#160;<span class="stringliteral">  btree_node(btree_node const &amp;) = delete;</span></div>
<div class="line"><a name="l00573"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ad8cf8e728e6a1b3032c1f022056bb40c">  573</a></span>&#160;<span class="stringliteral">  btree_node &amp;operator=(btree_node const &amp;) = delete;</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral">  // Public for EmptyNodeType.</span></div>
<div class="line"><a name="l00576"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a8d80b6529ba69b83651211dd77696a5a">  576</a></span>&#160;<span class="stringliteral">  constexpr static size_type Alignment() {</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral">    static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral">                  &quot;</span>Alignment of all nodes must be <a class="code" href="namespaceabsl.html#a2b450b606cc6db74111d91871e5242e8">equal</a>.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral">    return InternalLayout().Alignment();</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral"> protected:</span></div>
<div class="line"><a name="l00583"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ab851a48a737998bbc67bf5f6f10ced5e">  583</a></span>&#160;<span class="stringliteral">  btree_node() = default;</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral">  using layout_type =</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral">      absl::container_internal::Layout&lt;btree_node *, uint32_t, field_type,</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral">                                       slot_type, btree_node *&gt;;</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral">  constexpr static size_type SizeWithNSlots(size_type n) {</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral">    return layout_type(</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral">               /*parent*/ 1,</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral">               /*generation*/ params_type::kEnableGenerations ? 1 : 0,</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral">               /*position, start, finish, max_count*/ 4,</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="stringliteral">               /*slots*/ n,</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="stringliteral">               /*children*/ 0)</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="stringliteral">        .AllocSize();</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="stringliteral">  // A lower bound for the overhead of fields other than slots in a leaf node.</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="stringliteral">  constexpr static size_type MinimumOverhead() {</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="stringliteral">    return SizeWithNSlots(1) - sizeof(slot_type);</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="stringliteral">  // Compute how many values we can fit onto a leaf node taking into account</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral">  // padding.</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral">  constexpr static size_type NodeTargetSlots(const size_type begin,</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral">                                             const size_type end) {</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral">    return begin == end ? begin</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="stringliteral">           : SizeWithNSlots((begin + end) / 2 + 1) &gt;</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="stringliteral">                   params_type::kTargetNodeSize</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral">               ? NodeTargetSlots(begin, (begin + end) / 2)</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral">               : NodeTargetSlots((begin + end) / 2 + 1, end);</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral">  constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral">  constexpr static size_type kNodeTargetSlots =</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral">      NodeTargetSlots(0, kTargetNodeSize);</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral">  // We need a minimum of 3 slots per internal node in order to perform</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral">  // splitting (1 value for the two nodes involved in the split and 1 value</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral">  // propagated to the parent as the delimiter for the split). For performance</span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="stringliteral">  // reasons, we don&#39;t allow 3 slots-per-node due to bad worst case occupancy of</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="stringliteral">  // 1/3 (for a node, not a b-tree).</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="stringliteral">  constexpr static size_type kMinNodeSlots = 4;</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="stringliteral">  constexpr static size_type kNodeSlots =</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="stringliteral">      kNodeTargetSlots &gt;= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="stringliteral">  // The node is internal (i.e. is not a leaf node) if and only if `max_count`</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="stringliteral">  // has this value.</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="stringliteral">  constexpr static field_type kInternalNodeMaxCount = 0;</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="stringliteral">  // Leaves can have less than kNodeSlots values.</span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="stringliteral">  constexpr static layout_type LeafLayout(</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="stringliteral">      const size_type slot_count = kNodeSlots) {</span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="stringliteral">    return layout_type(</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="stringliteral">        /*parent*/ 1,</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="stringliteral">        /*generation*/ params_type::kEnableGenerations ? 1 : 0,</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="stringliteral">        /*position, start, finish, max_count*/ 4,</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="stringliteral">        /*slots*/ slot_count,</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="stringliteral">        /*children*/ 0);</span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="stringliteral">  constexpr static layout_type InternalLayout() {</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="stringliteral">    return layout_type(</span></div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="stringliteral">        /*parent*/ 1,</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="stringliteral">        /*generation*/ params_type::kEnableGenerations ? 1 : 0,</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="stringliteral">        /*position, start, finish, max_count*/ 4,</span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="stringliteral">        /*slots*/ kNodeSlots,</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="stringliteral">        /*children*/ kNodeSlots + 1);</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="stringliteral">  constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="stringliteral">    return LeafLayout(slot_count).AllocSize();</span></div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="stringliteral">  constexpr static size_type InternalSize() {</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="stringliteral">    return InternalLayout().AllocSize();</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="stringliteral">  // N is the index of the type in the Layout definition.</span></div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="stringliteral">  // ElementType&lt;N&gt; is the Nth type in the Layout definition.</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="stringliteral">  template &lt;size_type N&gt;</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="stringliteral">  inline typename layout_type::template ElementType&lt;N&gt; *GetField() {</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="stringliteral">    // We assert that we don&#39;t read from values that aren&#39;t there.</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="stringliteral">    assert(N &lt; 4 || is_internal());</span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="stringliteral">    return InternalLayout().template Pointer&lt;N&gt;(reinterpret_cast&lt;char *&gt;(this));</span></div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="stringliteral">  template &lt;size_type N&gt;</span></div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="stringliteral">  inline const typename layout_type::template ElementType&lt;N&gt; *GetField() const {</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="stringliteral">    assert(N &lt; 4 || is_internal());</span></div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="stringliteral">    return InternalLayout().template Pointer&lt;N&gt;(</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="stringliteral">        reinterpret_cast&lt;const char *&gt;(this));</span></div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="stringliteral">  void set_parent(btree_node *p) { *GetField&lt;0&gt;() = p; }</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="stringliteral">  field_type &amp;mutable_finish() { return GetField&lt;2&gt;()[2]; }</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="stringliteral">  slot_type *slot(size_type i) { return &amp;GetField&lt;3&gt;()[i]; }</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="stringliteral">  slot_type *start_slot() { return slot(start()); }</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="stringliteral">  slot_type *finish_slot() { return slot(finish()); }</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="stringliteral">  const slot_type *slot(size_type i) const { return &amp;GetField&lt;3&gt;()[i]; }</span></div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="stringliteral">  void set_position(field_type v) { GetField&lt;2&gt;()[0] = v; }</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="stringliteral">  void set_start(field_type v) { GetField&lt;2&gt;()[1] = v; }</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="stringliteral">  void set_finish(field_type v) { GetField&lt;2&gt;()[2] = v; }</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="stringliteral">  // This method is only called by the node init methods.</span></div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="stringliteral">  void set_max_count(field_type v) { GetField&lt;2&gt;()[3] = v; }</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="stringliteral">  // Whether this is a leaf node or not. This value doesn&#39;t change after the</span></div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="stringliteral">  // node is created.</span></div>
<div class="line"><a name="l00686"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ac14606fc62029bf09f10d184b48293f4">  686</a></span>&#160;<span class="stringliteral">  bool is_leaf() const { return GetField&lt;2&gt;()[3] != kInternalNodeMaxCount; }</span></div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="stringliteral">  // Whether this is an internal node or not. This value doesn&#39;t change after</span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="stringliteral">  // the node is created.</span></div>
<div class="line"><a name="l00689"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a157156330d132572a61c15d12d450afb">  689</a></span>&#160;<span class="stringliteral">  bool is_internal() const { return !is_leaf(); }</span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="stringliteral">  // Getter for the position of this node in its parent.</span></div>
<div class="line"><a name="l00692"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a2ca19d7f40119c375da611953efbe14c">  692</a></span>&#160;<span class="stringliteral">  field_type position() const { return GetField&lt;2&gt;()[0]; }</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="stringliteral">  // Getter for the offset of the first value in the `values` array.</span></div>
<div class="line"><a name="l00695"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a46a94e51fc14b7dcbf709ddfbf28c224">  695</a></span>&#160;<span class="stringliteral">  field_type start() const {</span></div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="stringliteral">    // TODO(ezb): when floating storage is implemented, return GetField&lt;2&gt;()[1];</span></div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="stringliteral">    assert(GetField&lt;2&gt;()[1] == 0);</span></div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="stringliteral">    return 0;</span></div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="stringliteral">  // Getter for the offset after the last value in the `values` array.</span></div>
<div class="line"><a name="l00702"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a5278e501c795351034342a8653072c9c">  702</a></span>&#160;<span class="stringliteral">  field_type finish() const { return GetField&lt;2&gt;()[2]; }</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="stringliteral">  // Getters for the number of values stored in this node.</span></div>
<div class="line"><a name="l00705"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#aa3a30f3038e122719e83285e8ae9503d">  705</a></span>&#160;<span class="stringliteral">  field_type count() const {</span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="stringliteral">    assert(finish() &gt;= start());</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="stringliteral">    return finish() - start();</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00709"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a3070446e7c95787e00e31cf72a2854ec">  709</a></span>&#160;<span class="stringliteral">  field_type max_count() const {</span></div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="stringliteral">    // Internal nodes have max_count==kInternalNodeMaxCount.</span></div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="stringliteral">    // Leaf nodes have max_count in [1, kNodeSlots].</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="stringliteral">    const field_type max_count = GetField&lt;2&gt;()[3];</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="stringliteral">    return max_count == field_type{kInternalNodeMaxCount}</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="stringliteral">               ? field_type{kNodeSlots}</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="stringliteral">               : max_count;</span></div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="stringliteral">  // Getter for the parent of this node.</span></div>
<div class="line"><a name="l00719"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ae1baa66dac8dc0cd568d5ffaba2bbba4">  719</a></span>&#160;<span class="stringliteral">  btree_node *parent() const { return *GetField&lt;0&gt;(); }</span></div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="stringliteral">  // Getter for whether the node is the root of the tree. The parent of the</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="stringliteral">  // root of the tree is the leftmost node in the tree which is guaranteed to</span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="stringliteral">  // be a leaf.</span></div>
<div class="line"><a name="l00723"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ad35cbdc54800c1e1e02cbe72af1dd418">  723</a></span>&#160;<span class="stringliteral">  bool is_root() const { return parent()-&gt;is_leaf(); }</span></div>
<div class="line"><a name="l00724"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a75febfa0f6e4b40b94042284b51c8e95">  724</a></span>&#160;<span class="stringliteral">  void make_root() {</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="stringliteral">    assert(parent()-&gt;is_root());</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="stringliteral">    set_generation(parent()-&gt;generation());</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="stringliteral">    set_parent(parent()-&gt;parent());</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="stringliteral">  // Gets the root node&#39;s generation integer, which is the one used by the tree.</span></div>
<div class="line"><a name="l00731"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#aadec1a139e06db91885f754e3896a48f">  731</a></span>&#160;<span class="stringliteral">  uint32_t *get_root_generation() const {</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="stringliteral">    assert(params_type::kEnableGenerations);</span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="stringliteral">    const btree_node *curr = this;</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="stringliteral">    for (; !curr-&gt;is_root(); curr = curr-&gt;parent()) continue;</span></div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="stringliteral">    return const_cast&lt;uint32_t *&gt;(&amp;curr-&gt;GetField&lt;1&gt;()[0]);</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="stringliteral">  // Returns the generation for iterator validation.</span></div>
<div class="line"><a name="l00739"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a659b8bda770af792bb8eb3b8e3b8d2a9">  739</a></span>&#160;<span class="stringliteral">  uint32_t generation() const {</span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="stringliteral">    return params_type::kEnableGenerations ? *get_root_generation() : 0;</span></div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="stringliteral">  // Updates generation. Should only be called on a root node or during node</span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="stringliteral">  // initialization.</span></div>
<div class="line"><a name="l00744"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a1d86c45e1fc2c045bf70c50c7c16b4e8">  744</a></span>&#160;<span class="stringliteral">  void set_generation(uint32_t generation) {</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="stringliteral">    if (params_type::kEnableGenerations) GetField&lt;1&gt;()[0] = generation;</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="stringliteral">  // Updates the generation. We do this whenever the node is mutated.</span></div>
<div class="line"><a name="l00748"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a6ce430e177efe21f6d4c9a2a9f093aec">  748</a></span>&#160;<span class="stringliteral">  void next_generation() {</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="stringliteral">    if (params_type::kEnableGenerations) ++*get_root_generation();</span></div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="stringliteral">  // Getters for the key/value at position i in the node.</span></div>
<div class="line"><a name="l00753"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a4cfafe195bc9250da1eaff059db826f1">  753</a></span>&#160;<span class="stringliteral">  const key_type &amp;key(size_type i) const { return params_type::key(slot(i)); }</span></div>
<div class="line"><a name="l00754"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#abcfe255d8b2a838cdcd206b705ca9f8e">  754</a></span>&#160;<span class="stringliteral">  reference value(size_type i) { return params_type::element(slot(i)); }</span></div>
<div class="line"><a name="l00755"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ab4b64405c6ecef899bba2c4b2422637e">  755</a></span>&#160;<span class="stringliteral">  const_reference value(size_type i) const {</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="stringliteral">    return params_type::element(slot(i));</span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="stringliteral">  // Getters/setter for the child at position i in the node.</span></div>
<div class="line"><a name="l00760"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#abfa26d8ed46862b4881f7c6b92d1ffdd">  760</a></span>&#160;<span class="stringliteral">  btree_node *child(field_type i) const { return GetField&lt;4&gt;()[i]; }</span></div>
<div class="line"><a name="l00761"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a699584ff7e2bb18640897e6daa90d84b">  761</a></span>&#160;<span class="stringliteral">  btree_node *start_child() const { return child(start()); }</span></div>
<div class="line"><a name="l00762"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a7872d3d4b28da1e622bd9c917f327c1d">  762</a></span>&#160;<span class="stringliteral">  btree_node *&amp;mutable_child(field_type i) { return GetField&lt;4&gt;()[i]; }</span></div>
<div class="line"><a name="l00763"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#affae5c6059b85d2e8970380057600618">  763</a></span>&#160;<span class="stringliteral">  void clear_child(field_type i) {</span></div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerPoisonObject(&amp;mutable_child(i));</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00766"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a0973c4f7f0c7254df2e24d353ed6f789">  766</a></span>&#160;<span class="stringliteral">  void set_child(field_type i, btree_node *c) {</span></div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerUnpoisonObject(&amp;mutable_child(i));</span></div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="stringliteral">    mutable_child(i) = c;</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="stringliteral">    c-&gt;set_position(i);</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00771"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a619bb2e742e4c3fdcd4379e6b8274fdb">  771</a></span>&#160;<span class="stringliteral">  void init_child(field_type i, btree_node *c) {</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="stringliteral">    set_child(i, c);</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="stringliteral">    c-&gt;set_parent(this);</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="stringliteral">  // Returns the position of the first value whose key is not less than k.</span></div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l00778"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a4f68fc1e936f463f150516314407698a">  778</a></span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, is_key_compare_to::value&gt; lower_bound(</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="stringliteral">      const K &amp;k, const key_compare &amp;comp) const {</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="stringliteral">    return use_linear_search::value ? linear_search(k, comp)</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="stringliteral">                                    : binary_search(k, comp);</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="stringliteral">  // Returns the position of the first value whose key is greater than k.</span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l00785"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a182abf2c1f6e7fd889cddabf60990ecd">  785</a></span>&#160;<span class="stringliteral">  size_type upper_bound(const K &amp;k, const key_compare &amp;comp) const {</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="stringliteral">    auto upper_compare = upper_bound_adapter&lt;key_compare&gt;(comp);</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="stringliteral">    return use_linear_search::value ? linear_search(k, upper_compare).value</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="stringliteral">                                    : binary_search(k, upper_compare).value;</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="stringliteral">  template &lt;typename K, typename Compare&gt;</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, btree_is_key_compare_to&lt;Compare, key_type&gt;::value&gt;</span></div>
<div class="line"><a name="l00793"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a0ccb09a5124c31d20c2d83ff1d3063bc">  793</a></span>&#160;<span class="stringliteral">  linear_search(const K &amp;k, const Compare &amp;comp) const {</span></div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="stringliteral">    return linear_search_impl(k, start(), finish(), comp,</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="stringliteral">                              btree_is_key_compare_to&lt;Compare, key_type&gt;());</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="stringliteral">  template &lt;typename K, typename Compare&gt;</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, btree_is_key_compare_to&lt;Compare, key_type&gt;::value&gt;</span></div>
<div class="line"><a name="l00800"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a08cfe25254eb264e6b54bf378cf651a3">  800</a></span>&#160;<span class="stringliteral">  binary_search(const K &amp;k, const Compare &amp;comp) const {</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="stringliteral">    return binary_search_impl(k, start(), finish(), comp,</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;<span class="stringliteral">                              btree_is_key_compare_to&lt;Compare, key_type&gt;());</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;<span class="stringliteral">  // Returns the position of the first value whose key is not less than k using</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="stringliteral">  // linear search performed using plain compare.</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="stringliteral">  template &lt;typename K, typename Compare&gt;</span></div>
<div class="line"><a name="l00808"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ace0ee63b1a826f25d376c6eb439fd47b">  808</a></span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, false&gt; linear_search_impl(</span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;<span class="stringliteral">      const K &amp;k, size_type s, const size_type e, const Compare &amp;comp,</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;<span class="stringliteral">      std::false_type /* IsCompareTo */) const {</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;<span class="stringliteral">    while (s &lt; e) {</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;<span class="stringliteral">      if (!comp(key(s), k)) {</span></div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="stringliteral">        break;</span></div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="stringliteral">      ++s;</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="stringliteral">    return SearchResult&lt;size_type, false&gt;{s};</span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="stringliteral">  // Returns the position of the first value whose key is not less than k using</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="stringliteral">  // linear search performed using compare-to.</span></div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="stringliteral">  template &lt;typename K, typename Compare&gt;</span></div>
<div class="line"><a name="l00823"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ad01546b62e09ac88569206ecf2266ead">  823</a></span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, true&gt; linear_search_impl(</span></div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="stringliteral">      const K &amp;k, size_type s, const size_type e, const Compare &amp;comp,</span></div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="stringliteral">      std::true_type /* IsCompareTo */) const {</span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="stringliteral">    while (s &lt; e) {</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="stringliteral">      const absl::weak_ordering c = comp(key(s), k);</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="stringliteral">      if (c == 0) {</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="stringliteral">        return {s, MatchKind::kEq};</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="stringliteral">      } else if (c &gt; 0) {</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="stringliteral">        break;</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="stringliteral">      ++s;</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="stringliteral">    return {s, MatchKind::kNe};</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="stringliteral">  // Returns the position of the first value whose key is not less than k using</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="stringliteral">  // binary search performed using plain compare.</span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="stringliteral">  template &lt;typename K, typename Compare&gt;</span></div>
<div class="line"><a name="l00841"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a3f260003b7a359b075c41dfc73f235d7">  841</a></span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, false&gt; binary_search_impl(</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="stringliteral">      const K &amp;k, size_type s, size_type e, const Compare &amp;comp,</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="stringliteral">      std::false_type /* IsCompareTo */) const {</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="stringliteral">    while (s != e) {</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="stringliteral">      const size_type mid = (s + e) &gt;&gt; 1;</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="stringliteral">      if (comp(key(mid), k)) {</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="stringliteral">        s = mid + 1;</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="stringliteral">      } else {</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="stringliteral">        e = mid;</span></div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="stringliteral">    return SearchResult&lt;size_type, false&gt;{s};</span></div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="stringliteral">  // Returns the position of the first value whose key is not less than k using</span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="stringliteral">  // binary search performed using compare-to.</span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="stringliteral">  template &lt;typename K, typename CompareTo&gt;</span></div>
<div class="line"><a name="l00858"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a300baf520a2e19dd6ce93f74fed0e7e3">  858</a></span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, true&gt; binary_search_impl(</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="stringliteral">      const K &amp;k, size_type s, size_type e, const CompareTo &amp;comp,</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="stringliteral">      std::true_type /* IsCompareTo */) const {</span></div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="stringliteral">    if (params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {</span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="stringliteral">      MatchKind exact_match = MatchKind::kNe;</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="stringliteral">      while (s != e) {</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="stringliteral">        const size_type mid = (s + e) &gt;&gt; 1;</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="stringliteral">        const absl::weak_ordering c = comp(key(mid), k);</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="stringliteral">        if (c &lt; 0) {</span></div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="stringliteral">          s = mid + 1;</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="stringliteral">        } else {</span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="stringliteral">          e = mid;</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="stringliteral">          if (c == 0) {</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="stringliteral">            // Need to return the first value whose key is not less than k,</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="stringliteral">            // which requires continuing the binary search if there could be</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="stringliteral">            // multiple equivalent keys.</span></div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="stringliteral">            exact_match = MatchKind::kEq;</span></div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="stringliteral">          }</span></div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="stringliteral">      return {s, exact_match};</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="stringliteral">    } else {  // Can&#39;t have multiple equivalent keys.</span></div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="stringliteral">      while (s != e) {</span></div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="stringliteral">        const size_type mid = (s + e) &gt;&gt; 1;</span></div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="stringliteral">        const absl::weak_ordering c = comp(key(mid), k);</span></div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="stringliteral">        if (c &lt; 0) {</span></div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="stringliteral">          s = mid + 1;</span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="stringliteral">        } else if (c &gt; 0) {</span></div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="stringliteral">          e = mid;</span></div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="stringliteral">        } else {</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="stringliteral">          return {mid, MatchKind::kEq};</span></div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="stringliteral">      return {s, MatchKind::kNe};</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="stringliteral">  // Emplaces a value at position i, shifting all existing values and</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="stringliteral">  // children at positions &gt;= i to the right by 1.</span></div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="stringliteral">  template &lt;typename... Args&gt;</span></div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="stringliteral">  void emplace_value(field_type i, allocator_type *alloc, Args &amp;&amp;...args);</span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="stringliteral">  // Removes the values at positions [i, i + to_erase), shifting all existing</span></div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="stringliteral">  // values and children after that range to the left by to_erase. Clears all</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="stringliteral">  // children between [i, i + to_erase).</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="stringliteral">  void remove_values(field_type i, field_type to_erase, allocator_type *alloc);</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="stringliteral">  // Rebalances a node with its right sibling.</span></div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="stringliteral">  void rebalance_right_to_left(field_type to_move, btree_node *right,</span></div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="stringliteral">                               allocator_type *alloc);</span></div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="stringliteral">  void rebalance_left_to_right(field_type to_move, btree_node *right,</span></div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="stringliteral">                               allocator_type *alloc);</span></div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;<span class="stringliteral">  // Splits a node, moving a portion of the node&#39;s values to its right sibling.</span></div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="stringliteral">  void split(int insert_position, btree_node *dest, allocator_type *alloc);</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;<span class="stringliteral">  // Merges a node with its right sibling, moving all of the values and the</span></div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="stringliteral">  // delimiting key in the parent node onto itself, and deleting the src node.</span></div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="stringliteral">  void merge(btree_node *src, allocator_type *alloc);</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="stringliteral">  // Node allocation/deletion routines.</span></div>
<div class="line"><a name="l00919"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a732d743eb75a2ed8ccc8b6bd48c2608a">  919</a></span>&#160;<span class="stringliteral">  void init_leaf(field_type max_count, btree_node *parent) {</span></div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="stringliteral">    set_generation(0);</span></div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="stringliteral">    set_parent(parent);</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="stringliteral">    set_position(0);</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="stringliteral">    set_start(0);</span></div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="stringliteral">    set_finish(0);</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="stringliteral">    set_max_count(max_count);</span></div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerPoisonMemoryRegion(</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="stringliteral">        start_slot(), max_count * sizeof(slot_type));</span></div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00929"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#acdd248eeff44737d5711610d56b2955c">  929</a></span>&#160;<span class="stringliteral">  void init_internal(btree_node *parent) {</span></div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="stringliteral">    init_leaf(kNodeSlots, parent);</span></div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="stringliteral">    // Set `max_count` to a sentinel value to indicate that this node is</span></div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="stringliteral">    // internal.</span></div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="stringliteral">    set_max_count(kInternalNodeMaxCount);</span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerPoisonMemoryRegion(</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="stringliteral">        &amp;mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00938"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a0156055a1a4006e02037e4351f9b1d05">  938</a></span>&#160;<span class="stringliteral">  static void deallocate(const size_type size, btree_node *node,</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="stringliteral">                         allocator_type *alloc) {</span></div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="stringliteral">    absl::container_internal::Deallocate&lt;Alignment()&gt;(alloc, node, size);</span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="stringliteral">  // Deletes a node and all of its children.</span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="stringliteral">  static void clear_and_delete(btree_node *node, allocator_type *alloc);</span></div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="stringliteral">  template &lt;typename... Args&gt;</span></div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="stringliteral">  void value_init(const field_type i, allocator_type *alloc, Args &amp;&amp;...args) {</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="stringliteral">    next_generation();</span></div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerUnpoisonObject(slot(i));</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="stringliteral">    params_type::construct(alloc, slot(i), std::forward&lt;Args&gt;(args)...);</span></div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="stringliteral">  void value_destroy(const field_type i, allocator_type *alloc) {</span></div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="stringliteral">    next_generation();</span></div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="stringliteral">    params_type::destroy(alloc, slot(i));</span></div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerPoisonObject(slot(i));</span></div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="stringliteral">  void value_destroy_n(const field_type i, const field_type n,</span></div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="stringliteral">                       allocator_type *alloc) {</span></div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="stringliteral">    next_generation();</span></div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="stringliteral">    for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {</span></div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="stringliteral">      params_type::destroy(alloc, s);</span></div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="stringliteral">      absl::container_internal::SanitizerPoisonObject(s);</span></div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="stringliteral">  static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerUnpoisonObject(dest);</span></div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="stringliteral">    params_type::transfer(alloc, dest, src);</span></div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="stringliteral">    absl::container_internal::SanitizerPoisonObject(src);</span></div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="stringliteral">  // Transfers value from slot `src_i` in `src_node` to slot `dest_i` in `this`.</span></div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="stringliteral">  void transfer(const size_type dest_i, const size_type src_i,</span></div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;<span class="stringliteral">                btree_node *src_node, allocator_type *alloc) {</span></div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="stringliteral">    next_generation();</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;<span class="stringliteral">    transfer(slot(dest_i), src_node-&gt;slot(src_i), alloc);</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="stringliteral">  // Transfers `n` values starting at value `src_i` in `src_node` into the</span></div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="stringliteral">  // values starting at value `dest_i` in `this`.</span></div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;<span class="stringliteral">  void transfer_n(const size_type n, const size_type dest_i,</span></div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;<span class="stringliteral">                  const size_type src_i, btree_node *src_node,</span></div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;<span class="stringliteral">                  allocator_type *alloc) {</span></div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;<span class="stringliteral">    next_generation();</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;<span class="stringliteral">    for (slot_type *src = src_node-&gt;slot(src_i), *end = src + n,</span></div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="stringliteral">                   *dest = slot(dest_i);</span></div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="stringliteral">         src != end; ++src, ++dest) {</span></div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="stringliteral">      transfer(dest, src, alloc);</span></div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;<span class="stringliteral">  // Same as above, except that we start at the end and work our way to the</span></div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="stringliteral">  // beginning.</span></div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="stringliteral">  void transfer_n_backward(const size_type n, const size_type dest_i,</span></div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="stringliteral">                           const size_type src_i, btree_node *src_node,</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="stringliteral">                           allocator_type *alloc) {</span></div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="stringliteral">    next_generation();</span></div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="stringliteral">    for (slot_type *src = src_node-&gt;slot(src_i + n), *end = src - n,</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="stringliteral">                   *dest = slot(dest_i + n);</span></div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="stringliteral">         src != end; --src, --dest) {</span></div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="stringliteral">      // If we modified the loop index calculations above to avoid the -1s here,</span></div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="stringliteral">      // it would result in UB in the computation of `end` (and possibly `src`</span></div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;<span class="stringliteral">      // as well, if n == 0), since slot() is effectively an array index and it</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;<span class="stringliteral">      // is UB to compute the address of any out-of-bounds array element except</span></div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;<span class="stringliteral">      // for one-past-the-end.</span></div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;<span class="stringliteral">      transfer(dest - 1, src - 1, alloc);</span></div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="stringliteral">  template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01013"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a3890c9c76b2785f6397396f3a7420c12"> 1013</a></span>&#160;<span class="stringliteral">  friend class btree;</span></div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;<span class="stringliteral">  template &lt;typename N, typename R, typename P&gt;</span></div>
<div class="line"><a name="l01015"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a1f75df653a78c762d0e23db2fcf6528a"> 1015</a></span>&#160;<span class="stringliteral">  friend class btree_iterator;</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a6d13711b7d4324249c83c4e6f9a0e117"> 1016</a></span>&#160;<span class="stringliteral">  friend class BtreeNodePeer;</span></div>
<div class="line"><a name="l01017"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a9e4b8c582598bba429514b5612082a3b"> 1017</a></span>&#160;<span class="stringliteral">  friend struct btree_access;</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="stringliteral">template &lt;typename Node&gt;</span></div>
<div class="line"><a name="l01021"></a><span class="lineno"><a class="line" href="namespaceabsl_1_1container__internal.html#a265d12198862f7bf39e9d41dc459b07a"> 1021</a></span>&#160;<span class="stringliteral">bool AreNodesFromSameContainer(const Node *node_a, const Node *node_b) {</span></div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="stringliteral">  // If either node is null, then give up on checking whether they&#39;re from the</span></div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="stringliteral">  // same container. (If exactly one is null, then we&#39;ll trigger the</span></div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="stringliteral">  // default-constructed assert in Equals.)</span></div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;<span class="stringliteral">  if (node_a == nullptr || node_b == nullptr) return true;</span></div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;<span class="stringliteral">  while (!node_a-&gt;is_root()) node_a = node_a-&gt;parent();</span></div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;<span class="stringliteral">  while (!node_b-&gt;is_root()) node_b = node_b-&gt;parent();</span></div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;<span class="stringliteral">  return node_a == node_b;</span></div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01031"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__enabled.html"> 1031</a></span>&#160;<span class="stringliteral">class btree_iterator_generation_info_enabled {</span></div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l01033"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__enabled.html#aaac876107438ecd2ba31e81fa1a22fa7"> 1033</a></span>&#160;<span class="stringliteral">  explicit btree_iterator_generation_info_enabled(uint32_t g)</span></div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;<span class="stringliteral">      : generation_(g) {}</span></div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="stringliteral">  // Updates the generation. For use internally right before we return an</span></div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="stringliteral">  // iterator to the user.</span></div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="stringliteral">  template &lt;typename Node&gt;</span></div>
<div class="line"><a name="l01039"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__enabled.html#aeb3db4d5a41126e18892caf8d880f64c"> 1039</a></span>&#160;<span class="stringliteral">  void update_generation(const Node *node) {</span></div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="stringliteral">    if (node != nullptr) generation_ = node-&gt;generation();</span></div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01042"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__enabled.html#aaf7c47e8711b54885038132f32762155"> 1042</a></span>&#160;<span class="stringliteral">  uint32_t generation() const { return generation_; }</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="stringliteral">  template &lt;typename Node&gt;</span></div>
<div class="line"><a name="l01045"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__enabled.html#a554a4de1d2e7917c16de1f0541cb32cf"> 1045</a></span>&#160;<span class="stringliteral">  void assert_valid_generation(const Node *node) const {</span></div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;<span class="stringliteral">    if (node != nullptr &amp;&amp; node-&gt;generation() != generation_) {</span></div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;<span class="stringliteral">      ABSL_INTERNAL_LOG(</span></div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;<span class="stringliteral">          FATAL,</span></div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;<span class="stringliteral">          &quot;</span>Attempting <a class="code" href="layout__test_8cc.html#a633ab603a49d0a046734a0f3e6de45e9">to</a> use an invalidated iterator. The corresponding <a class="code" href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a>-tree <span class="stringliteral">&quot;</span></div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="stringliteral">          &quot;</span>container has been mutated since <span class="keyword">this</span> iterator was constructed.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;<span class="stringliteral">  // Used to check that the iterator hasn&#39;t been invalidated.</span></div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="stringliteral">  uint32_t generation_;</span></div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01059"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__disabled.html"> 1059</a></span>&#160;<span class="stringliteral">class btree_iterator_generation_info_disabled {</span></div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l01061"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__disabled.html#a0e66ea7855fabc077d69fa465f251691"> 1061</a></span>&#160;<span class="stringliteral">  explicit btree_iterator_generation_info_disabled(uint32_t) {}</span></div>
<div class="line"><a name="l01062"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__disabled.html#a8146edcca4698e03db24f8c3c4005ef3"> 1062</a></span>&#160;<span class="stringliteral">  void update_generation(const void *) {}</span></div>
<div class="line"><a name="l01063"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__disabled.html#a8838c7b530e126ae1939821651fc9185"> 1063</a></span>&#160;<span class="stringliteral">  uint32_t generation() const { return 0; }</span></div>
<div class="line"><a name="l01064"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator__generation__info__disabled.html#afae3def183ed967a873c92ca89926927"> 1064</a></span>&#160;<span class="stringliteral">  void assert_valid_generation(const void *) const {}</span></div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="stringliteral">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="stringliteral">using btree_iterator_generation_info = btree_iterator_generation_info_enabled;</span></div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="stringliteral">#else</span></div>
<div class="line"><a name="l01070"></a><span class="lineno"><a class="line" href="namespaceabsl_1_1container__internal.html#a2b4927a35d0740256c16f60a208e19f4"> 1070</a></span>&#160;<span class="stringliteral">using btree_iterator_generation_info = btree_iterator_generation_info_disabled;</span></div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="stringliteral">template &lt;typename Node, typename Reference, typename Pointer&gt;</span></div>
<div class="line"><a name="l01074"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html"> 1074</a></span>&#160;<span class="stringliteral">class btree_iterator : private btree_iterator_generation_info {</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;<span class="stringliteral">  using field_type = typename Node::field_type;</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;<span class="stringliteral">  using key_type = typename Node::key_type;</span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;<span class="stringliteral">  using size_type = typename Node::size_type;</span></div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="stringliteral">  using params_type = typename Node::params_type;</span></div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="stringliteral">  using is_map_container = typename params_type::is_map_container;</span></div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="stringliteral">  using node_type = Node;</span></div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="stringliteral">  using normal_node = typename std::remove_const&lt;Node&gt;::type;</span></div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="stringliteral">  using const_node = const Node;</span></div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="stringliteral">  using normal_pointer = typename params_type::pointer;</span></div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="stringliteral">  using normal_reference = typename params_type::reference;</span></div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="stringliteral">  using const_pointer = typename params_type::const_pointer;</span></div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="stringliteral">  using const_reference = typename params_type::const_reference;</span></div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="stringliteral">  using slot_type = typename params_type::slot_type;</span></div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="stringliteral">  using iterator =</span></div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;<span class="stringliteral">     btree_iterator&lt;normal_node, normal_reference, normal_pointer&gt;;</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="stringliteral">  using const_iterator =</span></div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="stringliteral">      btree_iterator&lt;const_node, const_reference, const_pointer&gt;;</span></div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="stringliteral">  // These aliases are public for std::iterator_traits.</span></div>
<div class="line"><a name="l01097"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a48230b0d540584c344c1dbae936b85f7"> 1097</a></span>&#160;<span class="stringliteral">  using difference_type = typename Node::difference_type;</span></div>
<div class="line"><a name="l01098"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#aa075103f409c0d18be1b52108d9ec012"> 1098</a></span>&#160;<span class="stringliteral">  using value_type = typename params_type::value_type;</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a8cb731f3829c1ab1ef51a347be59cf40"> 1099</a></span>&#160;<span class="stringliteral">  using pointer = Pointer;</span></div>
<div class="line"><a name="l01100"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#ab2013fa25f109fe5ca9b77199c8595ca"> 1100</a></span>&#160;<span class="stringliteral">  using reference = Reference;</span></div>
<div class="line"><a name="l01101"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#aef144f0a2ce1f129160a89310352e4cf"> 1101</a></span>&#160;<span class="stringliteral">  using iterator_category = std::bidirectional_iterator_tag;</span></div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01103"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a57df533b743e0a811887204c37edd05c"> 1103</a></span>&#160;<span class="stringliteral">  btree_iterator() : btree_iterator(nullptr, -1) {}</span></div>
<div class="line"><a name="l01104"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#ae76164c6a4092e71843c19424134cd9f"> 1104</a></span>&#160;<span class="stringliteral">  explicit btree_iterator(Node *n) : btree_iterator(n, n-&gt;start()) {}</span></div>
<div class="line"><a name="l01105"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a86703b5d20606f170a7fb1ebff85f720"> 1105</a></span>&#160;<span class="stringliteral">  btree_iterator(Node *n, int p)</span></div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="stringliteral">      : btree_iterator_generation_info(n != nullptr ? n-&gt;generation()</span></div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="stringliteral">                                                    : ~uint32_t{}),</span></div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="stringliteral">        node_(n),</span></div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="stringliteral">        position_(p) {}</span></div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="stringliteral">  // NOTE: this SFINAE allows for implicit conversions from iterator to</span></div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="stringliteral">  // const_iterator, but it specifically avoids hiding the copy constructor so</span></div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="stringliteral">  // that the trivial one will be used when possible.</span></div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="stringliteral">  template &lt;typename N, typename R, typename P,</span></div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="stringliteral">            absl::enable_if_t&lt;</span></div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="stringliteral">                std::is_same&lt;btree_iterator&lt;N, R, P&gt;, iterator&gt;::value &amp;&amp;</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="stringliteral">                    std::is_same&lt;btree_iterator, const_iterator&gt;::value,</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="stringliteral">                int&gt; = 0&gt;</span></div>
<div class="line"><a name="l01119"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#aebd48d601735d460919040c17a1529cc"> 1119</a></span>&#160;<span class="stringliteral">  btree_iterator(const btree_iterator&lt;N, R, P&gt; other)  // NOLINT</span></div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="stringliteral">      : btree_iterator_generation_info(other),</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="stringliteral">        node_(other.node_),</span></div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="stringliteral">        position_(other.position_) {}</span></div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01124"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a5c15c0dbbee87854b72eacddc974f5a3"> 1124</a></span>&#160;<span class="stringliteral">  bool operator==(const iterator &amp;other) const {</span></div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="stringliteral">    return Equals(other);</span></div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01127"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a70e9fd9063fcaf5cd4e2228f156144f5"> 1127</a></span>&#160;<span class="stringliteral">  bool operator==(const const_iterator &amp;other) const {</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="stringliteral">    return Equals(other);</span></div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01130"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a3962c2b165836d1a6303e509588f8211"> 1130</a></span>&#160;<span class="stringliteral">  bool operator!=(const iterator &amp;other) const {</span></div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="stringliteral">    return !Equals(other);</span></div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01133"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#af695d9225feb696071eb341520674b74"> 1133</a></span>&#160;<span class="stringliteral">  bool operator!=(const const_iterator &amp;other) const {</span></div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="stringliteral">    return !Equals(other);</span></div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="stringliteral">  // Returns n such that n calls to ++other yields *this.</span></div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="stringliteral">  // Precondition: n exists.</span></div>
<div class="line"><a name="l01139"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a764f6954e07fd6fa89151962847cb5b4"> 1139</a></span>&#160;<span class="stringliteral">  difference_type operator-(const_iterator other) const {</span></div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="stringliteral">    if (node_ == other.node_) {</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="stringliteral">      if (node_-&gt;is_leaf()) return position_ - other.position_;</span></div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="stringliteral">      if (position_ == other.position_) return 0;</span></div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="stringliteral">    return distance_slow(other);</span></div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="stringliteral">  // Accessors for the key/value the iterator is pointing at.</span></div>
<div class="line"><a name="l01148"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a310fbdbeecee384bce545a02632e408c"> 1148</a></span>&#160;<span class="stringliteral">  reference operator*() const {</span></div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;<span class="stringliteral">    ABSL_HARDENING_ASSERT(node_ != nullptr);</span></div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="stringliteral">    assert_valid_generation(node_);</span></div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="stringliteral">    ABSL_HARDENING_ASSERT(position_ &gt;= node_-&gt;start());</span></div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="stringliteral">    if (position_ &gt;= node_-&gt;finish()) {</span></div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="stringliteral">      ABSL_HARDENING_ASSERT(!IsEndIterator() &amp;&amp; &quot;</span>Dereferencing <a class="code" href="float__conversion_8cc.html#a8fd806ad19b8f5513a4cf18cbf77532c">end</a>() <a class="code" href="classabsl_1_1container__internal_1_1btree__iterator.html">iterator</a><span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="stringliteral">      ABSL_HARDENING_ASSERT(position_ &lt; node_-&gt;finish());</span></div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="stringliteral">    return node_-&gt;value(static_cast&lt;field_type&gt;(position_));</span></div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01158"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a984d65969b35419d0cd46a8f11d89f0d"> 1158</a></span>&#160;<span class="stringliteral">  pointer operator-&gt;() const { return &amp;operator*(); }</span></div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01160"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a2573fd216622ba5eb03285140956e9ac"> 1160</a></span>&#160;<span class="stringliteral">  btree_iterator &amp;operator++() {</span></div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="stringliteral">    increment();</span></div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="stringliteral">    return *this;</span></div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01164"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a90b93805d6a7306db5c69124536ab555"> 1164</a></span>&#160;<span class="stringliteral">  btree_iterator &amp;operator--() {</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;<span class="stringliteral">    decrement();</span></div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="stringliteral">    return *this;</span></div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01168"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a7f7ed8130b282f88a9e6f4f0edada9cd"> 1168</a></span>&#160;<span class="stringliteral">  btree_iterator operator++(int) {</span></div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;<span class="stringliteral">    btree_iterator tmp = *this;</span></div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="stringliteral">    ++*this;</span></div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="stringliteral">    return tmp;</span></div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01173"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#acf45128f450452867fe6c6df29ed1385"> 1173</a></span>&#160;<span class="stringliteral">  btree_iterator operator--(int) {</span></div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="stringliteral">    btree_iterator tmp = *this;</span></div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="stringliteral">    --*this;</span></div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;<span class="stringliteral">    return tmp;</span></div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="stringliteral">  friend iterator;</span></div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;<span class="stringliteral">  friend const_iterator;</span></div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;<span class="stringliteral">  template &lt;typename Params&gt;</span></div>
<div class="line"><a name="l01183"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a3890c9c76b2785f6397396f3a7420c12"> 1183</a></span>&#160;<span class="stringliteral">  friend class btree;</span></div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;<span class="stringliteral">  template &lt;typename Tree&gt;</span></div>
<div class="line"><a name="l01185"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a76951fec4fe9d307a5d4b720fe4c5e2c"> 1185</a></span>&#160;<span class="stringliteral">  friend class btree_container;</span></div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="stringliteral">  template &lt;typename Tree&gt;</span></div>
<div class="line"><a name="l01187"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a18093a9d44d2e0b36e03dc831ce64daf"> 1187</a></span>&#160;<span class="stringliteral">  friend class btree_set_container;</span></div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;<span class="stringliteral">  template &lt;typename Tree&gt;</span></div>
<div class="line"><a name="l01189"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#ab52763f67d4ad77bb0c5b3b467ba09c6"> 1189</a></span>&#160;<span class="stringliteral">  friend class btree_map_container;</span></div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;<span class="stringliteral">  template &lt;typename Tree&gt;</span></div>
<div class="line"><a name="l01191"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#ad9b4be2e44d63f032e8e0a7bee7784b5"> 1191</a></span>&#160;<span class="stringliteral">  friend class btree_multiset_container;</span></div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;<span class="stringliteral">  template &lt;typename TreeType, typename CheckerType&gt;</span></div>
<div class="line"><a name="l01193"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a92986d02030a178680e14ba864c041bc"> 1193</a></span>&#160;<span class="stringliteral">  friend class base_checker;</span></div>
<div class="line"><a name="l01194"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__iterator.html#a9e4b8c582598bba429514b5612082a3b"> 1194</a></span>&#160;<span class="stringliteral">  friend struct btree_access;</span></div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;<span class="stringliteral">  // This SFINAE allows explicit conversions from const_iterator to</span></div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;<span class="stringliteral">  // iterator, but also avoids hiding the copy constructor.</span></div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;<span class="stringliteral">  // NOTE: the const_cast is safe because this constructor is only called by</span></div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;<span class="stringliteral">  // non-const methods and the container owns the nodes.</span></div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="stringliteral">  template &lt;typename N, typename R, typename P,</span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;<span class="stringliteral">            absl::enable_if_t&lt;</span></div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="stringliteral">                std::is_same&lt;btree_iterator&lt;N, R, P&gt;, const_iterator&gt;::value &amp;&amp;</span></div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="stringliteral">                    std::is_same&lt;btree_iterator, iterator&gt;::value,</span></div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;<span class="stringliteral">                int&gt; = 0&gt;</span></div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="stringliteral">  explicit btree_iterator(const btree_iterator&lt;N, R, P&gt; other)</span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="stringliteral">      : btree_iterator_generation_info(other.generation()),</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="stringliteral">        node_(const_cast&lt;node_type *&gt;(other.node_)),</span></div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="stringliteral">        position_(other.position_) {}</span></div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="stringliteral">  bool Equals(const const_iterator other) const {</span></div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;<span class="stringliteral">    ABSL_HARDENING_ASSERT(((node_ == nullptr &amp;&amp; other.node_ == nullptr) ||</span></div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;<span class="stringliteral">                           (node_ != nullptr &amp;&amp; other.node_ != nullptr)) &amp;&amp;</span></div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;<span class="stringliteral">                          &quot;</span>Comparing <span class="keywordflow">default</span>-constructed <a class="code" href="classabsl_1_1container__internal_1_1btree__iterator.html">iterator</a> with <span class="stringliteral">&quot;</span></div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;<span class="stringliteral">                          &quot;</span>non-<span class="keywordflow">default</span>-constructed <a class="code" href="classabsl_1_1container__internal_1_1btree__iterator.html">iterator</a>.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;<span class="stringliteral">    // Note: we use assert instead of ABSL_HARDENING_ASSERT here because this</span></div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;<span class="stringliteral">    // changes the complexity of Equals from O(1) to O(log(N) + log(M)) where</span></div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;<span class="stringliteral">    // N/M are sizes of the containers containing node_/other.node_.</span></div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="stringliteral">    assert(AreNodesFromSameContainer(node_, other.node_) &amp;&amp;</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="stringliteral">           &quot;</span>Comparing iterators <a class="code" href="layout__test_8cc.html#a66a6152caa0d2dec6985ed86838ba876">from</a> different containers.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="stringliteral">    assert_valid_generation(node_);</span></div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;<span class="stringliteral">    other.assert_valid_generation(other.node_);</span></div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;<span class="stringliteral">    return node_ == other.node_ &amp;&amp; position_ == other.position_;</span></div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;<span class="stringliteral">  bool IsEndIterator() const {</span></div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;<span class="stringliteral">    if (position_ != node_-&gt;finish()) return false;</span></div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;<span class="stringliteral">    node_type *node = node_;</span></div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="stringliteral">    while (!node-&gt;is_root()) {</span></div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;<span class="stringliteral">      if (node-&gt;position() != node-&gt;parent()-&gt;finish()) return false;</span></div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="stringliteral">      node = node-&gt;parent();</span></div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;<span class="stringliteral">    return true;</span></div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;<span class="stringliteral">  // Returns n such that n calls to ++other yields *this.</span></div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<span class="stringliteral">  // Precondition: n exists &amp;&amp; (this-&gt;node_ != other.node_ ||</span></div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;<span class="stringliteral">  // !this-&gt;node_-&gt;is_leaf() || this-&gt;position_ != other.position_).</span></div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;<span class="stringliteral">  difference_type distance_slow(const_iterator other) const;</span></div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;<span class="stringliteral">  // Increment/decrement the iterator.</span></div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;<span class="stringliteral">  void increment() {</span></div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;<span class="stringliteral">    assert_valid_generation(node_);</span></div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="stringliteral">    if (node_-&gt;is_leaf() &amp;&amp; ++position_ &lt; node_-&gt;finish()) {</span></div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;<span class="stringliteral">      return;</span></div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;<span class="stringliteral">    increment_slow();</span></div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;<span class="stringliteral">  void increment_slow();</span></div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="stringliteral">  void decrement() {</span></div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;<span class="stringliteral">    assert_valid_generation(node_);</span></div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;<span class="stringliteral">    if (node_-&gt;is_leaf() &amp;&amp; --position_ &gt;= node_-&gt;start()) {</span></div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="stringliteral">      return;</span></div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;<span class="stringliteral">    decrement_slow();</span></div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;<span class="stringliteral">  void decrement_slow();</span></div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;<span class="stringliteral">  const key_type &amp;key() const {</span></div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;<span class="stringliteral">    return node_-&gt;key(static_cast&lt;size_type&gt;(position_));</span></div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;<span class="stringliteral">  decltype(std::declval&lt;Node *&gt;()-&gt;slot(0)) slot() {</span></div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="stringliteral">    return node_-&gt;slot(static_cast&lt;size_type&gt;(position_));</span></div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="stringliteral">  void update_generation() {</span></div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;<span class="stringliteral">    btree_iterator_generation_info::update_generation(node_);</span></div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="stringliteral">  // The node in the tree the iterator is pointing at.</span></div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;<span class="stringliteral">  Node *node_;</span></div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;<span class="stringliteral">  // The position within the node of the tree the iterator is pointing at.</span></div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;<span class="stringliteral">  // NOTE: this is an int rather than a field_type because iterators can point</span></div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;<span class="stringliteral">  // to invalid positions (such as -1) in certain circumstances.</span></div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;<span class="stringliteral">  int position_;</span></div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;<span class="stringliteral">template &lt;typename Params&gt;</span></div>
<div class="line"><a name="l01279"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html"> 1279</a></span>&#160;<span class="stringliteral">class btree {</span></div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;<span class="stringliteral">  using node_type = btree_node&lt;Params&gt;;</span></div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;<span class="stringliteral">  using is_key_compare_to = typename Params::is_key_compare_to;</span></div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;<span class="stringliteral">  using field_type = typename node_type::field_type;</span></div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="stringliteral">  // We use a static empty node for the root/leftmost/rightmost of empty btrees</span></div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;<span class="stringliteral">  // in order to avoid branching in begin()/end().</span></div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;<span class="stringliteral">  struct alignas(node_type::Alignment()) EmptyNodeType : node_type {</span></div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;<span class="stringliteral">    using field_type = typename node_type::field_type;</span></div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="stringliteral">    node_type *parent;</span></div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="stringliteral">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="stringliteral">    uint32_t generation = 0;</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="stringliteral">    field_type position = 0;</span></div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;<span class="stringliteral">    field_type start = 0;</span></div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;<span class="stringliteral">    field_type finish = 0;</span></div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="stringliteral">    // max_count must be != kInternalNodeMaxCount (so that this node is regarded</span></div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;<span class="stringliteral">    // as a leaf node). max_count() is never called when the tree is empty.</span></div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;<span class="stringliteral">    field_type max_count = node_type::kInternalNodeMaxCount + 1;</span></div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;<span class="stringliteral">#ifdef _MSC_VER</span></div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="stringliteral">    // MSVC has constexpr code generations bugs here.</span></div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;<span class="stringliteral">    EmptyNodeType() : parent(this) {}</span></div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="stringliteral">#else</span></div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;<span class="stringliteral">    explicit constexpr EmptyNodeType(node_type *p) : parent(p) {}</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="stringliteral">  };</span></div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="stringliteral">  static node_type *EmptyNode() {</span></div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;<span class="stringliteral">#ifdef _MSC_VER</span></div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="stringliteral">    static EmptyNodeType *empty_node = new EmptyNodeType;</span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="stringliteral">    // This assert fails on some other construction methods.</span></div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="stringliteral">    assert(empty_node-&gt;parent == empty_node);</span></div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="stringliteral">    return empty_node;</span></div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="stringliteral">#else</span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="stringliteral">    static constexpr EmptyNodeType empty_node(</span></div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="stringliteral">        const_cast&lt;EmptyNodeType *&gt;(&amp;empty_node));</span></div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="stringliteral">    return const_cast&lt;EmptyNodeType *&gt;(&amp;empty_node);</span></div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;<span class="stringliteral">  enum : uint32_t {</span></div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="stringliteral">    kNodeSlots = node_type::kNodeSlots,</span></div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="stringliteral">    kMinNodeValues = kNodeSlots / 2,</span></div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="stringliteral">  };</span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="stringliteral">  struct node_stats {</span></div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="stringliteral">    using size_type = typename Params::size_type;</span></div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="stringliteral">    node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}</span></div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="stringliteral">    node_stats &amp;operator+=(const node_stats &amp;other) {</span></div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="stringliteral">      leaf_nodes += other.leaf_nodes;</span></div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="stringliteral">      internal_nodes += other.internal_nodes;</span></div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="stringliteral">      return *this;</span></div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="stringliteral">    size_type leaf_nodes;</span></div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="stringliteral">    size_type internal_nodes;</span></div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="stringliteral">  };</span></div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l01341"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a6b966801bad635da48352edd28761c75"> 1341</a></span>&#160;<span class="stringliteral">  using key_type = typename Params::key_type;</span></div>
<div class="line"><a name="l01342"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ab6f8cf57d99b95911f8961d07cd314c0"> 1342</a></span>&#160;<span class="stringliteral">  using value_type = typename Params::value_type;</span></div>
<div class="line"><a name="l01343"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#afba5badd554a6b0c050c37a83e2bba83"> 1343</a></span>&#160;<span class="stringliteral">  using size_type = typename Params::size_type;</span></div>
<div class="line"><a name="l01344"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ab41fb3692bee30a0740caee9b610f480"> 1344</a></span>&#160;<span class="stringliteral">  using difference_type = typename Params::difference_type;</span></div>
<div class="line"><a name="l01345"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ae64bb18d241b0a687741ade3200439dc"> 1345</a></span>&#160;<span class="stringliteral">  using key_compare = typename Params::key_compare;</span></div>
<div class="line"><a name="l01346"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#abf51c1509258fca7d398d2cd70192d22"> 1346</a></span>&#160;<span class="stringliteral">  using original_key_compare = typename Params::original_key_compare;</span></div>
<div class="line"><a name="l01347"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a22951f9df958edfad2f84e1eb4039f55"> 1347</a></span>&#160;<span class="stringliteral">  using value_compare = typename Params::value_compare;</span></div>
<div class="line"><a name="l01348"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a084cfade75b2671e1b2214e343ccf38c"> 1348</a></span>&#160;<span class="stringliteral">  using allocator_type = typename Params::allocator_type;</span></div>
<div class="line"><a name="l01349"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#afebb736bd0625ea02b5b73f35d1f99dd"> 1349</a></span>&#160;<span class="stringliteral">  using reference = typename Params::reference;</span></div>
<div class="line"><a name="l01350"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a5f45bdc8ab16c2f7438f27b8981c3980"> 1350</a></span>&#160;<span class="stringliteral">  using const_reference = typename Params::const_reference;</span></div>
<div class="line"><a name="l01351"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a5f13fb6b6f55e434fa6b559332253c97"> 1351</a></span>&#160;<span class="stringliteral">  using pointer = typename Params::pointer;</span></div>
<div class="line"><a name="l01352"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aba2b140c9f2a1c919c2c476b5c32e2d9"> 1352</a></span>&#160;<span class="stringliteral">  using const_pointer = typename Params::const_pointer;</span></div>
<div class="line"><a name="l01353"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a1c2a1656b47c60a78d3e7dfdff172ede"> 1353</a></span>&#160;<span class="stringliteral">  using iterator =</span></div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="stringliteral">      typename btree_iterator&lt;node_type, reference, pointer&gt;::iterator;</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a039e412f89b9fc92e39125f7de8d1385"> 1355</a></span>&#160;<span class="stringliteral">  using const_iterator = typename iterator::const_iterator;</span></div>
<div class="line"><a name="l01356"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#af6fc3f86ce4f1ca965cfd6eeb0a256ee"> 1356</a></span>&#160;<span class="stringliteral">  using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;</span></div>
<div class="line"><a name="l01357"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a2901aab687f9bd87f188c0221ea08a94"> 1357</a></span>&#160;<span class="stringliteral">  using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;</span></div>
<div class="line"><a name="l01358"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aa1ae8e1bb09384483d740930df0df879"> 1358</a></span>&#160;<span class="stringliteral">  using node_handle_type = node_handle&lt;Params, Params, allocator_type&gt;;</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="stringliteral">  // Internal types made public for use by btree_container types.</span></div>
<div class="line"><a name="l01361"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a07751b9b42ff2e10b0cc9ef09569ae4d"> 1361</a></span>&#160;<span class="stringliteral">  using params_type = Params;</span></div>
<div class="line"><a name="l01362"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ad6effb2d60df1ed16d17b3c2f865152d"> 1362</a></span>&#160;<span class="stringliteral">  using slot_type = typename Params::slot_type;</span></div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="stringliteral">  // Copies or moves (depending on the template parameter) the values in</span></div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="stringliteral">  // other into this btree in their order in other. This btree must be empty</span></div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="stringliteral">  // before this method is called. This method is used in copy construction,</span></div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="stringliteral">  // copy assignment, and move assignment.</span></div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="stringliteral">  template &lt;typename Btree&gt;</span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="stringliteral">  void copy_or_move_values_in_order(Btree &amp;other);</span></div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="stringliteral">  // Validates that various assumptions/requirements are true at compile time.</span></div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="stringliteral">  constexpr static bool static_assert_validation();</span></div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="stringliteral"> public:</span></div>
<div class="line"><a name="l01376"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a3d1a79da0eb40fea5df46ef89a239987"> 1376</a></span>&#160;<span class="stringliteral">  btree(const key_compare &amp;comp, const allocator_type &amp;alloc)</span></div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="stringliteral">      : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}</span></div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01379"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a78ad377d4fe51895553f3ea281ff8f26"> 1379</a></span>&#160;<span class="stringliteral">  btree(const btree &amp;other) : btree(other, other.allocator()) {}</span></div>
<div class="line"><a name="l01380"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ad2162a8484a02fdba16e09352c16c2e7"> 1380</a></span>&#160;<span class="stringliteral">  btree(const btree &amp;other, const allocator_type &amp;alloc)</span></div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="stringliteral">      : btree(other.key_comp(), alloc) {</span></div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="stringliteral">    copy_or_move_values_in_order(other);</span></div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01384"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aae40605eed4d9ba36162e8ee307733f6"> 1384</a></span>&#160;<span class="stringliteral">  btree(btree &amp;&amp;other) noexcept</span></div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="stringliteral">      : root_(absl::exchange(other.root_, EmptyNode())),</span></div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="stringliteral">        rightmost_(std::move(other.rightmost_)),</span></div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="stringliteral">        size_(absl::exchange(other.size_, 0u)) {</span></div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="stringliteral">    other.mutable_rightmost() = EmptyNode();</span></div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01390"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a010f1294664cb1b0555951e96d96d63c"> 1390</a></span>&#160;<span class="stringliteral">  btree(btree &amp;&amp;other, const allocator_type &amp;alloc)</span></div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="stringliteral">      : btree(other.key_comp(), alloc) {</span></div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="stringliteral">    if (alloc == other.allocator()) {</span></div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="stringliteral">      swap(other);</span></div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="stringliteral">      // Move values from `other` one at a time when allocators are different.</span></div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="stringliteral">      copy_or_move_values_in_order(other);</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01400"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aacf455926b2a246f09cbbb555a613ee7"> 1400</a></span>&#160;<span class="stringliteral">  ~btree() {</span></div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="stringliteral">    // Put static_asserts in destructor to avoid triggering them before the type</span></div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="stringliteral">    // is complete.</span></div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="stringliteral">    static_assert(static_assert_validation(), &quot;</span>This call must be elided.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="stringliteral">    clear();</span></div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="stringliteral">  // Assign the contents of other to *this.</span></div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="stringliteral">  btree &amp;operator=(const btree &amp;other);</span></div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="stringliteral">  btree &amp;operator=(btree &amp;&amp;other) noexcept;</span></div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01411"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a9d5a6b8d77d13c24823bdfae87748ee9"> 1411</a></span>&#160;<span class="stringliteral">  iterator begin() { return iterator(leftmost()); }</span></div>
<div class="line"><a name="l01412"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ae0866c603c7fe265fe9cbd67c3cfd889"> 1412</a></span>&#160;<span class="stringliteral">  const_iterator begin() const { return const_iterator(leftmost()); }</span></div>
<div class="line"><a name="l01413"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a1b6ed8eafdde6b3f7c025706a6a8fb04"> 1413</a></span>&#160;<span class="stringliteral">  iterator end() { return iterator(rightmost(), rightmost()-&gt;finish()); }</span></div>
<div class="line"><a name="l01414"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a3cee4fc0f2fb46c25a34fcf4068313fa"> 1414</a></span>&#160;<span class="stringliteral">  const_iterator end() const {</span></div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="stringliteral">    return const_iterator(rightmost(), rightmost()-&gt;finish());</span></div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01417"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aab941b4c99a851585696f83db1b7818f"> 1417</a></span>&#160;<span class="stringliteral">  reverse_iterator rbegin() { return reverse_iterator(end()); }</span></div>
<div class="line"><a name="l01418"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aec9a9c85ab44ad54edb690d015342c3d"> 1418</a></span>&#160;<span class="stringliteral">  const_reverse_iterator rbegin() const {</span></div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;<span class="stringliteral">    return const_reverse_iterator(end());</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01421"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a037b966218e178547c7657583cee3946"> 1421</a></span>&#160;<span class="stringliteral">  reverse_iterator rend() { return reverse_iterator(begin()); }</span></div>
<div class="line"><a name="l01422"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a7450eab9a9c009f002b8a1f0aa769451"> 1422</a></span>&#160;<span class="stringliteral">  const_reverse_iterator rend() const {</span></div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="stringliteral">    return const_reverse_iterator(begin());</span></div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="stringliteral">  // Finds the first element whose key is not less than `key`.</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01428"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#abb477217e076333791f3a4e74603644b"> 1428</a></span>&#160;<span class="stringliteral">  iterator lower_bound(const K &amp;key) {</span></div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;<span class="stringliteral">    return internal_end(internal_lower_bound(key).value);</span></div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01432"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a264c2ff6540e945dedd1bcb9cd5cc05e"> 1432</a></span>&#160;<span class="stringliteral">  const_iterator lower_bound(const K &amp;key) const {</span></div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="stringliteral">    return internal_end(internal_lower_bound(key).value);</span></div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;<span class="stringliteral">  // Finds the first element whose key is not less than `key` and also returns</span></div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;<span class="stringliteral">  // whether that element is equal to `key`.</span></div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01439"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aeb89713672553910a73d3735cef0b2f2"> 1439</a></span>&#160;<span class="stringliteral">  std::pair&lt;iterator, bool&gt; lower_bound_equal(const K &amp;key) const;</span></div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;<span class="stringliteral">  // Finds the first element whose key is greater than `key`.</span></div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01443"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a941c3a2f77d73ca235d3c7771c96c609"> 1443</a></span>&#160;<span class="stringliteral">  iterator upper_bound(const K &amp;key) {</span></div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;<span class="stringliteral">    return internal_end(internal_upper_bound(key));</span></div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01447"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a07b517bd31e330406a409d8149f1223d"> 1447</a></span>&#160;<span class="stringliteral">  const_iterator upper_bound(const K &amp;key) const {</span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="stringliteral">    return internal_end(internal_upper_bound(key));</span></div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="stringliteral">  // Finds the range of values which compare equal to key. The first member of</span></div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="stringliteral">  // the returned pair is equal to lower_bound(key). The second member of the</span></div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="stringliteral">  // pair is equal to upper_bound(key).</span></div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01455"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a3f5faaec378146dc179c783d6fbae5fc"> 1455</a></span>&#160;<span class="stringliteral">  std::pair&lt;iterator, iterator&gt; equal_range(const K &amp;key);</span></div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01457"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a5c3108b50a305421813a8ce4d585de84"> 1457</a></span>&#160;<span class="stringliteral">  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K &amp;key) const {</span></div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="stringliteral">    return const_cast&lt;btree *&gt;(this)-&gt;equal_range(key);</span></div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="stringliteral">  // Inserts a value into the btree only if it does not already exist. The</span></div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;<span class="stringliteral">  // boolean return value indicates whether insertion succeeded or failed.</span></div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="stringliteral">  // Requirement: if `key` already exists in the btree, does not consume `args`.</span></div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;<span class="stringliteral">  // Requirement: `key` is never referenced after consuming `args`.</span></div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="stringliteral">  template &lt;typename K, typename... Args&gt;</span></div>
<div class="line"><a name="l01466"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a6f5a6f6eaedb7d655bcff32341020761"> 1466</a></span>&#160;<span class="stringliteral">  std::pair&lt;iterator, bool&gt; insert_unique(const K &amp;key, Args &amp;&amp;...args);</span></div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;<span class="stringliteral">  // Inserts with hint. Checks to see if the value should be placed immediately</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;<span class="stringliteral">  // before `position` in the tree. If so, then the insertion will take</span></div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;<span class="stringliteral">  // amortized constant time. If not, the insertion will take amortized</span></div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;<span class="stringliteral">  // logarithmic time as if a call to insert_unique() were made.</span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;<span class="stringliteral">  // Requirement: if `key` already exists in the btree, does not consume `args`.</span></div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;<span class="stringliteral">  // Requirement: `key` is never referenced after consuming `args`.</span></div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="stringliteral">  template &lt;typename K, typename... Args&gt;</span></div>
<div class="line"><a name="l01475"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ae668c997584c77a67f3b9fcaefe3a5bf"> 1475</a></span>&#160;<span class="stringliteral">  std::pair&lt;iterator, bool&gt; insert_hint_unique(iterator position, const K &amp;key,</span></div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="stringliteral">                                               Args &amp;&amp;...args);</span></div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="stringliteral">  // Insert a range of values into the btree.</span></div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;<span class="stringliteral">  // Note: the first overload avoids constructing a value_type if the key</span></div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;<span class="stringliteral">  // already exists in the btree.</span></div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;<span class="stringliteral">  template &lt;typename InputIterator,</span></div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;<span class="stringliteral">            typename = decltype(std::declval&lt;const key_compare &amp;&gt;()(</span></div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;<span class="stringliteral">                params_type::key(*std::declval&lt;InputIterator&gt;()),</span></div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;<span class="stringliteral">                std::declval&lt;const key_type &amp;&gt;()))&gt;</span></div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;<span class="stringliteral">  void insert_iterator_unique(InputIterator b, InputIterator e, int);</span></div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;<span class="stringliteral">  // We need the second overload for cases in which we need to construct a</span></div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="stringliteral">  // value_type in order to compare it with the keys already in the btree.</span></div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;<span class="stringliteral">  template &lt;typename InputIterator&gt;</span></div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;<span class="stringliteral">  void insert_iterator_unique(InputIterator b, InputIterator e, char);</span></div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;<span class="stringliteral">  // Inserts a value into the btree.</span></div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;<span class="stringliteral">  template &lt;typename ValueType&gt;</span></div>
<div class="line"><a name="l01493"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a063b654052b7b844eafa40b618501785"> 1493</a></span>&#160;<span class="stringliteral">  iterator insert_multi(const key_type &amp;key, ValueType &amp;&amp;v);</span></div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;<span class="stringliteral">  // Inserts a value into the btree.</span></div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;<span class="stringliteral">  template &lt;typename ValueType&gt;</span></div>
<div class="line"><a name="l01497"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a893170a643996fb0f9a0e79b1827902d"> 1497</a></span>&#160;<span class="stringliteral">  iterator insert_multi(ValueType &amp;&amp;v) {</span></div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="stringliteral">    return insert_multi(params_type::key(v), std::forward&lt;ValueType&gt;(v));</span></div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;<span class="stringliteral">  // Insert with hint. Check to see if the value should be placed immediately</span></div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="stringliteral">  // before position in the tree. If it does, then the insertion will take</span></div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;<span class="stringliteral">  // amortized constant time. If not, the insertion will take amortized</span></div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;<span class="stringliteral">  // logarithmic time as if a call to insert_multi(v) were made.</span></div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;<span class="stringliteral">  template &lt;typename ValueType&gt;</span></div>
<div class="line"><a name="l01506"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ad1499a97629400d7f627731a7a0679c3"> 1506</a></span>&#160;<span class="stringliteral">  iterator insert_hint_multi(iterator position, ValueType &amp;&amp;v);</span></div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="stringliteral">  // Insert a range of values into the btree.</span></div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;<span class="stringliteral">  template &lt;typename InputIterator&gt;</span></div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;<span class="stringliteral">  void insert_iterator_multi(InputIterator b, InputIterator e);</span></div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="stringliteral">  // Erase the specified iterator from the btree. The iterator must be valid</span></div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;<span class="stringliteral">  // (i.e. not equal to end()).  Return an iterator pointing to the node after</span></div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;<span class="stringliteral">  // the one that was erased (or end() if none exists).</span></div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;<span class="stringliteral">  // Requirement: does not read the value at `*iter`.</span></div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;<span class="stringliteral">  iterator erase(iterator iter);</span></div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;<span class="stringliteral">  // Erases range. Returns the number of keys erased and an iterator pointing</span></div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;<span class="stringliteral">  // to the element after the last erased element.</span></div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;<span class="stringliteral">  std::pair&lt;size_type, iterator&gt; erase_range(iterator begin, iterator end);</span></div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;<span class="stringliteral">  // Finds an element with key equivalent to `key` or returns `end()` if `key`</span></div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;<span class="stringliteral">  // is not present.</span></div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01525"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ad818fcc09648dc3a5077b9b41b87994e"> 1525</a></span>&#160;<span class="stringliteral">  iterator find(const K &amp;key) {</span></div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;<span class="stringliteral">    return internal_end(internal_find(key));</span></div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01529"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ab4d5332af00f3de6b241a943f263c759"> 1529</a></span>&#160;<span class="stringliteral">  const_iterator find(const K &amp;key) const {</span></div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;<span class="stringliteral">    return internal_end(internal_find(key));</span></div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;<span class="stringliteral">  // Clear the btree, deleting all of the values it contains.</span></div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;<span class="stringliteral">  void clear();</span></div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;<span class="stringliteral">  // Swaps the contents of `this` and `other`.</span></div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;<span class="stringliteral">  void swap(btree &amp;other);</span></div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01539"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ac7ae970bab59bafddfd454c77a5ece75"> 1539</a></span>&#160;<span class="stringliteral">  const key_compare &amp;key_comp() const noexcept {</span></div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;<span class="stringliteral">    return rightmost_.template get&lt;0&gt;();</span></div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;<span class="stringliteral">  template &lt;typename K1, typename K2&gt;</span></div>
<div class="line"><a name="l01543"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a83617b24728b4a6bf61826bd6ae1231e"> 1543</a></span>&#160;<span class="stringliteral">  bool compare_keys(const K1 &amp;a, const K2 &amp;b) const {</span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;<span class="stringliteral">    return compare_internal::compare_result_as_less_than(key_comp()(a, b));</span></div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01547"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#add4a7e3dc56cb309d7d886b7b65955cc"> 1547</a></span>&#160;<span class="stringliteral">  value_compare value_comp() const {</span></div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;<span class="stringliteral">    return value_compare(original_key_compare(key_comp()));</span></div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;<span class="stringliteral">  // Verifies the structure of the btree.</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;<span class="stringliteral">  void verify() const;</span></div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;<span class="stringliteral">  // Size routines.</span></div>
<div class="line"><a name="l01555"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a56472e601f36d04ea40dd04250bd072f"> 1555</a></span>&#160;<span class="stringliteral">  size_type size() const { return size_; }</span></div>
<div class="line"><a name="l01556"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a6cb1270526a16c5b3018bcb3400d9acf"> 1556</a></span>&#160;<span class="stringliteral">  size_type max_size() const { return (std::numeric_limits&lt;size_type&gt;::max)(); }</span></div>
<div class="line"><a name="l01557"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ac9dde695ba0e4cb19797ba59aa0c6388"> 1557</a></span>&#160;<span class="stringliteral">  bool empty() const { return size_ == 0; }</span></div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;<span class="stringliteral">  // The height of the btree. An empty tree will have height 0.</span></div>
<div class="line"><a name="l01560"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#aade2cb2e92c827ae0e0d07febd143e50"> 1560</a></span>&#160;<span class="stringliteral">  size_type height() const {</span></div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;<span class="stringliteral">    size_type h = 0;</span></div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;<span class="stringliteral">    if (!empty()) {</span></div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;<span class="stringliteral">      // Count the length of the chain from the leftmost node up to the</span></div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;<span class="stringliteral">      // root. We actually count from the root back around to the level below</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;<span class="stringliteral">      // the root, but the calculation is the same because of the circularity</span></div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;<span class="stringliteral">      // of that traversal.</span></div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;<span class="stringliteral">      const node_type *n = root();</span></div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;<span class="stringliteral">      do {</span></div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;<span class="stringliteral">        ++h;</span></div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;<span class="stringliteral">        n = n-&gt;parent();</span></div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;<span class="stringliteral">      } while (n != root());</span></div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="stringliteral">    return h;</span></div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;<span class="stringliteral">  // The number of internal, leaf and total nodes used by the btree.</span></div>
<div class="line"><a name="l01577"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ac8aff170aa795680cb218797d389ccaf"> 1577</a></span>&#160;<span class="stringliteral">  size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }</span></div>
<div class="line"><a name="l01578"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a338d0924d19a42d2dcf5d20055211001"> 1578</a></span>&#160;<span class="stringliteral">  size_type internal_nodes() const {</span></div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;<span class="stringliteral">    return internal_stats(root()).internal_nodes;</span></div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01581"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a5a30096af88e9da9c568c3d879424301"> 1581</a></span>&#160;<span class="stringliteral">  size_type nodes() const {</span></div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="stringliteral">    node_stats stats = internal_stats(root());</span></div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="stringliteral">    return stats.leaf_nodes + stats.internal_nodes;</span></div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="stringliteral">  // The total number of bytes used by the btree.</span></div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="stringliteral">  // TODO(b/169338300): update to support node_btree_*.</span></div>
<div class="line"><a name="l01588"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a6fa5f820add209c074a40c9e206a59ef"> 1588</a></span>&#160;<span class="stringliteral">  size_type bytes_used() const {</span></div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="stringliteral">    node_stats stats = internal_stats(root());</span></div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="stringliteral">    if (stats.leaf_nodes == 1 &amp;&amp; stats.internal_nodes == 0) {</span></div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="stringliteral">      return sizeof(*this) + node_type::LeafSize(root()-&gt;max_count());</span></div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;<span class="stringliteral">      return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +</span></div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;<span class="stringliteral">             stats.internal_nodes * node_type::InternalSize();</span></div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;<span class="stringliteral">  // The average number of bytes used per value stored in the btree assuming</span></div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="stringliteral">  // random insertion order.</span></div>
<div class="line"><a name="l01600"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a109286bdf8edb33a158f5d6903a1ce43"> 1600</a></span>&#160;<span class="stringliteral">  static double average_bytes_per_value() {</span></div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;<span class="stringliteral">    // The expected number of values per node with random insertion order is the</span></div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;<span class="stringliteral">    // average of the maximum and minimum numbers of values per node.</span></div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;<span class="stringliteral">    const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;</span></div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;<span class="stringliteral">    return node_type::LeafSize() / expected_values_per_node;</span></div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;<span class="stringliteral">  // The fullness of the btree. Computed as the number of elements in the btree</span></div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;<span class="stringliteral">  // divided by the maximum number of elements a tree with the current number</span></div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="stringliteral">  // of nodes could hold. A value of 1 indicates perfect space</span></div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;<span class="stringliteral">  // utilization. Smaller values indicate space wastage.</span></div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;<span class="stringliteral">  // Returns 0 for empty trees.</span></div>
<div class="line"><a name="l01612"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a54f9cd74eba8f7f895604289243c0a5e"> 1612</a></span>&#160;<span class="stringliteral">  double fullness() const {</span></div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;<span class="stringliteral">    if (empty()) return 0.0;</span></div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;<span class="stringliteral">    return static_cast&lt;double&gt;(size()) / (nodes() * kNodeSlots);</span></div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;<span class="stringliteral">  // The overhead of the btree structure in bytes per node. Computed as the</span></div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;<span class="stringliteral">  // total number of bytes used by the btree minus the number of bytes used for</span></div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;<span class="stringliteral">  // storing elements divided by the number of elements.</span></div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;<span class="stringliteral">  // Returns 0 for empty trees.</span></div>
<div class="line"><a name="l01620"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a037668a1056adfcdfbac4536c68013c7"> 1620</a></span>&#160;<span class="stringliteral">  double overhead() const {</span></div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;<span class="stringliteral">    if (empty()) return 0.0;</span></div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;<span class="stringliteral">    return (bytes_used() - size() * sizeof(value_type)) /</span></div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;<span class="stringliteral">           static_cast&lt;double&gt;(size());</span></div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;<span class="stringliteral">  // The allocator used by the btree.</span></div>
<div class="line"><a name="l01627"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a74863079b9916e8a691f936144ee26bf"> 1627</a></span>&#160;<span class="stringliteral">  allocator_type get_allocator() const { return allocator(); }</span></div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;<span class="stringliteral"> private:</span></div>
<div class="line"><a name="l01630"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a9e4b8c582598bba429514b5612082a3b"> 1630</a></span>&#160;<span class="stringliteral">  friend struct btree_access;</span></div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;<span class="stringliteral">  // Internal accessor routines.</span></div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;<span class="stringliteral">  node_type *root() { return root_; }</span></div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;<span class="stringliteral">  const node_type *root() const { return root_; }</span></div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;<span class="stringliteral">  node_type *&amp;mutable_root() noexcept { return root_; }</span></div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;<span class="stringliteral">  node_type *rightmost() { return rightmost_.template get&lt;2&gt;(); }</span></div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;<span class="stringliteral">  const node_type *rightmost() const { return rightmost_.template get&lt;2&gt;(); }</span></div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;<span class="stringliteral">  node_type *&amp;mutable_rightmost() noexcept {</span></div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;<span class="stringliteral">    return rightmost_.template get&lt;2&gt;();</span></div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;<span class="stringliteral">  key_compare *mutable_key_comp() noexcept {</span></div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;<span class="stringliteral">    return &amp;rightmost_.template get&lt;0&gt;();</span></div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;<span class="stringliteral">  // The leftmost node is stored as the parent of the root node.</span></div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;<span class="stringliteral">  node_type *leftmost() { return root()-&gt;parent(); }</span></div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="stringliteral">  const node_type *leftmost() const { return root()-&gt;parent(); }</span></div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;<span class="stringliteral">  // Allocator routines.</span></div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;<span class="stringliteral">  allocator_type *mutable_allocator() noexcept {</span></div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;<span class="stringliteral">    return &amp;rightmost_.template get&lt;1&gt;();</span></div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;<span class="stringliteral">  const allocator_type &amp;allocator() const noexcept {</span></div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;<span class="stringliteral">    return rightmost_.template get&lt;1&gt;();</span></div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;<span class="stringliteral">  // Allocates a correctly aligned node of at least size bytes using the</span></div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;<span class="stringliteral">  // allocator.</span></div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;<span class="stringliteral">  node_type *allocate(size_type size) {</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="stringliteral">    return reinterpret_cast&lt;node_type *&gt;(</span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="stringliteral">        absl::container_internal::Allocate&lt;node_type::Alignment()&gt;(</span></div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="stringliteral">            mutable_allocator(), size));</span></div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;<span class="stringliteral">  // Node creation/deletion routines.</span></div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;<span class="stringliteral">  node_type *new_internal_node(node_type *parent) {</span></div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;<span class="stringliteral">    node_type *n = allocate(node_type::InternalSize());</span></div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="stringliteral">    n-&gt;init_internal(parent);</span></div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="stringliteral">    return n;</span></div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="stringliteral">  node_type *new_leaf_node(node_type *parent) {</span></div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;<span class="stringliteral">    node_type *n = allocate(node_type::LeafSize());</span></div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;<span class="stringliteral">    n-&gt;init_leaf(kNodeSlots, parent);</span></div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="stringliteral">    return n;</span></div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="stringliteral">  node_type *new_leaf_root_node(field_type max_count) {</span></div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;<span class="stringliteral">    node_type *n = allocate(node_type::LeafSize(max_count));</span></div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="stringliteral">    n-&gt;init_leaf(max_count, /*parent=*/n);</span></div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;<span class="stringliteral">    return n;</span></div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="stringliteral">  // Deletion helper routines.</span></div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="stringliteral">  iterator rebalance_after_delete(iterator iter);</span></div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="stringliteral">  // Rebalances or splits the node iter points to.</span></div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="stringliteral">  void rebalance_or_split(iterator *iter);</span></div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="stringliteral">  // Merges the values of left, right and the delimiting key on their parent</span></div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="stringliteral">  // onto left, removing the delimiting key and deleting right.</span></div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;<span class="stringliteral">  void merge_nodes(node_type *left, node_type *right);</span></div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="stringliteral">  // Tries to merge node with its left or right sibling, and failing that,</span></div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="stringliteral">  // rebalance with its left or right sibling. Returns true if a merge</span></div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;<span class="stringliteral">  // occurred, at which point it is no longer valid to access node. Returns</span></div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;<span class="stringliteral">  // false if no merging took place.</span></div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="stringliteral">  bool try_merge_or_rebalance(iterator *iter);</span></div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="stringliteral">  // Tries to shrink the height of the tree by 1.</span></div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;<span class="stringliteral">  void try_shrink();</span></div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;<span class="stringliteral">  iterator internal_end(iterator iter) {</span></div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="stringliteral">    return iter.node_ != nullptr ? iter : end();</span></div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;<span class="stringliteral">  const_iterator internal_end(const_iterator iter) const {</span></div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="stringliteral">    return iter.node_ != nullptr ? iter : end();</span></div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;<span class="stringliteral">  // Emplaces a value into the btree immediately before iter. Requires that</span></div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="stringliteral">  // key(v) &lt;= iter.key() and (--iter).key() &lt;= key(v).</span></div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="stringliteral">  template &lt;typename... Args&gt;</span></div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;<span class="stringliteral">  iterator internal_emplace(iterator iter, Args &amp;&amp;...args);</span></div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="stringliteral">  // Returns an iterator pointing to the first value &gt;= the value &quot;</span>iter<span class="stringliteral">&quot; is</span></div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="stringliteral">  // pointing at. Note that &quot;</span>iter<span class="stringliteral">&quot; might be pointing to an invalid location such</span></div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="stringliteral">  // as iter.position_ == iter.node_-&gt;finish(). This routine simply moves iter</span></div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="stringliteral">  // up in the tree to a valid location. Requires: iter.node_ is non-null.</span></div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="stringliteral">  template &lt;typename IterType&gt;</span></div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="stringliteral">  static IterType internal_last(IterType iter);</span></div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="stringliteral">  // Returns an iterator pointing to the leaf position at which key would</span></div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="stringliteral">  // reside in the tree, unless there is an exact match - in which case, the</span></div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="stringliteral">  // result may not be on a leaf. When there&#39;s a three-way comparator, we can</span></div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="stringliteral">  // return whether there was an exact match. This allows the caller to avoid a</span></div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="stringliteral">  // subsequent comparison to determine if an exact match was made, which is</span></div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="stringliteral">  // important for keys with expensive comparison, such as strings.</span></div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;<span class="stringliteral">  SearchResult&lt;iterator, is_key_compare_to::value&gt; internal_locate(</span></div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="stringliteral">      const K &amp;key) const;</span></div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;<span class="stringliteral">  // Internal routine which implements lower_bound().</span></div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;<span class="stringliteral">  SearchResult&lt;iterator, is_key_compare_to::value&gt; internal_lower_bound(</span></div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;<span class="stringliteral">      const K &amp;key) const;</span></div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;<span class="stringliteral">  // Internal routine which implements upper_bound().</span></div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;<span class="stringliteral">  iterator internal_upper_bound(const K &amp;key) const;</span></div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;<span class="stringliteral">  // Internal routine which implements find().</span></div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;<span class="stringliteral">  template &lt;typename K&gt;</span></div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;<span class="stringliteral">  iterator internal_find(const K &amp;key) const;</span></div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;<span class="stringliteral">  // Verifies the tree structure of node.</span></div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;<span class="stringliteral">  size_type internal_verify(const node_type *node, const key_type *lo,</span></div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;<span class="stringliteral">                            const key_type *hi) const;</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;<span class="stringliteral">  node_stats internal_stats(const node_type *node) const {</span></div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;<span class="stringliteral">    // The root can be a static empty node.</span></div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;<span class="stringliteral">    if (node == nullptr || (node == root() &amp;&amp; empty())) {</span></div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;<span class="stringliteral">      return node_stats(0, 0);</span></div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;<span class="stringliteral">    if (node-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;<span class="stringliteral">      return node_stats(1, 0);</span></div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;<span class="stringliteral">    node_stats res(0, 1);</span></div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;<span class="stringliteral">    for (int i = node-&gt;start(); i &lt;= node-&gt;finish(); ++i) {</span></div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;<span class="stringliteral">      res += internal_stats(node-&gt;child(i));</span></div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;<span class="stringliteral">    return res;</span></div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;<span class="stringliteral">  node_type *root_;</span></div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;<span class="stringliteral">  // A pointer to the rightmost node. Note that the leftmost node is stored as</span></div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;<span class="stringliteral">  // the root&#39;s parent. We use compressed tuple in order to save space because</span></div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;<span class="stringliteral">  // key_compare and allocator_type are usually empty.</span></div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;<span class="stringliteral">  absl::container_internal::CompressedTuple&lt;key_compare, allocator_type,</span></div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;<span class="stringliteral">                                            node_type *&gt;</span></div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;<span class="stringliteral">      rightmost_;</span></div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;<span class="stringliteral">  // Number of values.</span></div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;<span class="stringliteral">  size_type size_;</span></div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;<span class="stringliteral">// btree_node methods</span></div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;<span class="stringliteral">template &lt;typename... Args&gt;</span></div>
<div class="line"><a name="l01779"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#ab6addef475b6d9c761fb5a2ee3f61027"> 1779</a></span>&#160;<span class="stringliteral">inline void btree_node&lt;P&gt;::emplace_value(const field_type i,</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;<span class="stringliteral">                                         allocator_type *alloc,</span></div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;<span class="stringliteral">                                         Args &amp;&amp;...args) {</span></div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;<span class="stringliteral">  assert(i &gt;= start());</span></div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;<span class="stringliteral">  assert(i &lt;= finish());</span></div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;<span class="stringliteral">  // Shift old values to create space for new value and then construct it in</span></div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;<span class="stringliteral">  // place.</span></div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;<span class="stringliteral">  if (i &lt; finish()) {</span></div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;<span class="stringliteral">    transfer_n_backward(finish() - i, /*dest_i=*/i + 1, /*src_i=*/i, this,</span></div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;<span class="stringliteral">                        alloc);</span></div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;<span class="stringliteral">  value_init(static_cast&lt;field_type&gt;(i), alloc, std::forward&lt;Args&gt;(args)...);</span></div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;<span class="stringliteral">  set_finish(finish() + 1);</span></div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;<span class="stringliteral">  if (is_internal() &amp;&amp; finish() &gt; i + 1) {</span></div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;<span class="stringliteral">    for (field_type j = finish(); j &gt; i + 1; --j) {</span></div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;<span class="stringliteral">      set_child(j, child(j - 1));</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;<span class="stringliteral">    clear_child(i + 1);</span></div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01802"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#aba2d3a6e33e2f83cee5cac03b6e3c30e"> 1802</a></span>&#160;<span class="stringliteral">inline void btree_node&lt;P&gt;::remove_values(const field_type i,</span></div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;<span class="stringliteral">                                         const field_type to_erase,</span></div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;<span class="stringliteral">                                         allocator_type *alloc) {</span></div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;<span class="stringliteral">  // Transfer values after the removed range into their new places.</span></div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;<span class="stringliteral">  value_destroy_n(i, to_erase, alloc);</span></div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;<span class="stringliteral">  const field_type orig_finish = finish();</span></div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;<span class="stringliteral">  const field_type src_i = i + to_erase;</span></div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;<span class="stringliteral">  transfer_n(orig_finish - src_i, i, src_i, this, alloc);</span></div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;<span class="stringliteral">  if (is_internal()) {</span></div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;<span class="stringliteral">    // Delete all children between begin and end.</span></div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;<span class="stringliteral">    for (field_type j = 0; j &lt; to_erase; ++j) {</span></div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;<span class="stringliteral">      clear_and_delete(child(i + j + 1), alloc);</span></div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;<span class="stringliteral">    // Rotate children after end into new positions.</span></div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;<span class="stringliteral">    for (field_type j = i + to_erase + 1; j &lt;= orig_finish; ++j) {</span></div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;<span class="stringliteral">      set_child(j - to_erase, child(j));</span></div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;<span class="stringliteral">      clear_child(j);</span></div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;<span class="stringliteral">  set_finish(orig_finish - to_erase);</span></div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01826"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#aa50bfd26470967d949e17257ab1baeaf"> 1826</a></span>&#160;<span class="stringliteral">void btree_node&lt;P&gt;::rebalance_right_to_left(field_type to_move,</span></div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;<span class="stringliteral">                                            btree_node *right,</span></div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;<span class="stringliteral">                                            allocator_type *alloc) {</span></div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;<span class="stringliteral">  assert(parent() == right-&gt;parent());</span></div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;<span class="stringliteral">  assert(position() + 1 == right-&gt;position());</span></div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;<span class="stringliteral">  assert(right-&gt;count() &gt;= count());</span></div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="stringliteral">  assert(to_move &gt;= 1);</span></div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="stringliteral">  assert(to_move &lt;= right-&gt;count());</span></div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;<span class="stringliteral">  // 1) Move the delimiting value in the parent to the left node.</span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;<span class="stringliteral">  transfer(finish(), position(), parent(), alloc);</span></div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;<span class="stringliteral">  // 2) Move the (to_move - 1) values from the right node to the left node.</span></div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;<span class="stringliteral">  transfer_n(to_move - 1, finish() + 1, right-&gt;start(), right, alloc);</span></div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;<span class="stringliteral">  // 3) Move the new delimiting value to the parent from the right node.</span></div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;<span class="stringliteral">  parent()-&gt;transfer(position(), right-&gt;start() + to_move - 1, right, alloc);</span></div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;<span class="stringliteral">  // 4) Shift the values in the right node to their correct positions.</span></div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;<span class="stringliteral">  right-&gt;transfer_n(right-&gt;count() - to_move, right-&gt;start(),</span></div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;<span class="stringliteral">                    right-&gt;start() + to_move, right, alloc);</span></div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;<span class="stringliteral">  if (is_internal()) {</span></div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;<span class="stringliteral">    // Move the child pointers from the right to the left node.</span></div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;<span class="stringliteral">    for (field_type i = 0; i &lt; to_move; ++i) {</span></div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;<span class="stringliteral">      init_child(finish() + i + 1, right-&gt;child(i));</span></div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;<span class="stringliteral">    for (field_type i = right-&gt;start(); i &lt;= right-&gt;finish() - to_move; ++i) {</span></div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;<span class="stringliteral">      assert(i + to_move &lt;= right-&gt;max_count());</span></div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;<span class="stringliteral">      right-&gt;init_child(i, right-&gt;child(i + to_move));</span></div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;<span class="stringliteral">      right-&gt;clear_child(i + to_move);</span></div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;<span class="stringliteral">  // Fixup `finish` on the left and right nodes.</span></div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;<span class="stringliteral">  set_finish(finish() + to_move);</span></div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;<span class="stringliteral">  right-&gt;set_finish(right-&gt;finish() - to_move);</span></div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01866"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a07491d7498433b699894d227779b1b51"> 1866</a></span>&#160;<span class="stringliteral">void btree_node&lt;P&gt;::rebalance_left_to_right(field_type to_move,</span></div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;<span class="stringliteral">                                            btree_node *right,</span></div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;<span class="stringliteral">                                            allocator_type *alloc) {</span></div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="stringliteral">  assert(parent() == right-&gt;parent());</span></div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;<span class="stringliteral">  assert(position() + 1 == right-&gt;position());</span></div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;<span class="stringliteral">  assert(count() &gt;= right-&gt;count());</span></div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;<span class="stringliteral">  assert(to_move &gt;= 1);</span></div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;<span class="stringliteral">  assert(to_move &lt;= count());</span></div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;<span class="stringliteral">  // Values in the right node are shifted to the right to make room for the</span></div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;<span class="stringliteral">  // new to_move values. Then, the delimiting value in the parent and the</span></div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;<span class="stringliteral">  // other (to_move - 1) values in the left node are moved into the right node.</span></div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;<span class="stringliteral">  // Lastly, a new delimiting value is moved from the left node into the</span></div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;<span class="stringliteral">  // parent, and the remaining empty left node entries are destroyed.</span></div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;<span class="stringliteral">  // 1) Shift existing values in the right node to their correct positions.</span></div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;<span class="stringliteral">  right-&gt;transfer_n_backward(right-&gt;count(), right-&gt;start() + to_move,</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="stringliteral">                             right-&gt;start(), right, alloc);</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;<span class="stringliteral">  // 2) Move the delimiting value in the parent to the right node.</span></div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;<span class="stringliteral">  right-&gt;transfer(right-&gt;start() + to_move - 1, position(), parent(), alloc);</span></div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;<span class="stringliteral">  // 3) Move the (to_move - 1) values from the left node to the right node.</span></div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;<span class="stringliteral">  right-&gt;transfer_n(to_move - 1, right-&gt;start(), finish() - (to_move - 1), this,</span></div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;<span class="stringliteral">                    alloc);</span></div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;<span class="stringliteral">  // 4) Move the new delimiting value to the parent from the left node.</span></div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;<span class="stringliteral">  parent()-&gt;transfer(position(), finish() - to_move, this, alloc);</span></div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;<span class="stringliteral">  if (is_internal()) {</span></div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;<span class="stringliteral">    // Move the child pointers from the left to the right node.</span></div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;<span class="stringliteral">    for (field_type i = right-&gt;finish() + 1; i &gt; right-&gt;start(); --i) {</span></div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;<span class="stringliteral">      right-&gt;init_child(i - 1 + to_move, right-&gt;child(i - 1));</span></div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;<span class="stringliteral">      right-&gt;clear_child(i - 1);</span></div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;<span class="stringliteral">    for (field_type i = 1; i &lt;= to_move; ++i) {</span></div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;<span class="stringliteral">      right-&gt;init_child(i - 1, child(finish() - to_move + i));</span></div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<span class="stringliteral">      clear_child(finish() - to_move + i);</span></div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;<span class="stringliteral">  // Fixup the counts on the left and right nodes.</span></div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;<span class="stringliteral">  set_finish(finish() - to_move);</span></div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;<span class="stringliteral">  right-&gt;set_finish(right-&gt;finish() + to_move);</span></div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01913"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a99aab0851810062f38dacfafe4ce9f99"> 1913</a></span>&#160;<span class="stringliteral">void btree_node&lt;P&gt;::split(const int insert_position, btree_node *dest,</span></div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;<span class="stringliteral">                          allocator_type *alloc) {</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;<span class="stringliteral">  assert(dest-&gt;count() == 0);</span></div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;<span class="stringliteral">  assert(max_count() == kNodeSlots);</span></div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;<span class="stringliteral">  // We bias the split based on the position being inserted. If we&#39;re</span></div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;<span class="stringliteral">  // inserting at the beginning of the left node then bias the split to put</span></div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;<span class="stringliteral">  // more values on the right node. If we&#39;re inserting at the end of the</span></div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;<span class="stringliteral">  // right node then bias the split to put more values on the left node.</span></div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;<span class="stringliteral">  if (insert_position == start()) {</span></div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;<span class="stringliteral">    dest-&gt;set_finish(dest-&gt;start() + finish() - 1);</span></div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;<span class="stringliteral">  } else if (insert_position == kNodeSlots) {</span></div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;<span class="stringliteral">    dest-&gt;set_finish(dest-&gt;start());</span></div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;<span class="stringliteral">    dest-&gt;set_finish(dest-&gt;start() + count() / 2);</span></div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;<span class="stringliteral">  set_finish(finish() - dest-&gt;count());</span></div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;<span class="stringliteral">  assert(count() &gt;= 1);</span></div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;<span class="stringliteral">  // Move values from the left sibling to the right sibling.</span></div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;<span class="stringliteral">  dest-&gt;transfer_n(dest-&gt;count(), dest-&gt;start(), finish(), this, alloc);</span></div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;<span class="stringliteral">  // The split key is the largest value in the left sibling.</span></div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;<span class="stringliteral">  --mutable_finish();</span></div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;<span class="stringliteral">  parent()-&gt;emplace_value(position(), alloc, finish_slot());</span></div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;<span class="stringliteral">  value_destroy(finish(), alloc);</span></div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;<span class="stringliteral">  parent()-&gt;init_child(position() + 1, dest);</span></div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;<span class="stringliteral">  if (is_internal()) {</span></div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;<span class="stringliteral">    for (field_type i = dest-&gt;start(), j = finish() + 1; i &lt;= dest-&gt;finish();</span></div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;<span class="stringliteral">         ++i, ++j) {</span></div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;<span class="stringliteral">      assert(child(j) != nullptr);</span></div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;<span class="stringliteral">      dest-&gt;init_child(i, child(j));</span></div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;<span class="stringliteral">      clear_child(j);</span></div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01952"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a495e21155ae20d66de5a29c60fa2d5b5"> 1952</a></span>&#160;<span class="stringliteral">void btree_node&lt;P&gt;::merge(btree_node *src, allocator_type *alloc) {</span></div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;<span class="stringliteral">  assert(parent() == src-&gt;parent());</span></div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;<span class="stringliteral">  assert(position() + 1 == src-&gt;position());</span></div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;<span class="stringliteral">  // Move the delimiting value to the left node.</span></div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;<span class="stringliteral">  value_init(finish(), alloc, parent()-&gt;slot(position()));</span></div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;<span class="stringliteral">  // Move the values from the right to the left node.</span></div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;<span class="stringliteral">  transfer_n(src-&gt;count(), finish() + 1, src-&gt;start(), src, alloc);</span></div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;<span class="stringliteral">  if (is_internal()) {</span></div>
<div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;<span class="stringliteral">    // Move the child pointers from the right to the left node.</span></div>
<div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;<span class="stringliteral">    for (field_type i = src-&gt;start(), j = finish() + 1; i &lt;= src-&gt;finish();</span></div>
<div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;<span class="stringliteral">         ++i, ++j) {</span></div>
<div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;<span class="stringliteral">      init_child(j, src-&gt;child(i));</span></div>
<div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;<span class="stringliteral">      src-&gt;clear_child(i);</span></div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;<span class="stringliteral">  // Fixup `finish` on the src and dest nodes.</span></div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;<span class="stringliteral">  set_finish(start() + 1 + count() + src-&gt;count());</span></div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;<span class="stringliteral">  src-&gt;set_finish(src-&gt;start());</span></div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;<span class="stringliteral">  // Remove the value on the parent node and delete the src node.</span></div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;<span class="stringliteral">  parent()-&gt;remove_values(position(), /*to_erase=*/1, alloc);</span></div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l01980"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree__node.html#a5435ed06ba3acd639b97cac969373c64"> 1980</a></span>&#160;<span class="stringliteral">void btree_node&lt;P&gt;::clear_and_delete(btree_node *node, allocator_type *alloc) {</span></div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;<span class="stringliteral">  if (node-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;<span class="stringliteral">    node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);</span></div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;<span class="stringliteral">    deallocate(LeafSize(node-&gt;max_count()), node, alloc);</span></div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;<span class="stringliteral">    return;</span></div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;<span class="stringliteral">  if (node-&gt;count() == 0) {</span></div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;<span class="stringliteral">    deallocate(InternalSize(), node, alloc);</span></div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;<span class="stringliteral">    return;</span></div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;<span class="stringliteral">  // The parent of the root of the subtree we are deleting.</span></div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;<span class="stringliteral">  btree_node *delete_root_parent = node-&gt;parent();</span></div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;<span class="stringliteral">  // Navigate to the leftmost leaf under node, and then delete upwards.</span></div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;<span class="stringliteral">  while (node-&gt;is_internal()) node = node-&gt;start_child();</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;<span class="stringliteral">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;<span class="stringliteral">  // When generations are enabled, we delete the leftmost leaf last in case it&#39;s</span></div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;<span class="stringliteral">  // the parent of the root and we need to check whether it&#39;s a leaf before we</span></div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;<span class="stringliteral">  // can update the root&#39;s generation.</span></div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;<span class="stringliteral">  // TODO(ezb): if we change btree_node::is_root to check a bool inside the node</span></div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;<span class="stringliteral">  // instead of checking whether the parent is a leaf, we can remove this logic.</span></div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;<span class="stringliteral">  btree_node *leftmost_leaf = node;</span></div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;<span class="stringliteral">  // Use `size_type` because `pos` needs to be able to hold `kNodeSlots+1`,</span></div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;<span class="stringliteral">  // which isn&#39;t guaranteed to be a valid `field_type`.</span></div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;<span class="stringliteral">  size_type pos = node-&gt;position();</span></div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;<span class="stringliteral">  btree_node *parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;<span class="stringliteral">  for (;;) {</span></div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;<span class="stringliteral">    // In each iteration of the next loop, we delete one leaf node and go right.</span></div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;<span class="stringliteral">    assert(pos &lt;= parent-&gt;finish());</span></div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;<span class="stringliteral">    do {</span></div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;<span class="stringliteral">      node = parent-&gt;child(static_cast&lt;field_type&gt;(pos));</span></div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;<span class="stringliteral">      if (node-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;<span class="stringliteral">        // Navigate to the leftmost leaf under node.</span></div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;<span class="stringliteral">        while (node-&gt;is_internal()) node = node-&gt;start_child();</span></div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;<span class="stringliteral">        pos = node-&gt;position();</span></div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;<span class="stringliteral">        parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;<span class="stringliteral">      node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);</span></div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;<span class="stringliteral">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;<span class="stringliteral">      if (leftmost_leaf != node)</span></div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;<span class="stringliteral">        deallocate(LeafSize(node-&gt;max_count()), node, alloc);</span></div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;<span class="stringliteral">      ++pos;</span></div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;<span class="stringliteral">    } while (pos &lt;= parent-&gt;finish());</span></div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;<span class="stringliteral">    // Once we&#39;ve deleted all children of parent, delete parent and go up/right.</span></div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;<span class="stringliteral">    assert(pos &gt; parent-&gt;finish());</span></div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;<span class="stringliteral">    do {</span></div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;<span class="stringliteral">      node = parent;</span></div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;<span class="stringliteral">      pos = node-&gt;position();</span></div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;<span class="stringliteral">      parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;<span class="stringliteral">      node-&gt;value_destroy_n(node-&gt;start(), node-&gt;count(), alloc);</span></div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;<span class="stringliteral">      deallocate(InternalSize(), node, alloc);</span></div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;<span class="stringliteral">      if (parent == delete_root_parent) {</span></div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;<span class="stringliteral">#ifdef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;<span class="stringliteral">        deallocate(LeafSize(leftmost_leaf-&gt;max_count()), leftmost_leaf, alloc);</span></div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;<span class="stringliteral">#endif</span></div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;<span class="stringliteral">        return;</span></div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;<span class="stringliteral">      ++pos;</span></div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;<span class="stringliteral">    } while (pos &gt; parent-&gt;finish());</span></div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;<span class="stringliteral">// btree_iterator methods</span></div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;<span class="stringliteral">// Note: the implementation here is based on btree_node::clear_and_delete.</span></div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;<span class="stringliteral">template &lt;typename N, typename R, typename P&gt;</span></div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;<span class="stringliteral">auto btree_iterator&lt;N, R, P&gt;::distance_slow(const_iterator other) const</span></div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;<span class="stringliteral">    -&gt; difference_type {</span></div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;<span class="stringliteral">  const_iterator begin = other;</span></div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;<span class="stringliteral">  const_iterator end = *this;</span></div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;<span class="stringliteral">  assert(begin.node_ != end.node_ || !begin.node_-&gt;is_leaf() ||</span></div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;<span class="stringliteral">         begin.position_ != end.position_);</span></div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;<span class="stringliteral">  const node_type *node = begin.node_;</span></div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;<span class="stringliteral">  // We need to compensate for double counting if begin.node_ is a leaf node.</span></div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;<span class="stringliteral">  difference_type count = node-&gt;is_leaf() ? -begin.position_ : 0;</span></div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;<span class="stringliteral">  // First navigate to the leftmost leaf node past begin.</span></div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;<span class="stringliteral">  if (node-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;<span class="stringliteral">    ++count;</span></div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;<span class="stringliteral">    node = node-&gt;child(begin.position_ + 1);</span></div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;<span class="stringliteral">  while (node-&gt;is_internal()) node = node-&gt;start_child();</span></div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;<span class="stringliteral">  // Use `size_type` because `pos` needs to be able to hold `kNodeSlots+1`,</span></div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;<span class="stringliteral">  // which isn&#39;t guaranteed to be a valid `field_type`.</span></div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;<span class="stringliteral">  size_type pos = node-&gt;position();</span></div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;<span class="stringliteral">  const node_type *parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;<span class="stringliteral">  for (;;) {</span></div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;<span class="stringliteral">    // In each iteration of the next loop, we count one leaf node and go right.</span></div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;<span class="stringliteral">    assert(pos &lt;= parent-&gt;finish());</span></div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;<span class="stringliteral">    do {</span></div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;<span class="stringliteral">      node = parent-&gt;child(static_cast&lt;field_type&gt;(pos));</span></div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;<span class="stringliteral">      if (node-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;<span class="stringliteral">        // Navigate to the leftmost leaf under node.</span></div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;<span class="stringliteral">        while (node-&gt;is_internal()) node = node-&gt;start_child();</span></div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;<span class="stringliteral">        pos = node-&gt;position();</span></div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;<span class="stringliteral">        parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;<span class="stringliteral">      if (node == end.node_) return count + end.position_;</span></div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;<span class="stringliteral">      if (parent == end.node_ &amp;&amp; pos == static_cast&lt;size_type&gt;(end.position_))</span></div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;<span class="stringliteral">        return count + node-&gt;count();</span></div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;<span class="stringliteral">      // +1 is for the next internal node value.</span></div>
<div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;<span class="stringliteral">      count += node-&gt;count() + 1;</span></div>
<div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;<span class="stringliteral">      ++pos;</span></div>
<div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;<span class="stringliteral">    } while (pos &lt;= parent-&gt;finish());</span></div>
<div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;<span class="stringliteral">    // Once we&#39;ve counted all children of parent, go up/right.</span></div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;<span class="stringliteral">    assert(pos &gt; parent-&gt;finish());</span></div>
<div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;<span class="stringliteral">    do {</span></div>
<div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;<span class="stringliteral">      node = parent;</span></div>
<div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;<span class="stringliteral">      pos = node-&gt;position();</span></div>
<div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;<span class="stringliteral">      parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;<span class="stringliteral">      // -1 because we counted the value at end and shouldn&#39;t.</span></div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;<span class="stringliteral">      if (parent == end.node_ &amp;&amp; pos == static_cast&lt;size_type&gt;(end.position_))</span></div>
<div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;<span class="stringliteral">        return count - 1;</span></div>
<div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;<span class="stringliteral">      ++pos;</span></div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;<span class="stringliteral">    } while (pos &gt; parent-&gt;finish());</span></div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;<span class="stringliteral">template &lt;typename N, typename R, typename P&gt;</span></div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;<span class="stringliteral">void btree_iterator&lt;N, R, P&gt;::increment_slow() {</span></div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;<span class="stringliteral">  if (node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;<span class="stringliteral">    assert(position_ &gt;= node_-&gt;finish());</span></div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;<span class="stringliteral">    btree_iterator save(*this);</span></div>
<div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;<span class="stringliteral">    while (position_ == node_-&gt;finish() &amp;&amp; !node_-&gt;is_root()) {</span></div>
<div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;<span class="stringliteral">      assert(node_-&gt;parent()-&gt;child(node_-&gt;position()) == node_);</span></div>
<div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;<span class="stringliteral">      position_ = node_-&gt;position();</span></div>
<div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;<span class="stringliteral">      node_ = node_-&gt;parent();</span></div>
<div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;<span class="stringliteral">    // TODO(ezb): assert we aren&#39;t incrementing end() instead of handling.</span></div>
<div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;<span class="stringliteral">    if (position_ == node_-&gt;finish()) {</span></div>
<div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;<span class="stringliteral">      *this = save;</span></div>
<div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;<span class="stringliteral">    assert(position_ &lt; node_-&gt;finish());</span></div>
<div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;<span class="stringliteral">    node_ = node_-&gt;child(static_cast&lt;field_type&gt;(position_ + 1));</span></div>
<div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;<span class="stringliteral">    while (node_-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;<span class="stringliteral">      node_ = node_-&gt;start_child();</span></div>
<div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;<span class="stringliteral">    position_ = node_-&gt;start();</span></div>
<div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;<span class="stringliteral">template &lt;typename N, typename R, typename P&gt;</span></div>
<div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;<span class="stringliteral">void btree_iterator&lt;N, R, P&gt;::decrement_slow() {</span></div>
<div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;<span class="stringliteral">  if (node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;<span class="stringliteral">    assert(position_ &lt;= -1);</span></div>
<div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;<span class="stringliteral">    btree_iterator save(*this);</span></div>
<div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;<span class="stringliteral">    while (position_ &lt; node_-&gt;start() &amp;&amp; !node_-&gt;is_root()) {</span></div>
<div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;<span class="stringliteral">      assert(node_-&gt;parent()-&gt;child(node_-&gt;position()) == node_);</span></div>
<div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;<span class="stringliteral">      position_ = node_-&gt;position() - 1;</span></div>
<div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;<span class="stringliteral">      node_ = node_-&gt;parent();</span></div>
<div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;<span class="stringliteral">    // TODO(ezb): assert we aren&#39;t decrementing begin() instead of handling.</span></div>
<div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;<span class="stringliteral">    if (position_ &lt; node_-&gt;start()) {</span></div>
<div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;<span class="stringliteral">      *this = save;</span></div>
<div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;<span class="stringliteral">    assert(position_ &gt;= node_-&gt;start());</span></div>
<div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;<span class="stringliteral">    node_ = node_-&gt;child(static_cast&lt;field_type&gt;(position_));</span></div>
<div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;<span class="stringliteral">    while (node_-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;<span class="stringliteral">      node_ = node_-&gt;child(node_-&gt;finish());</span></div>
<div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;<span class="stringliteral">    position_ = node_-&gt;finish() - 1;</span></div>
<div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;<span class="stringliteral">// btree methods</span></div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;<span class="stringliteral">template &lt;typename Btree&gt;</span></div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;<span class="stringliteral">void btree&lt;P&gt;::copy_or_move_values_in_order(Btree &amp;other) {</span></div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;<span class="stringliteral">  static_assert(std::is_same&lt;btree, Btree&gt;::value ||</span></div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;<span class="stringliteral">                    std::is_same&lt;const btree, Btree&gt;::value,</span></div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;<span class="stringliteral">                &quot;</span>Btree <a class="code" href="structabsl_1_1container__internal_1_1key__compare__adapter.html#af99ac249bd516219a4922ed17d3d33bf">type</a> must be same or <span class="keyword">const</span>.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;<span class="stringliteral">  assert(empty());</span></div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;<span class="stringliteral">  // We can avoid key comparisons because we know the order of the</span></div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;<span class="stringliteral">  // values is the same order we&#39;ll store them in.</span></div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;<span class="stringliteral">  auto iter = other.begin();</span></div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;<span class="stringliteral">  if (iter == other.end()) return;</span></div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;<span class="stringliteral">  insert_multi(iter.slot());</span></div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;<span class="stringliteral">  ++iter;</span></div>
<div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;<span class="stringliteral">  for (; iter != other.end(); ++iter) {</span></div>
<div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;<span class="stringliteral">    // If the btree is not empty, we can just insert the new value at the end</span></div>
<div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;<span class="stringliteral">    // of the tree.</span></div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;<span class="stringliteral">    internal_emplace(end(), iter.slot());</span></div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;<span class="stringliteral">constexpr bool btree&lt;P&gt;::static_assert_validation() {</span></div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;<span class="stringliteral">  static_assert(std::is_nothrow_copy_constructible&lt;key_compare&gt;::value,</span></div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;<span class="stringliteral">                &quot;</span>Key comparison must be nothrow copy constructible<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;<span class="stringliteral">  static_assert(std::is_nothrow_copy_constructible&lt;allocator_type&gt;::value,</span></div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;<span class="stringliteral">                &quot;</span>Allocator must be nothrow copy constructible<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;<span class="stringliteral">  static_assert(type_traits_internal::is_trivially_copyable&lt;iterator&gt;::value,</span></div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;<span class="stringliteral">                &quot;</span>iterator not trivially copyable.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;<span class="stringliteral">  // Note: We assert that kTargetValues, which is computed from</span></div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;<span class="stringliteral">  // Params::kTargetNodeSize, must fit the node_type::field_type.</span></div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;<span class="stringliteral">  static_assert(</span></div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;<span class="stringliteral">      kNodeSlots &lt; (1 &lt;&lt; (8 * sizeof(typename node_type::field_type))),</span></div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;<span class="stringliteral">      &quot;</span>target node <a class="code" href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a> too large<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;<span class="stringliteral">  // Verify that key_compare returns an absl::{weak,strong}_ordering or bool.</span></div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;<span class="stringliteral">  static_assert(</span></div>
<div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;<span class="stringliteral">      compare_has_valid_result_type&lt;key_compare, key_type&gt;(),</span></div>
<div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;<span class="stringliteral">      &quot;</span><a class="code" href="btree__test_8cc.html#a35af0be900467fedbb610bd6ea65ed78">key</a> comparison <span class="keyword">function</span> must <span class="keywordflow">return</span> <a class="code" href="namespaceabsl.html">absl</a>::{weak,strong}_ordering or <span class="stringliteral">&quot;</span></div>
<div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;<span class="stringliteral">      &quot;</span><span class="keywordtype">bool</span>.<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;<span class="stringliteral">  // Test the assumption made in setting kNodeSlotSpace.</span></div>
<div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;<span class="stringliteral">  static_assert(node_type::MinimumOverhead() &gt;= sizeof(void *) + 4,</span></div>
<div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;<span class="stringliteral">                &quot;</span>node space assumption incorrect<span class="stringliteral">&quot;);</span></div>
<div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;<span class="stringliteral">  return true;</span></div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;<span class="stringliteral">template &lt;typename K&gt;</span></div>
<div class="line"><a name="l02207"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a685ddbe256bbe04511f7657b35178a1d"> 2207</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::lower_bound_equal(const K &amp;key) const</span></div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;<span class="stringliteral">    -&gt; std::pair&lt;iterator, bool&gt; {</span></div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;<span class="stringliteral">  const SearchResult&lt;iterator, is_key_compare_to::value&gt; res =</span></div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;<span class="stringliteral">      internal_lower_bound(key);</span></div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;<span class="stringliteral">  const iterator lower = iterator(internal_end(res.value));</span></div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;<span class="stringliteral">  const bool equal = res.HasMatch()</span></div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;<span class="stringliteral">                         ? res.IsEq()</span></div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;<span class="stringliteral">                         : lower != end() &amp;&amp; !compare_keys(key, lower.key());</span></div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;<span class="stringliteral">  return {lower, equal};</span></div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;<span class="stringliteral">template &lt;typename K&gt;</span></div>
<div class="line"><a name="l02220"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a791d4a405c5eb148d17741a9da0466c6"> 2220</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::equal_range(const K &amp;key) -&gt; std::pair&lt;iterator, iterator&gt; {</span></div>
<div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;<span class="stringliteral">  const std::pair&lt;iterator, bool&gt; lower_and_equal = lower_bound_equal(key);</span></div>
<div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;<span class="stringliteral">  const iterator lower = lower_and_equal.first;</span></div>
<div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;<span class="stringliteral">  if (!lower_and_equal.second) {</span></div>
<div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;<span class="stringliteral">    return {lower, lower};</span></div>
<div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;<span class="stringliteral">  const iterator next = std::next(lower);</span></div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;<span class="stringliteral">  if (!params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {</span></div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;<span class="stringliteral">    // The next iterator after lower must point to a key greater than `key`.</span></div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;<span class="stringliteral">    // Note: if this assert fails, then it may indicate that the comparator does</span></div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;<span class="stringliteral">    // not meet the equivalence requirements for Compare</span></div>
<div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;<span class="stringliteral">    // (see https://en.cppreference.com/w/cpp/named_req/Compare).</span></div>
<div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;<span class="stringliteral">    assert(next == end() || compare_keys(key, next.key()));</span></div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;<span class="stringliteral">    return {lower, next};</span></div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;<span class="stringliteral">  // Try once more to avoid the call to upper_bound() if there&#39;s only one</span></div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;<span class="stringliteral">  // equivalent key. This should prevent all calls to upper_bound() in cases of</span></div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;<span class="stringliteral">  // unique-containers with heterogeneous comparators in which all comparison</span></div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;<span class="stringliteral">  // operators have the same equivalence classes.</span></div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;<span class="stringliteral">  if (next == end() || compare_keys(key, next.key())) return {lower, next};</span></div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;<span class="stringliteral">  // In this case, we need to call upper_bound() to avoid worst case O(N)</span></div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;<span class="stringliteral">  // behavior if we were to iterate over equal keys.</span></div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;<span class="stringliteral">  return {lower, upper_bound(key)};</span></div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;<span class="stringliteral">template &lt;typename K, typename... Args&gt;</span></div>
<div class="line"><a name="l02249"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a4e29b0453278c25641d3b74eebb44fab"> 2249</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::insert_unique(const K &amp;key, Args &amp;&amp;...args)</span></div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;<span class="stringliteral">    -&gt; std::pair&lt;iterator, bool&gt; {</span></div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;<span class="stringliteral">  if (empty()) {</span></div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;<span class="stringliteral">    mutable_root() = mutable_rightmost() = new_leaf_root_node(1);</span></div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;<span class="stringliteral">  SearchResult&lt;iterator, is_key_compare_to::value&gt; res = internal_locate(key);</span></div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;<span class="stringliteral">  iterator iter = res.value;</span></div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;<span class="stringliteral">  if (res.HasMatch()) {</span></div>
<div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;<span class="stringliteral">    if (res.IsEq()) {</span></div>
<div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;<span class="stringliteral">      // The key already exists in the tree, do nothing.</span></div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;<span class="stringliteral">      return {iter, false};</span></div>
<div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;<span class="stringliteral">    iterator last = internal_last(iter);</span></div>
<div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;<span class="stringliteral">    if (last.node_ &amp;&amp; !compare_keys(key, last.key())) {</span></div>
<div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;<span class="stringliteral">      // The key already exists in the tree, do nothing.</span></div>
<div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;<span class="stringliteral">      return {last, false};</span></div>
<div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;<span class="stringliteral">  return {internal_emplace(iter, std::forward&lt;Args&gt;(args)...), true};</span></div>
<div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;<span class="stringliteral">template &lt;typename K, typename... Args&gt;</span></div>
<div class="line"><a name="l02275"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a803b2d55900bb5f44a4d5aa192ad4df8"> 2275</a></span>&#160;<span class="stringliteral">inline auto btree&lt;P&gt;::insert_hint_unique(iterator position, const K &amp;key,</span></div>
<div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;<span class="stringliteral">                                         Args &amp;&amp;...args)</span></div>
<div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;<span class="stringliteral">    -&gt; std::pair&lt;iterator, bool&gt; {</span></div>
<div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;<span class="stringliteral">  if (!empty()) {</span></div>
<div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;<span class="stringliteral">    if (position == end() || compare_keys(key, position.key())) {</span></div>
<div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;<span class="stringliteral">      if (position == begin() || compare_keys(std::prev(position).key(), key)) {</span></div>
<div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;<span class="stringliteral">        // prev.key() &lt; key &lt; position.key()</span></div>
<div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;<span class="stringliteral">        return {internal_emplace(position, std::forward&lt;Args&gt;(args)...), true};</span></div>
<div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;<span class="stringliteral">    } else if (compare_keys(position.key(), key)) {</span></div>
<div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;<span class="stringliteral">      ++position;</span></div>
<div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;<span class="stringliteral">      if (position == end() || compare_keys(key, position.key())) {</span></div>
<div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;<span class="stringliteral">        // {original `position`}.key() &lt; key &lt; {current `position`}.key()</span></div>
<div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;<span class="stringliteral">        return {internal_emplace(position, std::forward&lt;Args&gt;(args)...), true};</span></div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;<span class="stringliteral">      // position.key() == key</span></div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;<span class="stringliteral">      return {position, false};</span></div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;<span class="stringliteral">  return insert_unique(key, std::forward&lt;Args&gt;(args)...);</span></div>
<div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;<span class="stringliteral">template &lt;typename InputIterator, typename&gt;</span></div>
<div class="line"><a name="l02300"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a9a01313c289bbf4df1f0d13a4826e227"> 2300</a></span>&#160;<span class="stringliteral">void btree&lt;P&gt;::insert_iterator_unique(InputIterator b, InputIterator e, int) {</span></div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;<span class="stringliteral">  for (; b != e; ++b) {</span></div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;<span class="stringliteral">    insert_hint_unique(end(), params_type::key(*b), *b);</span></div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;<span class="stringliteral">template &lt;typename InputIterator&gt;</span></div>
<div class="line"><a name="l02308"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ac6406042363fe073fc741984d13e2c2f"> 2308</a></span>&#160;<span class="stringliteral">void btree&lt;P&gt;::insert_iterator_unique(InputIterator b, InputIterator e, char) {</span></div>
<div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;<span class="stringliteral">  for (; b != e; ++b) {</span></div>
<div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;<span class="stringliteral">    // Use a node handle to manage a temp slot.</span></div>
<div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;<span class="stringliteral">    auto node_handle =</span></div>
<div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;<span class="stringliteral">        CommonAccess::Construct&lt;node_handle_type&gt;(get_allocator(), *b);</span></div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;<span class="stringliteral">    slot_type *slot = CommonAccess::GetSlot(node_handle);</span></div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;<span class="stringliteral">    insert_hint_unique(end(), params_type::key(slot), slot);</span></div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;<span class="stringliteral">template &lt;typename ValueType&gt;</span></div>
<div class="line"><a name="l02320"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a7da0e22391c008caed5404e775d5c479"> 2320</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::insert_multi(const key_type &amp;key, ValueType &amp;&amp;v) -&gt; iterator {</span></div>
<div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;<span class="stringliteral">  if (empty()) {</span></div>
<div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;<span class="stringliteral">    mutable_root() = mutable_rightmost() = new_leaf_root_node(1);</span></div>
<div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;<span class="stringliteral">  iterator iter = internal_upper_bound(key);</span></div>
<div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;<span class="stringliteral">  if (iter.node_ == nullptr) {</span></div>
<div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;<span class="stringliteral">    iter = end();</span></div>
<div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;<span class="stringliteral">  return internal_emplace(iter, std::forward&lt;ValueType&gt;(v));</span></div>
<div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;<span class="stringliteral">template &lt;typename ValueType&gt;</span></div>
<div class="line"><a name="l02334"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a92c92d78d498976762004e04b212f58b"> 2334</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::insert_hint_multi(iterator position, ValueType &amp;&amp;v) -&gt; iterator {</span></div>
<div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;<span class="stringliteral">  if (!empty()) {</span></div>
<div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;<span class="stringliteral">    const key_type &amp;key = params_type::key(v);</span></div>
<div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;<span class="stringliteral">    if (position == end() || !compare_keys(position.key(), key)) {</span></div>
<div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;<span class="stringliteral">      if (position == begin() ||</span></div>
<div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;<span class="stringliteral">          !compare_keys(key, std::prev(position).key())) {</span></div>
<div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;<span class="stringliteral">        // prev.key() &lt;= key &lt;= position.key()</span></div>
<div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;<span class="stringliteral">        return internal_emplace(position, std::forward&lt;ValueType&gt;(v));</span></div>
<div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;<span class="stringliteral">      ++position;</span></div>
<div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;<span class="stringliteral">      if (position == end() || !compare_keys(position.key(), key)) {</span></div>
<div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;<span class="stringliteral">        // {original `position`}.key() &lt; key &lt; {current `position`}.key()</span></div>
<div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;<span class="stringliteral">        return internal_emplace(position, std::forward&lt;ValueType&gt;(v));</span></div>
<div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;<span class="stringliteral">  return insert_multi(std::forward&lt;ValueType&gt;(v));</span></div>
<div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;<span class="stringliteral">template &lt;typename InputIterator&gt;</span></div>
<div class="line"><a name="l02356"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a7d94d1fbb95cf470eca71b6da1935e3a"> 2356</a></span>&#160;<span class="stringliteral">void btree&lt;P&gt;::insert_iterator_multi(InputIterator b, InputIterator e) {</span></div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;<span class="stringliteral">  for (; b != e; ++b) {</span></div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;<span class="stringliteral">    insert_hint_multi(end(), *b);</span></div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02363"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a2d49147afcd21e6c8aa6149fffe3d589"> 2363</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::operator=(const btree &amp;other) -&gt; btree &amp; {</span></div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;<span class="stringliteral">  if (this != &amp;other) {</span></div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;<span class="stringliteral">    clear();</span></div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;<span class="stringliteral">    *mutable_key_comp() = other.key_comp();</span></div>
<div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;<span class="stringliteral">    if (absl::allocator_traits&lt;</span></div>
<div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;<span class="stringliteral">            allocator_type&gt;::propagate_on_container_copy_assignment::value) {</span></div>
<div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;<span class="stringliteral">      *mutable_allocator() = other.allocator();</span></div>
<div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;<span class="stringliteral">    copy_or_move_values_in_order(other);</span></div>
<div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;<span class="stringliteral">  return *this;</span></div>
<div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02379"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a426e5e101a0990259966b3c527a00ffd"> 2379</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::operator=(btree &amp;&amp;other) noexcept -&gt; btree &amp; {</span></div>
<div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;<span class="stringliteral">  if (this != &amp;other) {</span></div>
<div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;<span class="stringliteral">    clear();</span></div>
<div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;<span class="stringliteral">    using std::swap;</span></div>
<div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;<span class="stringliteral">    if (absl::allocator_traits&lt;</span></div>
<div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;<span class="stringliteral">            allocator_type&gt;::propagate_on_container_copy_assignment::value) {</span></div>
<div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;<span class="stringliteral">      swap(root_, other.root_);</span></div>
<div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;<span class="stringliteral">      // Note: `rightmost_` also contains the allocator and the key comparator.</span></div>
<div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;<span class="stringliteral">      swap(rightmost_, other.rightmost_);</span></div>
<div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;<span class="stringliteral">      swap(size_, other.size_);</span></div>
<div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;<span class="stringliteral">      if (allocator() == other.allocator()) {</span></div>
<div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;<span class="stringliteral">        swap(mutable_root(), other.mutable_root());</span></div>
<div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;<span class="stringliteral">        swap(*mutable_key_comp(), *other.mutable_key_comp());</span></div>
<div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;<span class="stringliteral">        swap(mutable_rightmost(), other.mutable_rightmost());</span></div>
<div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;<span class="stringliteral">        swap(size_, other.size_);</span></div>
<div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;<span class="stringliteral">      } else {</span></div>
<div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;<span class="stringliteral">        // We aren&#39;t allowed to propagate the allocator and the allocator is</span></div>
<div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;<span class="stringliteral">        // different so we can&#39;t take over its memory. We must move each element</span></div>
<div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;<span class="stringliteral">        // individually. We need both `other` and `this` to have `other`s key</span></div>
<div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;<span class="stringliteral">        // comparator while moving the values so we can&#39;t swap the key</span></div>
<div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;<span class="stringliteral">        // comparators.</span></div>
<div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;<span class="stringliteral">        *mutable_key_comp() = other.key_comp();</span></div>
<div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;<span class="stringliteral">        copy_or_move_values_in_order(other);</span></div>
<div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;<span class="stringliteral">  return *this;</span></div>
<div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02411"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ab1db43f454a4da0926bd5f03b17f0595"> 2411</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::erase(iterator iter) -&gt; iterator {</span></div>
<div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;<span class="stringliteral">  iter.node_-&gt;value_destroy(static_cast&lt;field_type&gt;(iter.position_),</span></div>
<div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;<span class="stringliteral">                            mutable_allocator());</span></div>
<div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;<span class="stringliteral">  iter.update_generation();</span></div>
<div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;<span class="stringliteral">  const bool internal_delete = iter.node_-&gt;is_internal();</span></div>
<div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;<span class="stringliteral">  if (internal_delete) {</span></div>
<div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;<span class="stringliteral">    // Deletion of a value on an internal node. First, transfer the largest</span></div>
<div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;<span class="stringliteral">    // value from our left child here, then erase/rebalance from that position.</span></div>
<div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;<span class="stringliteral">    // We can get to the largest value from our left child by decrementing iter.</span></div>
<div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;<span class="stringliteral">    iterator internal_iter(iter);</span></div>
<div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;<span class="stringliteral">    --iter;</span></div>
<div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;<span class="stringliteral">    assert(iter.node_-&gt;is_leaf());</span></div>
<div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;<span class="stringliteral">    internal_iter.node_-&gt;transfer(</span></div>
<div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;<span class="stringliteral">        static_cast&lt;size_type&gt;(internal_iter.position_),</span></div>
<div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;<span class="stringliteral">        static_cast&lt;size_type&gt;(iter.position_), iter.node_,</span></div>
<div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;<span class="stringliteral">        mutable_allocator());</span></div>
<div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;<span class="stringliteral">    // Shift values after erased position in leaf. In the internal case, we</span></div>
<div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;<span class="stringliteral">    // don&#39;t need to do this because the leaf position is the end of the node.</span></div>
<div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;<span class="stringliteral">    const field_type transfer_from =</span></div>
<div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;<span class="stringliteral">        static_cast&lt;field_type&gt;(iter.position_ + 1);</span></div>
<div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;<span class="stringliteral">    const field_type num_to_transfer = iter.node_-&gt;finish() - transfer_from;</span></div>
<div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;<span class="stringliteral">    iter.node_-&gt;transfer_n(num_to_transfer,</span></div>
<div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;<span class="stringliteral">                           static_cast&lt;size_type&gt;(iter.position_),</span></div>
<div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;<span class="stringliteral">                           transfer_from, iter.node_, mutable_allocator());</span></div>
<div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;<span class="stringliteral">  // Update node finish and container size.</span></div>
<div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;<span class="stringliteral">  iter.node_-&gt;set_finish(iter.node_-&gt;finish() - 1);</span></div>
<div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;<span class="stringliteral">  --size_;</span></div>
<div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;<span class="stringliteral">  // We want to return the next value after the one we just erased. If we</span></div>
<div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;<span class="stringliteral">  // erased from an internal node (internal_delete == true), then the next</span></div>
<div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;<span class="stringliteral">  // value is ++(++iter). If we erased from a leaf node (internal_delete ==</span></div>
<div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;<span class="stringliteral">  // false) then the next value is ++iter. Note that ++iter may point to an</span></div>
<div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;<span class="stringliteral">  // internal node and the value in the internal node may move to a leaf node</span></div>
<div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;<span class="stringliteral">  // (iter.node_) when rebalancing is performed at the leaf level.</span></div>
<div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;<span class="stringliteral">  iterator res = rebalance_after_delete(iter);</span></div>
<div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;<span class="stringliteral">  // If we erased from an internal node, advance the iterator.</span></div>
<div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;<span class="stringliteral">  if (internal_delete) {</span></div>
<div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;<span class="stringliteral">    ++res;</span></div>
<div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;<span class="stringliteral">  return res;</span></div>
<div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::rebalance_after_delete(iterator iter) -&gt; iterator {</span></div>
<div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;<span class="stringliteral">  // Merge/rebalance as we walk back up the tree.</span></div>
<div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;<span class="stringliteral">  iterator res(iter);</span></div>
<div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;<span class="stringliteral">  bool first_iteration = true;</span></div>
<div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;<span class="stringliteral">  for (;;) {</span></div>
<div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;<span class="stringliteral">    if (iter.node_ == root()) {</span></div>
<div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;<span class="stringliteral">      try_shrink();</span></div>
<div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;<span class="stringliteral">      if (empty()) {</span></div>
<div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;<span class="stringliteral">        return end();</span></div>
<div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;<span class="stringliteral">    if (iter.node_-&gt;count() &gt;= kMinNodeValues) {</span></div>
<div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;<span class="stringliteral">    bool merged = try_merge_or_rebalance(&amp;iter);</span></div>
<div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;<span class="stringliteral">    // On the first iteration, we should update `res` with `iter` because `res`</span></div>
<div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;<span class="stringliteral">    // may have been invalidated.</span></div>
<div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;<span class="stringliteral">    if (first_iteration) {</span></div>
<div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;<span class="stringliteral">      res = iter;</span></div>
<div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;<span class="stringliteral">      first_iteration = false;</span></div>
<div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;<span class="stringliteral">    if (!merged) {</span></div>
<div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;<span class="stringliteral">    iter.position_ = iter.node_-&gt;position();</span></div>
<div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;<span class="stringliteral">    iter.node_ = iter.node_-&gt;parent();</span></div>
<div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;<span class="stringliteral">  res.update_generation();</span></div>
<div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;<span class="stringliteral">  // Adjust our return value. If we&#39;re pointing at the end of a node, advance</span></div>
<div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;<span class="stringliteral">  // the iterator.</span></div>
<div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;<span class="stringliteral">  if (res.position_ == res.node_-&gt;finish()) {</span></div>
<div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;<span class="stringliteral">    res.position_ = res.node_-&gt;finish() - 1;</span></div>
<div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;<span class="stringliteral">    ++res;</span></div>
<div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;<span class="stringliteral">  return res;</span></div>
<div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02500"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a3df02dbcb0dce2740994a3e0619bf6fc"> 2500</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::erase_range(iterator begin, iterator end)</span></div>
<div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;<span class="stringliteral">    -&gt; std::pair&lt;size_type, iterator&gt; {</span></div>
<div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;<span class="stringliteral">  size_type count = static_cast&lt;size_type&gt;(end - begin);</span></div>
<div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;<span class="stringliteral">  assert(count &gt;= 0);</span></div>
<div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;<span class="stringliteral">  if (count == 0) {</span></div>
<div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;<span class="stringliteral">    return {0, begin};</span></div>
<div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;<span class="stringliteral">  if (static_cast&lt;size_type&gt;(count) == size_) {</span></div>
<div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;<span class="stringliteral">    clear();</span></div>
<div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;<span class="stringliteral">    return {count, this-&gt;end()};</span></div>
<div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;<span class="stringliteral">  if (begin.node_ == end.node_) {</span></div>
<div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;<span class="stringliteral">    assert(end.position_ &gt; begin.position_);</span></div>
<div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;<span class="stringliteral">    begin.node_-&gt;remove_values(</span></div>
<div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;<span class="stringliteral">        static_cast&lt;field_type&gt;(begin.position_),</span></div>
<div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;<span class="stringliteral">        static_cast&lt;field_type&gt;(end.position_ - begin.position_),</span></div>
<div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;<span class="stringliteral">        mutable_allocator());</span></div>
<div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;<span class="stringliteral">    size_ -= count;</span></div>
<div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;<span class="stringliteral">    return {count, rebalance_after_delete(begin)};</span></div>
<div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;<span class="stringliteral">  const size_type target_size = size_ - count;</span></div>
<div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;<span class="stringliteral">  while (size_ &gt; target_size) {</span></div>
<div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;<span class="stringliteral">    if (begin.node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;<span class="stringliteral">      const size_type remaining_to_erase = size_ - target_size;</span></div>
<div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;<span class="stringliteral">      const size_type remaining_in_node =</span></div>
<div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;<span class="stringliteral">          static_cast&lt;size_type&gt;(begin.node_-&gt;finish() - begin.position_);</span></div>
<div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;<span class="stringliteral">      const field_type to_erase = static_cast&lt;field_type&gt;(</span></div>
<div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;<span class="stringliteral">          (std::min)(remaining_to_erase, remaining_in_node));</span></div>
<div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;<span class="stringliteral">      begin.node_-&gt;remove_values(static_cast&lt;field_type&gt;(begin.position_),</span></div>
<div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;<span class="stringliteral">                                 to_erase, mutable_allocator());</span></div>
<div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;<span class="stringliteral">      size_ -= to_erase;</span></div>
<div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;<span class="stringliteral">      begin = rebalance_after_delete(begin);</span></div>
<div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;<span class="stringliteral">      begin = erase(begin);</span></div>
<div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;<span class="stringliteral">  begin.update_generation();</span></div>
<div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;<span class="stringliteral">  return {count, begin};</span></div>
<div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02545"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a11560eba0f9fc3336a239b7b2c7a37b2"> 2545</a></span>&#160;<span class="stringliteral">void btree&lt;P&gt;::clear() {</span></div>
<div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;<span class="stringliteral">  if (!empty()) {</span></div>
<div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;<span class="stringliteral">    node_type::clear_and_delete(root(), mutable_allocator());</span></div>
<div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;<span class="stringliteral">  mutable_root() = mutable_rightmost() = EmptyNode();</span></div>
<div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;<span class="stringliteral">  size_ = 0;</span></div>
<div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02554"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a3987979b384f44065f862d9314d772a4"> 2554</a></span>&#160;<span class="stringliteral">void btree&lt;P&gt;::swap(btree &amp;other) {</span></div>
<div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;<span class="stringliteral">  using std::swap;</span></div>
<div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;<span class="stringliteral">  if (absl::allocator_traits&lt;</span></div>
<div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;<span class="stringliteral">          allocator_type&gt;::propagate_on_container_swap::value) {</span></div>
<div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;<span class="stringliteral">    // Note: `rightmost_` also contains the allocator and the key comparator.</span></div>
<div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;<span class="stringliteral">    swap(rightmost_, other.rightmost_);</span></div>
<div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;<span class="stringliteral">    // It&#39;s undefined behavior if the allocators are unequal here.</span></div>
<div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;<span class="stringliteral">    assert(allocator() == other.allocator());</span></div>
<div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;<span class="stringliteral">    swap(mutable_rightmost(), other.mutable_rightmost());</span></div>
<div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;<span class="stringliteral">    swap(*mutable_key_comp(), *other.mutable_key_comp());</span></div>
<div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;<span class="stringliteral">  swap(mutable_root(), other.mutable_root());</span></div>
<div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;<span class="stringliteral">  swap(size_, other.size_);</span></div>
<div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02571"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a8caf797f16f620731fef7f5f42257706"> 2571</a></span>&#160;<span class="stringliteral">void btree&lt;P&gt;::verify() const {</span></div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;<span class="stringliteral">  assert(root() != nullptr);</span></div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;<span class="stringliteral">  assert(leftmost() != nullptr);</span></div>
<div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;<span class="stringliteral">  assert(rightmost() != nullptr);</span></div>
<div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;<span class="stringliteral">  assert(empty() || size() == internal_verify(root(), nullptr, nullptr));</span></div>
<div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;<span class="stringliteral">  assert(leftmost() == (++const_iterator(root(), -1)).node_);</span></div>
<div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;<span class="stringliteral">  assert(rightmost() == (--const_iterator(root(), root()-&gt;finish())).node_);</span></div>
<div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;<span class="stringliteral">  assert(leftmost()-&gt;is_leaf());</span></div>
<div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;<span class="stringliteral">  assert(rightmost()-&gt;is_leaf());</span></div>
<div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;<span class="stringliteral">void btree&lt;P&gt;::rebalance_or_split(iterator *iter) {</span></div>
<div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;<span class="stringliteral">  node_type *&amp;node = iter-&gt;node_;</span></div>
<div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;<span class="stringliteral">  int &amp;insert_position = iter-&gt;position_;</span></div>
<div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;<span class="stringliteral">  assert(node-&gt;count() == node-&gt;max_count());</span></div>
<div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;<span class="stringliteral">  assert(kNodeSlots == node-&gt;max_count());</span></div>
<div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;<span class="stringliteral">  // First try to make room on the node by rebalancing.</span></div>
<div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;<span class="stringliteral">  node_type *parent = node-&gt;parent();</span></div>
<div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;<span class="stringliteral">  if (node != root()) {</span></div>
<div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;<span class="stringliteral">    if (node-&gt;position() &gt; parent-&gt;start()) {</span></div>
<div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;<span class="stringliteral">      // Try rebalancing with our left sibling.</span></div>
<div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;<span class="stringliteral">      node_type *left = parent-&gt;child(node-&gt;position() - 1);</span></div>
<div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;<span class="stringliteral">      assert(left-&gt;max_count() == kNodeSlots);</span></div>
<div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;<span class="stringliteral">      if (left-&gt;count() &lt; kNodeSlots) {</span></div>
<div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;<span class="stringliteral">        // We bias rebalancing based on the position being inserted. If we&#39;re</span></div>
<div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;<span class="stringliteral">        // inserting at the end of the right node then we bias rebalancing to</span></div>
<div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;<span class="stringliteral">        // fill up the left node.</span></div>
<div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;<span class="stringliteral">        field_type to_move =</span></div>
<div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;<span class="stringliteral">            (kNodeSlots - left-&gt;count()) /</span></div>
<div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;<span class="stringliteral">            (1 + (static_cast&lt;field_type&gt;(insert_position) &lt; kNodeSlots));</span></div>
<div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;<span class="stringliteral">        to_move = (std::max)(field_type{1}, to_move);</span></div>
<div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;<span class="stringliteral">        if (static_cast&lt;field_type&gt;(insert_position) - to_move &gt;=</span></div>
<div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;<span class="stringliteral">                node-&gt;start() ||</span></div>
<div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;<span class="stringliteral">            left-&gt;count() + to_move &lt; kNodeSlots) {</span></div>
<div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;<span class="stringliteral">          left-&gt;rebalance_right_to_left(to_move, node, mutable_allocator());</span></div>
<div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;<span class="stringliteral">          assert(node-&gt;max_count() - node-&gt;count() == to_move);</span></div>
<div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;<span class="stringliteral">          insert_position = static_cast&lt;int&gt;(</span></div>
<div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;<span class="stringliteral">              static_cast&lt;field_type&gt;(insert_position) - to_move);</span></div>
<div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;<span class="stringliteral">          if (insert_position &lt; node-&gt;start()) {</span></div>
<div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;<span class="stringliteral">            insert_position = insert_position + left-&gt;count() + 1;</span></div>
<div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;<span class="stringliteral">            node = left;</span></div>
<div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;<span class="stringliteral">          }</span></div>
<div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;<span class="stringliteral">          assert(node-&gt;count() &lt; node-&gt;max_count());</span></div>
<div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;<span class="stringliteral">          return;</span></div>
<div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;<span class="stringliteral">    if (node-&gt;position() &lt; parent-&gt;finish()) {</span></div>
<div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;<span class="stringliteral">      // Try rebalancing with our right sibling.</span></div>
<div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;<span class="stringliteral">      node_type *right = parent-&gt;child(node-&gt;position() + 1);</span></div>
<div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;<span class="stringliteral">      assert(right-&gt;max_count() == kNodeSlots);</span></div>
<div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;<span class="stringliteral">      if (right-&gt;count() &lt; kNodeSlots) {</span></div>
<div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;<span class="stringliteral">        // We bias rebalancing based on the position being inserted. If we&#39;re</span></div>
<div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;<span class="stringliteral">        // inserting at the beginning of the left node then we bias rebalancing</span></div>
<div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;<span class="stringliteral">        // to fill up the right node.</span></div>
<div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;<span class="stringliteral">        field_type to_move = (kNodeSlots - right-&gt;count()) /</span></div>
<div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;<span class="stringliteral">                             (1 + (insert_position &gt; node-&gt;start()));</span></div>
<div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;<span class="stringliteral">        to_move = (std::max)(field_type{1}, to_move);</span></div>
<div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;<span class="stringliteral">        if (static_cast&lt;field_type&gt;(insert_position) &lt;=</span></div>
<div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;<span class="stringliteral">                node-&gt;finish() - to_move ||</span></div>
<div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;<span class="stringliteral">            right-&gt;count() + to_move &lt; kNodeSlots) {</span></div>
<div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;<span class="stringliteral">          node-&gt;rebalance_left_to_right(to_move, right, mutable_allocator());</span></div>
<div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;<span class="stringliteral">          if (insert_position &gt; node-&gt;finish()) {</span></div>
<div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;<span class="stringliteral">            insert_position = insert_position - node-&gt;count() - 1;</span></div>
<div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;<span class="stringliteral">            node = right;</span></div>
<div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;<span class="stringliteral">          }</span></div>
<div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;<span class="stringliteral">          assert(node-&gt;count() &lt; node-&gt;max_count());</span></div>
<div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;<span class="stringliteral">          return;</span></div>
<div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;<span class="stringliteral">    // Rebalancing failed, make sure there is room on the parent node for a new</span></div>
<div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;<span class="stringliteral">    // value.</span></div>
<div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;<span class="stringliteral">    assert(parent-&gt;max_count() == kNodeSlots);</span></div>
<div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;<span class="stringliteral">    if (parent-&gt;count() == kNodeSlots) {</span></div>
<div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;<span class="stringliteral">      iterator parent_iter(node-&gt;parent(), node-&gt;position());</span></div>
<div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;<span class="stringliteral">      rebalance_or_split(&amp;parent_iter);</span></div>
<div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;<span class="stringliteral">    // Rebalancing not possible because this is the root node.</span></div>
<div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;<span class="stringliteral">    // Create a new root node and set the current root node as the child of the</span></div>
<div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;<span class="stringliteral">    // new root.</span></div>
<div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;<span class="stringliteral">    parent = new_internal_node(parent);</span></div>
<div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;<span class="stringliteral">    parent-&gt;set_generation(root()-&gt;generation());</span></div>
<div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;<span class="stringliteral">    parent-&gt;init_child(parent-&gt;start(), root());</span></div>
<div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;<span class="stringliteral">    mutable_root() = parent;</span></div>
<div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;<span class="stringliteral">    // If the former root was a leaf node, then it&#39;s now the rightmost node.</span></div>
<div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;<span class="stringliteral">    assert(parent-&gt;start_child()-&gt;is_internal() ||</span></div>
<div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;<span class="stringliteral">           parent-&gt;start_child() == rightmost());</span></div>
<div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;<span class="stringliteral">  // Split the node.</span></div>
<div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;<span class="stringliteral">  node_type *split_node;</span></div>
<div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;<span class="stringliteral">  if (node-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;<span class="stringliteral">    split_node = new_leaf_node(parent);</span></div>
<div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;<span class="stringliteral">    node-&gt;split(insert_position, split_node, mutable_allocator());</span></div>
<div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;<span class="stringliteral">    if (rightmost() == node) mutable_rightmost() = split_node;</span></div>
<div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;<span class="stringliteral">    split_node = new_internal_node(parent);</span></div>
<div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;<span class="stringliteral">    node-&gt;split(insert_position, split_node, mutable_allocator());</span></div>
<div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;<span class="stringliteral">  if (insert_position &gt; node-&gt;finish()) {</span></div>
<div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;<span class="stringliteral">    insert_position = insert_position - node-&gt;count() - 1;</span></div>
<div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;<span class="stringliteral">    node = split_node;</span></div>
<div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;<span class="stringliteral">void btree&lt;P&gt;::merge_nodes(node_type *left, node_type *right) {</span></div>
<div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;<span class="stringliteral">  left-&gt;merge(right, mutable_allocator());</span></div>
<div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;<span class="stringliteral">  if (rightmost() == right) mutable_rightmost() = left;</span></div>
<div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;<span class="stringliteral">bool btree&lt;P&gt;::try_merge_or_rebalance(iterator *iter) {</span></div>
<div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;<span class="stringliteral">  node_type *parent = iter-&gt;node_-&gt;parent();</span></div>
<div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;<span class="stringliteral">  if (iter-&gt;node_-&gt;position() &gt; parent-&gt;start()) {</span></div>
<div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;<span class="stringliteral">    // Try merging with our left sibling.</span></div>
<div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;<span class="stringliteral">    node_type *left = parent-&gt;child(iter-&gt;node_-&gt;position() - 1);</span></div>
<div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;<span class="stringliteral">    assert(left-&gt;max_count() == kNodeSlots);</span></div>
<div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;<span class="stringliteral">    if (1U + left-&gt;count() + iter-&gt;node_-&gt;count() &lt;= kNodeSlots) {</span></div>
<div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;<span class="stringliteral">      iter-&gt;position_ += 1 + left-&gt;count();</span></div>
<div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;<span class="stringliteral">      merge_nodes(left, iter-&gt;node_);</span></div>
<div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;<span class="stringliteral">      iter-&gt;node_ = left;</span></div>
<div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;<span class="stringliteral">      return true;</span></div>
<div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;<span class="stringliteral">  if (iter-&gt;node_-&gt;position() &lt; parent-&gt;finish()) {</span></div>
<div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;<span class="stringliteral">    // Try merging with our right sibling.</span></div>
<div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;<span class="stringliteral">    node_type *right = parent-&gt;child(iter-&gt;node_-&gt;position() + 1);</span></div>
<div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;<span class="stringliteral">    assert(right-&gt;max_count() == kNodeSlots);</span></div>
<div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160;<span class="stringliteral">    if (1U + iter-&gt;node_-&gt;count() + right-&gt;count() &lt;= kNodeSlots) {</span></div>
<div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160;<span class="stringliteral">      merge_nodes(iter-&gt;node_, right);</span></div>
<div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160;<span class="stringliteral">      return true;</span></div>
<div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;<span class="stringliteral">    // Try rebalancing with our right sibling. We don&#39;t perform rebalancing if</span></div>
<div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;<span class="stringliteral">    // we deleted the first element from iter-&gt;node_ and the node is not</span></div>
<div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;<span class="stringliteral">    // empty. This is a small optimization for the common pattern of deleting</span></div>
<div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;<span class="stringliteral">    // from the front of the tree.</span></div>
<div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;<span class="stringliteral">    if (right-&gt;count() &gt; kMinNodeValues &amp;&amp;</span></div>
<div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;<span class="stringliteral">        (iter-&gt;node_-&gt;count() == 0 || iter-&gt;position_ &gt; iter-&gt;node_-&gt;start())) {</span></div>
<div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;<span class="stringliteral">      field_type to_move = (right-&gt;count() - iter-&gt;node_-&gt;count()) / 2;</span></div>
<div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;<span class="stringliteral">      to_move =</span></div>
<div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;<span class="stringliteral">          (std::min)(to_move, static_cast&lt;field_type&gt;(right-&gt;count() - 1));</span></div>
<div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;<span class="stringliteral">      iter-&gt;node_-&gt;rebalance_right_to_left(to_move, right, mutable_allocator());</span></div>
<div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;<span class="stringliteral">      return false;</span></div>
<div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;<span class="stringliteral">  if (iter-&gt;node_-&gt;position() &gt; parent-&gt;start()) {</span></div>
<div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;<span class="stringliteral">    // Try rebalancing with our left sibling. We don&#39;t perform rebalancing if</span></div>
<div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;<span class="stringliteral">    // we deleted the last element from iter-&gt;node_ and the node is not</span></div>
<div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;<span class="stringliteral">    // empty. This is a small optimization for the common pattern of deleting</span></div>
<div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;<span class="stringliteral">    // from the back of the tree.</span></div>
<div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;<span class="stringliteral">    node_type *left = parent-&gt;child(iter-&gt;node_-&gt;position() - 1);</span></div>
<div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;<span class="stringliteral">    if (left-&gt;count() &gt; kMinNodeValues &amp;&amp;</span></div>
<div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;<span class="stringliteral">        (iter-&gt;node_-&gt;count() == 0 ||</span></div>
<div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;<span class="stringliteral">         iter-&gt;position_ &lt; iter-&gt;node_-&gt;finish())) {</span></div>
<div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;<span class="stringliteral">      field_type to_move = (left-&gt;count() - iter-&gt;node_-&gt;count()) / 2;</span></div>
<div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;<span class="stringliteral">      to_move = (std::min)(to_move, static_cast&lt;field_type&gt;(left-&gt;count() - 1));</span></div>
<div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;<span class="stringliteral">      left-&gt;rebalance_left_to_right(to_move, iter-&gt;node_, mutable_allocator());</span></div>
<div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;<span class="stringliteral">      iter-&gt;position_ += to_move;</span></div>
<div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;<span class="stringliteral">      return false;</span></div>
<div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;<span class="stringliteral">  return false;</span></div>
<div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;<span class="stringliteral">void btree&lt;P&gt;::try_shrink() {</span></div>
<div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;<span class="stringliteral">  node_type *orig_root = root();</span></div>
<div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;<span class="stringliteral">  if (orig_root-&gt;count() &gt; 0) {</span></div>
<div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;<span class="stringliteral">    return;</span></div>
<div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;<span class="stringliteral">  // Deleted the last item on the root node, shrink the height of the tree.</span></div>
<div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;<span class="stringliteral">  if (orig_root-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;<span class="stringliteral">    assert(size() == 0);</span></div>
<div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;<span class="stringliteral">    mutable_root() = mutable_rightmost() = EmptyNode();</span></div>
<div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;<span class="stringliteral">    node_type *child = orig_root-&gt;start_child();</span></div>
<div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160;<span class="stringliteral">    child-&gt;make_root();</span></div>
<div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;<span class="stringliteral">    mutable_root() = child;</span></div>
<div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;<span class="stringliteral">  node_type::clear_and_delete(orig_root, mutable_allocator());</span></div>
<div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;<span class="stringliteral">template &lt;typename IterType&gt;</span></div>
<div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;<span class="stringliteral">inline IterType btree&lt;P&gt;::internal_last(IterType iter) {</span></div>
<div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;<span class="stringliteral">  assert(iter.node_ != nullptr);</span></div>
<div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;<span class="stringliteral">  while (iter.position_ == iter.node_-&gt;finish()) {</span></div>
<div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;<span class="stringliteral">    iter.position_ = iter.node_-&gt;position();</span></div>
<div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;<span class="stringliteral">    iter.node_ = iter.node_-&gt;parent();</span></div>
<div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;<span class="stringliteral">    if (iter.node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;<span class="stringliteral">      iter.node_ = nullptr;</span></div>
<div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;<span class="stringliteral">  iter.update_generation();</span></div>
<div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;<span class="stringliteral">  return iter;</span></div>
<div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;<span class="stringliteral">template &lt;typename... Args&gt;</span></div>
<div class="line"><a name="l02785"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a36f1715cd227fec82f700679e46f961b"> 2785</a></span>&#160;<span class="stringliteral">inline auto btree&lt;P&gt;::internal_emplace(iterator iter, Args &amp;&amp;...args)</span></div>
<div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;<span class="stringliteral">    -&gt; iterator {</span></div>
<div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;<span class="stringliteral">  if (iter.node_-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;<span class="stringliteral">    // We can&#39;t insert on an internal node. Instead, we&#39;ll insert after the</span></div>
<div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;<span class="stringliteral">    // previous value which is guaranteed to be on a leaf node.</span></div>
<div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;<span class="stringliteral">    --iter;</span></div>
<div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;<span class="stringliteral">    ++iter.position_;</span></div>
<div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;<span class="stringliteral">  const field_type max_count = iter.node_-&gt;max_count();</span></div>
<div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;<span class="stringliteral">  allocator_type *alloc = mutable_allocator();</span></div>
<div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;<span class="stringliteral">  if (iter.node_-&gt;count() == max_count) {</span></div>
<div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;<span class="stringliteral">    // Make room in the leaf for the new item.</span></div>
<div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;<span class="stringliteral">    if (max_count &lt; kNodeSlots) {</span></div>
<div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;<span class="stringliteral">      // Insertion into the root where the root is smaller than the full node</span></div>
<div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;<span class="stringliteral">      // size. Simply grow the size of the root node.</span></div>
<div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;<span class="stringliteral">      assert(iter.node_ == root());</span></div>
<div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;<span class="stringliteral">      iter.node_ = new_leaf_root_node(static_cast&lt;field_type&gt;(</span></div>
<div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;<span class="stringliteral">          (std::min)(static_cast&lt;int&gt;(kNodeSlots), 2 * max_count)));</span></div>
<div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;<span class="stringliteral">      // Transfer the values from the old root to the new root.</span></div>
<div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;<span class="stringliteral">      node_type *old_root = root();</span></div>
<div class="line"><a name="l02805"></a><span class="lineno"> 2805</span>&#160;<span class="stringliteral">      node_type *new_root = iter.node_;</span></div>
<div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;<span class="stringliteral">      new_root-&gt;transfer_n(old_root-&gt;count(), new_root-&gt;start(),</span></div>
<div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160;<span class="stringliteral">                           old_root-&gt;start(), old_root, alloc);</span></div>
<div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;<span class="stringliteral">      new_root-&gt;set_finish(old_root-&gt;finish());</span></div>
<div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;<span class="stringliteral">      old_root-&gt;set_finish(old_root-&gt;start());</span></div>
<div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;<span class="stringliteral">      new_root-&gt;set_generation(old_root-&gt;generation());</span></div>
<div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160;<span class="stringliteral">      node_type::clear_and_delete(old_root, alloc);</span></div>
<div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;<span class="stringliteral">      mutable_root() = mutable_rightmost() = new_root;</span></div>
<div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;<span class="stringliteral">    } else {</span></div>
<div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;<span class="stringliteral">      rebalance_or_split(&amp;iter);</span></div>
<div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;<span class="stringliteral">  iter.node_-&gt;emplace_value(static_cast&lt;field_type&gt;(iter.position_), alloc,</span></div>
<div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;<span class="stringliteral">                            std::forward&lt;Args&gt;(args)...);</span></div>
<div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;<span class="stringliteral">  ++size_;</span></div>
<div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160;<span class="stringliteral">  iter.update_generation();</span></div>
<div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160;<span class="stringliteral">  return iter;</span></div>
<div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;<span class="stringliteral">template &lt;typename K&gt;</span></div>
<div class="line"><a name="l02826"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a208a3251414428bf8b26b6b6822e9217"> 2826</a></span>&#160;<span class="stringliteral">inline auto btree&lt;P&gt;::internal_locate(const K &amp;key) const</span></div>
<div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;<span class="stringliteral">    -&gt; SearchResult&lt;iterator, is_key_compare_to::value&gt; {</span></div>
<div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;<span class="stringliteral">  iterator iter(const_cast&lt;node_type *&gt;(root()));</span></div>
<div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;<span class="stringliteral">  for (;;) {</span></div>
<div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;<span class="stringliteral">    SearchResult&lt;size_type, is_key_compare_to::value&gt; res =</span></div>
<div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;<span class="stringliteral">        iter.node_-&gt;lower_bound(key, key_comp());</span></div>
<div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;<span class="stringliteral">    iter.position_ = static_cast&lt;int&gt;(res.value);</span></div>
<div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;<span class="stringliteral">    if (res.IsEq()) {</span></div>
<div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;<span class="stringliteral">      return {iter, MatchKind::kEq};</span></div>
<div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;<span class="stringliteral">    // Note: in the non-key-compare-to case, we don&#39;t need to walk all the way</span></div>
<div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;<span class="stringliteral">    // down the tree if the keys are equal, but determining equality would</span></div>
<div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;<span class="stringliteral">    // require doing an extra comparison on each node on the way down, and we</span></div>
<div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;<span class="stringliteral">    // will need to go all the way to the leaf node in the expected case.</span></div>
<div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;<span class="stringliteral">    if (iter.node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;<span class="stringliteral">    iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));</span></div>
<div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;<span class="stringliteral">  // Note: in the non-key-compare-to case, the key may actually be equivalent</span></div>
<div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;<span class="stringliteral">  // here (and the MatchKind::kNe is ignored).</span></div>
<div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;<span class="stringliteral">  return {iter, MatchKind::kNe};</span></div>
<div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;<span class="stringliteral">template &lt;typename K&gt;</span></div>
<div class="line"><a name="l02852"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a5f4173884d906473eaf528c02fb0b09c"> 2852</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::internal_lower_bound(const K &amp;key) const</span></div>
<div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;<span class="stringliteral">    -&gt; SearchResult&lt;iterator, is_key_compare_to::value&gt; {</span></div>
<div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;<span class="stringliteral">  if (!params_type::template can_have_multiple_equivalent_keys&lt;K&gt;()) {</span></div>
<div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;<span class="stringliteral">    SearchResult&lt;iterator, is_key_compare_to::value&gt; ret = internal_locate(key);</span></div>
<div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;<span class="stringliteral">    ret.value = internal_last(ret.value);</span></div>
<div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;<span class="stringliteral">    return ret;</span></div>
<div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;<span class="stringliteral">  iterator iter(const_cast&lt;node_type *&gt;(root()));</span></div>
<div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;<span class="stringliteral">  SearchResult&lt;size_type, is_key_compare_to::value&gt; res;</span></div>
<div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;<span class="stringliteral">  bool seen_eq = false;</span></div>
<div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;<span class="stringliteral">  for (;;) {</span></div>
<div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;<span class="stringliteral">    res = iter.node_-&gt;lower_bound(key, key_comp());</span></div>
<div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;<span class="stringliteral">    iter.position_ = static_cast&lt;int&gt;(res.value);</span></div>
<div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;<span class="stringliteral">    if (iter.node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;<span class="stringliteral">    seen_eq = seen_eq || res.IsEq();</span></div>
<div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;<span class="stringliteral">    iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));</span></div>
<div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;<span class="stringliteral">  if (res.IsEq()) return {iter, MatchKind::kEq};</span></div>
<div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;<span class="stringliteral">  return {internal_last(iter), seen_eq ? MatchKind::kEq : MatchKind::kNe};</span></div>
<div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;<span class="stringliteral">template &lt;typename K&gt;</span></div>
<div class="line"><a name="l02877"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#a09a4b98e151b85d017b8f7d8cce5d4db"> 2877</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::internal_upper_bound(const K &amp;key) const -&gt; iterator {</span></div>
<div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;<span class="stringliteral">  iterator iter(const_cast&lt;node_type *&gt;(root()));</span></div>
<div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;<span class="stringliteral">  for (;;) {</span></div>
<div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;<span class="stringliteral">    iter.position_ = static_cast&lt;int&gt;(iter.node_-&gt;upper_bound(key, key_comp()));</span></div>
<div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;<span class="stringliteral">    if (iter.node_-&gt;is_leaf()) {</span></div>
<div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;<span class="stringliteral">      break;</span></div>
<div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;<span class="stringliteral">    iter.node_ = iter.node_-&gt;child(static_cast&lt;field_type&gt;(iter.position_));</span></div>
<div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;<span class="stringliteral">  return internal_last(iter);</span></div>
<div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160;<span class="stringliteral">template &lt;typename K&gt;</span></div>
<div class="line"><a name="l02891"></a><span class="lineno"><a class="line" href="classabsl_1_1container__internal_1_1btree.html#ad0191bd1665c280524af0b70e5a798ea"> 2891</a></span>&#160;<span class="stringliteral">auto btree&lt;P&gt;::internal_find(const K &amp;key) const -&gt; iterator {</span></div>
<div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;<span class="stringliteral">  SearchResult&lt;iterator, is_key_compare_to::value&gt; res = internal_locate(key);</span></div>
<div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;<span class="stringliteral">  if (res.HasMatch()) {</span></div>
<div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;<span class="stringliteral">    if (res.IsEq()) {</span></div>
<div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;<span class="stringliteral">      return res.value;</span></div>
<div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;<span class="stringliteral">  } else {</span></div>
<div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;<span class="stringliteral">    const iterator iter = internal_last(res.value);</span></div>
<div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;<span class="stringliteral">    if (iter.node_ != nullptr &amp;&amp; !compare_keys(key, iter.key())) {</span></div>
<div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;<span class="stringliteral">      return iter;</span></div>
<div class="line"><a name="l02901"></a><span class="lineno"> 2901</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;<span class="stringliteral">  return {nullptr, 0};</span></div>
<div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;<span class="stringliteral">template &lt;typename P&gt;</span></div>
<div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;<span class="stringliteral">typename btree&lt;P&gt;::size_type btree&lt;P&gt;::internal_verify(</span></div>
<div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;<span class="stringliteral">    const node_type *node, const key_type *lo, const key_type *hi) const {</span></div>
<div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160;<span class="stringliteral">  assert(node-&gt;count() &gt; 0);</span></div>
<div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;<span class="stringliteral">  assert(node-&gt;count() &lt;= node-&gt;max_count());</span></div>
<div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;<span class="stringliteral">  if (lo) {</span></div>
<div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;<span class="stringliteral">    assert(!compare_keys(node-&gt;key(node-&gt;start()), *lo));</span></div>
<div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;<span class="stringliteral">  if (hi) {</span></div>
<div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;<span class="stringliteral">    assert(!compare_keys(*hi, node-&gt;key(node-&gt;finish() - 1)));</span></div>
<div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;<span class="stringliteral">  for (int i = node-&gt;start() + 1; i &lt; node-&gt;finish(); ++i) {</span></div>
<div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;<span class="stringliteral">    assert(!compare_keys(node-&gt;key(i), node-&gt;key(i - 1)));</span></div>
<div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;<span class="stringliteral">  size_type count = node-&gt;count();</span></div>
<div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;<span class="stringliteral">  if (node-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;<span class="stringliteral">    for (field_type i = node-&gt;start(); i &lt;= node-&gt;finish(); ++i) {</span></div>
<div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160;<span class="stringliteral">      assert(node-&gt;child(i) != nullptr);</span></div>
<div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;<span class="stringliteral">      assert(node-&gt;child(i)-&gt;parent() == node);</span></div>
<div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;<span class="stringliteral">      assert(node-&gt;child(i)-&gt;position() == i);</span></div>
<div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;<span class="stringliteral">      count += internal_verify(node-&gt;child(i),</span></div>
<div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160;<span class="stringliteral">                               i == node-&gt;start() ? lo : &amp;node-&gt;key(i - 1),</span></div>
<div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;<span class="stringliteral">                               i == node-&gt;finish() ? hi : &amp;node-&gt;key(i));</span></div>
<div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160;<span class="stringliteral">  return count;</span></div>
<div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02934"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1btree__access.html"> 2934</a></span>&#160;<span class="stringliteral">struct btree_access {</span></div>
<div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;<span class="stringliteral">  template &lt;typename BtreeContainer, typename Pred&gt;</span></div>
<div class="line"><a name="l02936"></a><span class="lineno"><a class="line" href="structabsl_1_1container__internal_1_1btree__access.html#a8e16146a3f2ab2ba43ddd4e3c973a2b0"> 2936</a></span>&#160;<span class="stringliteral">  static auto erase_if(BtreeContainer &amp;container, Pred pred) -&gt;</span></div>
<div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160;<span class="stringliteral">      typename BtreeContainer::size_type {</span></div>
<div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;<span class="stringliteral">    const auto initial_size = container.size();</span></div>
<div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160;<span class="stringliteral">    auto &amp;tree = container.tree_;</span></div>
<div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;<span class="stringliteral">    auto *alloc = tree.mutable_allocator();</span></div>
<div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;<span class="stringliteral">    for (auto it = container.begin(); it != container.end();) {</span></div>
<div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;<span class="stringliteral">      if (!pred(*it)) {</span></div>
<div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;<span class="stringliteral">        ++it;</span></div>
<div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;<span class="stringliteral">        continue;</span></div>
<div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;<span class="stringliteral">      auto *node = it.node_;</span></div>
<div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;<span class="stringliteral">      if (node-&gt;is_internal()) {</span></div>
<div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;<span class="stringliteral">        // Handle internal nodes normally.</span></div>
<div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;<span class="stringliteral">        it = container.erase(it);</span></div>
<div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;<span class="stringliteral">        continue;</span></div>
<div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;<span class="stringliteral">      // If this is a leaf node, then we do all the erases from this node</span></div>
<div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;<span class="stringliteral">      // at once before doing rebalancing.</span></div>
<div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;<span class="stringliteral">      // The current position to transfer slots to.</span></div>
<div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;<span class="stringliteral">      int to_pos = it.position_;</span></div>
<div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;<span class="stringliteral">      node-&gt;value_destroy(it.position_, alloc);</span></div>
<div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;<span class="stringliteral">      while (++it.position_ &lt; node-&gt;finish()) {</span></div>
<div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;<span class="stringliteral">        it.update_generation();</span></div>
<div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;<span class="stringliteral">        if (pred(*it)) {</span></div>
<div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;<span class="stringliteral">          node-&gt;value_destroy(it.position_, alloc);</span></div>
<div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;<span class="stringliteral">        } else {</span></div>
<div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;<span class="stringliteral">          node-&gt;transfer(node-&gt;slot(to_pos++), node-&gt;slot(it.position_), alloc);</span></div>
<div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;<span class="stringliteral">      }</span></div>
<div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;<span class="stringliteral">      const int num_deleted = node-&gt;finish() - to_pos;</span></div>
<div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;<span class="stringliteral">      tree.size_ -= num_deleted;</span></div>
<div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;<span class="stringliteral">      node-&gt;set_finish(to_pos);</span></div>
<div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;<span class="stringliteral">      it.position_ = to_pos;</span></div>
<div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;<span class="stringliteral">      it = tree.rebalance_after_delete(it);</span></div>
<div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;<span class="stringliteral">    }</span></div>
<div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;<span class="stringliteral">    return initial_size - container.size();</span></div>
<div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;<span class="stringliteral">#undef ABSL_BTREE_ENABLE_GENERATIONS</span></div>
<div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;<span class="stringliteral">}  // namespace container_internal</span></div>
<div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;<span class="stringliteral">ABSL_NAMESPACE_END</span></div>
<div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;<span class="stringliteral">}  // namespace absl</span></div>
<div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;<span class="stringliteral">#endif  // ABSL_CONTAINER_INTERNAL_BTREE_H_</span></div>
<div class="ttc" id="aabseil-cpp_2absl_2memory_2memory_8h_html"><div class="ttname"><a href="abseil-cpp_2absl_2memory_2memory_8h.html">memory.h</a></div></div>
<div class="ttc" id="aabseil-cpp_2absl_2types_2compare_8h_html"><div class="ttname"><a href="abseil-cpp_2absl_2types_2compare_8h.html">compare.h</a></div></div>
<div class="ttc" id="abase_2config_8h_html_a1426209ed359f780778edc8975b23f07"><div class="ttname"><a href="base_2config_8h.html#a1426209ed359f780778edc8975b23f07">ABSL_NAMESPACE_BEGIN</a></div><div class="ttdeci">#define ABSL_NAMESPACE_BEGIN</div><div class="ttdef"><b>Definition:</b> <a href="base_2config_8h_source.html#l00170">config.h:170</a></div></div>
<div class="ttc" id="abtree__test_8cc_html_a35af0be900467fedbb610bd6ea65ed78"><div class="ttname"><a href="btree__test_8cc.html#a35af0be900467fedbb610bd6ea65ed78">key</a></div><div class="ttdeci">int key</div><div class="ttdef"><b>Definition:</b> <a href="btree__test_8cc_source.html#l02202">btree_test.cc:2202</a></div></div>
<div class="ttc" id="aclassabsl_1_1_cord_html"><div class="ttname"><a href="classabsl_1_1_cord.html">absl::Cord</a></div><div class="ttdef"><b>Definition:</b> <a href="cord_8h_source.html#l00150">cord.h:150</a></div></div>
<div class="ttc" id="aclassabsl_1_1_cord_html_a51c340abb52e9c9aff0a434752fc085c"><div class="ttname"><a href="classabsl_1_1_cord.html#a51c340abb52e9c9aff0a434752fc085c">absl::Cord::Compare</a></div><div class="ttdeci">int Compare(absl::string_view rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="cord_8cc_source.html#l01011">cord.cc:1011</a></div></div>
<div class="ttc" id="aclassabsl_1_1container__internal_1_1btree__iterator_html"><div class="ttname"><a href="classabsl_1_1container__internal_1_1btree__iterator.html">absl::container_internal::btree_iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l01074">btree.h:1074</a></div></div>
<div class="ttc" id="aclassabsl_1_1string__view_html"><div class="ttname"><a href="classabsl_1_1string__view.html">absl::string_view</a></div><div class="ttdef"><b>Definition:</b> <a href="string__view_8h_source.html#l00161">string_view.h:161</a></div></div>
<div class="ttc" id="aclassabsl_1_1string__view_html_afdca90e80a4ea2e2d63133074fe4229e"><div class="ttname"><a href="classabsl_1_1string__view.html#afdca90e80a4ea2e2d63133074fe4229e">absl::string_view::compare</a></div><div class="ttdeci">constexpr int compare(string_view x) const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="string__view_8h_source.html#l00407">string_view.h:407</a></div></div>
<div class="ttc" id="aclassabsl_1_1weak__ordering_html"><div class="ttname"><a href="classabsl_1_1weak__ordering.html">absl::weak_ordering</a></div><div class="ttdef"><b>Definition:</b> <a href="abseil-cpp_2absl_2types_2compare_8h_source.html#l00347">compare.h:348</a></div></div>
<div class="ttc" id="acommon_8h_html"><div class="ttname"><a href="common_8h.html">common.h</a></div></div>
<div class="ttc" id="acommon__policy__traits_8h_html"><div class="ttname"><a href="common__policy__traits_8h.html">common_policy_traits.h</a></div></div>
<div class="ttc" id="acompressed__tuple_8h_html"><div class="ttname"><a href="compressed__tuple_8h.html">compressed_tuple.h</a></div></div>
<div class="ttc" id="acontainer__memory_8h_html"><div class="ttname"><a href="container__memory_8h.html">container_memory.h</a></div></div>
<div class="ttc" id="acord_8h_html"><div class="ttname"><a href="cord_8h.html">cord.h</a></div></div>
<div class="ttc" id="aflat__hash__map__test_8cc_html_a54c2bae0f8aeed048a397b0618037252"><div class="ttname"><a href="flat__hash__map__test_8cc.html#a54c2bae0f8aeed048a397b0618037252">value</a></div><div class="ttdeci">size_t value</div><div class="ttdef"><b>Definition:</b> <a href="flat__hash__map__test_8cc_source.html#l00134">flat_hash_map_test.cc:134</a></div></div>
<div class="ttc" id="afloat__conversion_8cc_html_a8fd806ad19b8f5513a4cf18cbf77532c"><div class="ttname"><a href="float__conversion_8cc.html#a8fd806ad19b8f5513a4cf18cbf77532c">end</a></div><div class="ttdeci">char * end</div><div class="ttdef"><b>Definition:</b> <a href="float__conversion_8cc_source.html#l01029">float_conversion.cc:1029</a></div></div>
<div class="ttc" id="alayout_8h_html"><div class="ttname"><a href="layout_8h.html">layout.h</a></div></div>
<div class="ttc" id="alayout__test_8cc_html_a633ab603a49d0a046734a0f3e6de45e9"><div class="ttname"><a href="layout__test_8cc.html#a633ab603a49d0a046734a0f3e6de45e9">to</a></div><div class="ttdeci">size_t to</div><div class="ttdef"><b>Definition:</b> <a href="layout__test_8cc_source.html#l01385">layout_test.cc:1385</a></div></div>
<div class="ttc" id="alayout__test_8cc_html_a66a6152caa0d2dec6985ed86838ba876"><div class="ttname"><a href="layout__test_8cc.html#a66a6152caa0d2dec6985ed86838ba876">from</a></div><div class="ttdeci">size_t from</div><div class="ttdef"><b>Definition:</b> <a href="layout__test_8cc_source.html#l01384">layout_test.cc:1384</a></div></div>
<div class="ttc" id="alayout__test_8cc_html_ad66453096871179e6c6effe0df4b483b"><div class="ttname"><a href="layout__test_8cc.html#ad66453096871179e6c6effe0df4b483b">b</a></div><div class="ttdeci">uint64_t b</div><div class="ttdef"><b>Definition:</b> <a href="layout__test_8cc_source.html#l00053">layout_test.cc:53</a></div></div>
<div class="ttc" id="alow__level__alloc_8cc_html_aad9b71a31372d5c0ab9c23163efe9544"><div class="ttname"><a href="low__level__alloc_8cc.html#aad9b71a31372d5c0ab9c23163efe9544">size</a></div><div class="ttdeci">uintptr_t size</div><div class="ttdef"><b>Definition:</b> <a href="low__level__alloc_8cc_source.html#l00080">low_level_alloc.cc:80</a></div></div>
<div class="ttc" id="amacros_8h_html"><div class="ttname"><a href="macros_8h.html">macros.h</a></div></div>
<div class="ttc" id="anamespaceabsl_1_1compare__internal_html_aee1e4e00fec9f4fe853f74c0fa251b41"><div class="ttname"><a href="namespaceabsl_1_1compare__internal.html#aee1e4e00fec9f4fe853f74c0fa251b41">absl::compare_internal::compare_result_as_ordering</a></div><div class="ttdeci">constexpr absl::weak_ordering compare_result_as_ordering(const Int c)</div><div class="ttdef"><b>Definition:</b> <a href="abseil-cpp_2absl_2types_2compare_8h_source.html#l00565">compare.h:565</a></div></div>
<div class="ttc" id="anamespaceabsl_1_1container__internal_html_a8b4e048c216bebee3486e4ebeaf57963"><div class="ttname"><a href="namespaceabsl_1_1container__internal.html#a8b4e048c216bebee3486e4ebeaf57963">absl::container_internal::btree_is_key_compare_to</a></div><div class="ttdeci">std::is_convertible&lt; compare_result_t&lt; Compare, T, T &gt;, absl::weak_ordering &gt; btree_is_key_compare_to</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00095">btree.h:96</a></div></div>
<div class="ttc" id="anamespaceabsl_1_1container__internal_html_a9cb1e35ef64969fb752e7b217bd18d14"><div class="ttname"><a href="namespaceabsl_1_1container__internal.html#a9cb1e35ef64969fb752e7b217bd18d14">absl::container_internal::compare_result_t</a></div><div class="ttdeci">absl::result_of_t&lt; const Compare(const T &amp;, const U &amp;)&gt; compare_result_t</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00090">btree.h:90</a></div></div>
<div class="ttc" id="anamespaceabsl_1_1strings__internal_html_aa6b970afaf13c99c2355c58dd26664e2"><div class="ttname"><a href="namespaceabsl_1_1strings__internal.html#aa6b970afaf13c99c2355c58dd26664e2">absl::strings_internal::Compare</a></div><div class="ttdeci">int Compare(const BigUnsigned&lt; N &gt; &amp;lhs, const BigUnsigned&lt; M &gt; &amp;rhs)</div><div class="ttdef"><b>Definition:</b> <a href="charconv__bigint_8h_source.html#l00353">charconv_bigint.h:353</a></div></div>
<div class="ttc" id="anamespaceabsl_html"><div class="ttname"><a href="namespaceabsl.html">absl</a></div><div class="ttdef"><b>Definition:</b> <a href="algorithm_8h_source.html#l00031">algorithm.h:31</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a2b450b606cc6db74111d91871e5242e8"><div class="ttname"><a href="namespaceabsl.html#a2b450b606cc6db74111d91871e5242e8">absl::equal</a></div><div class="ttdeci">bool equal(InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2, Pred &amp;&amp;pred)</div><div class="ttdef"><b>Definition:</b> <a href="algorithm_8h_source.html#l00104">algorithm.h:104</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a3b0d790d5d90487eb74e72e46bd68d60"><div class="ttname"><a href="namespaceabsl.html#a3b0d790d5d90487eb74e72e46bd68d60">absl::enable_if_t</a></div><div class="ttdeci">typename std::enable_if&lt; B, T &gt;::type enable_if_t</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8h_source.html#l00656">type_traits.h:656</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33"><div class="ttname"><a href="namespaceabsl.html#a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33">absl::FormatConversionChar::c</a></div><div class="ttdeci">@ c</div></div>
<div class="ttc" id="anamespaceabsl_html_a8a7cf6a75e931e10ad158e992dc456d4"><div class="ttname"><a href="namespaceabsl.html#a8a7cf6a75e931e10ad158e992dc456d4">absl::result_of_t</a></div><div class="ttdeci">typename type_traits_internal::result_of&lt; F &gt;::type result_of_t</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8h_source.html#l00683">type_traits.h:683</a></div></div>
<div class="ttc" id="anamespaceabsl_html_ab937fb37eb7d60210fe910bd43ab2654"><div class="ttname"><a href="namespaceabsl.html#ab937fb37eb7d60210fe910bd43ab2654">absl::move</a></div><div class="ttdeci">constexpr absl::remove_reference_t&lt; T &gt; &amp;&amp; move(T &amp;&amp;t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="utility_8h_source.html#l00221">utility.h:221</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="hash__function__defaults__test_8cc_source.html#l00355">hash_function_defaults_test.cc:355</a></div></div>
<div class="ttc" id="araw__logging_8h_html"><div class="ttname"><a href="raw__logging_8h.html">raw_logging.h</a></div></div>
<div class="ttc" id="astring__view_8h_html"><div class="ttname"><a href="string__view_8h.html">string_view.h</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_btree_test_only_checked_compare_opt_out_base_html"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_btree_test_only_checked_compare_opt_out_base.html">absl::container_internal::BtreeTestOnlyCheckedCompareOptOutBase</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00178">btree.h:178</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html">absl::container_internal::StringBtreeDefaultGreater</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00131">btree.h:131</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_a084fd6e71b16f03048928525847751b7"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a084fd6e71b16f03048928525847751b7">absl::container_internal::StringBtreeDefaultGreater::StringBtreeDefaultGreater</a></div><div class="ttdeci">StringBtreeDefaultGreater(std::greater&lt; absl::string_view &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00137">btree.h:137</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_a203e48d49598f1c6b7197c66fbbba422"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a203e48d49598f1c6b7197c66fbbba422">absl::container_internal::StringBtreeDefaultGreater::StringBtreeDefaultGreater</a></div><div class="ttdeci">StringBtreeDefaultGreater()=default</div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_a282010671103d613245764424d23f9c0"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a282010671103d613245764424d23f9c0">absl::container_internal::StringBtreeDefaultGreater::StringBtreeDefaultGreater</a></div><div class="ttdeci">StringBtreeDefaultGreater(std::greater&lt; std::string &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00136">btree.h:136</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_a3f4a3aa5c92ba4806dd66376bfc58a2c"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a3f4a3aa5c92ba4806dd66376bfc58a2c">absl::container_internal::StringBtreeDefaultGreater::is_transparent</a></div><div class="ttdeci">void is_transparent</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00132">btree.h:132</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_a53aaa856bc754e43594e5f21d2ed7525"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#a53aaa856bc754e43594e5f21d2ed7525">absl::container_internal::StringBtreeDefaultGreater::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(const absl::Cord &amp;lhs, const absl::Cord &amp;rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00149">btree.h:149</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_ab3a056b507c8e44f0e02fd85a1d26d9f"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab3a056b507c8e44f0e02fd85a1d26d9f">absl::container_internal::StringBtreeDefaultGreater::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(absl::string_view lhs, const absl::Cord &amp;rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00157">btree.h:157</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_ab433e38ac862e40a7670a74a7de41b0b"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#ab433e38ac862e40a7670a74a7de41b0b">absl::container_internal::StringBtreeDefaultGreater::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(const absl::Cord &amp;lhs, absl::string_view rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00153">btree.h:153</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_aba96a4cedf9b21e7322f489eb64cd9ba"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#aba96a4cedf9b21e7322f489eb64cd9ba">absl::container_internal::StringBtreeDefaultGreater::StringBtreeDefaultGreater</a></div><div class="ttdeci">StringBtreeDefaultGreater(std::greater&lt; absl::Cord &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00148">btree.h:148</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_greater_html_abbb9e493da91367e2f43c8d14edcb47b"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_greater.html#abbb9e493da91367e2f43c8d14edcb47b">absl::container_internal::StringBtreeDefaultGreater::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(absl::string_view lhs, absl::string_view rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00144">btree.h:144</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html">absl::container_internal::StringBtreeDefaultLess</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00098">btree.h:98</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a05012294e4d2041151b2634197cdbb3d"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a05012294e4d2041151b2634197cdbb3d">absl::container_internal::StringBtreeDefaultLess::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(const absl::Cord &amp;lhs, absl::string_view rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00121">btree.h:121</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a2f39528be4d68fc163e8133dc6bf0662"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a2f39528be4d68fc163e8133dc6bf0662">absl::container_internal::StringBtreeDefaultLess::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(const absl::Cord &amp;lhs, const absl::Cord &amp;rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00117">btree.h:117</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a34904a408b028a178c2469850f12b5c4"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a34904a408b028a178c2469850f12b5c4">absl::container_internal::StringBtreeDefaultLess::StringBtreeDefaultLess</a></div><div class="ttdeci">StringBtreeDefaultLess(std::less&lt; absl::string_view &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00105">btree.h:105</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a4ec55d10d838f23ca050618aeb4c4541"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a4ec55d10d838f23ca050618aeb4c4541">absl::container_internal::StringBtreeDefaultLess::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(absl::string_view lhs, absl::string_view rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00112">btree.h:112</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a5261735ce35ae50de8034075088cf407"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a5261735ce35ae50de8034075088cf407">absl::container_internal::StringBtreeDefaultLess::StringBtreeDefaultLess</a></div><div class="ttdeci">StringBtreeDefaultLess(std::less&lt; std::string &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00104">btree.h:104</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a58a4e176dda17f66cce24e3c30a3fb67"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a58a4e176dda17f66cce24e3c30a3fb67">absl::container_internal::StringBtreeDefaultLess::StringBtreeDefaultLess</a></div><div class="ttdeci">StringBtreeDefaultLess()=default</div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a825ee59e2e36b12ca5333ecf997f77ae"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a825ee59e2e36b12ca5333ecf997f77ae">absl::container_internal::StringBtreeDefaultLess::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(absl::string_view lhs, const absl::Cord &amp;rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00125">btree.h:125</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_a8bb6af879940fa761fa34b6665cd762c"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#a8bb6af879940fa761fa34b6665cd762c">absl::container_internal::StringBtreeDefaultLess::StringBtreeDefaultLess</a></div><div class="ttdeci">StringBtreeDefaultLess(std::less&lt; absl::Cord &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00116">btree.h:116</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1_string_btree_default_less_html_aa057a8e8688e7ccba9c9240dcfc31d13"><div class="ttname"><a href="structabsl_1_1container__internal_1_1_string_btree_default_less.html#aa057a8e8688e7ccba9c9240dcfc31d13">absl::container_internal::StringBtreeDefaultLess::is_transparent</a></div><div class="ttdeci">void is_transparent</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00099">btree.h:99</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4_html_a15b8cb22c39bc02c124f3fa7ff746690"><div class="ttname"><a href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#a15b8cb22c39bc02c124f3fa7ff746690">absl::container_internal::checked_compare_base&lt; Compare, false &gt;::checked_compare_base</a></div><div class="ttdeci">checked_compare_base(Compare c)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00172">btree.h:172</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4_html_a8355ec766d4613008f9ba02efb010628"><div class="ttname"><a href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#a8355ec766d4613008f9ba02efb010628">absl::container_internal::checked_compare_base&lt; Compare, false &gt;::comp</a></div><div class="ttdeci">const Compare &amp; comp() const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00173">btree.h:173</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4_html_aa8c8c1187d0a8e432ec115712256ae7e"><div class="ttname"><a href="structabsl_1_1container__internal_1_1checked__compare__base_3_01_compare_00_01false_01_4.html#aa8c8c1187d0a8e432ec115712256ae7e">absl::container_internal::checked_compare_base&lt; Compare, false &gt;::compare</a></div><div class="ttdeci">Compare compare</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00174">btree.h:174</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1checked__compare__base_html"><div class="ttname"><a href="structabsl_1_1container__internal_1_1checked__compare__base.html">absl::container_internal::checked_compare_base</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00165">btree.h:165</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1checked__compare__base_html_a9eabdf8e1cf5b681c332a5b0c86857a4"><div class="ttname"><a href="structabsl_1_1container__internal_1_1checked__compare__base.html#a9eabdf8e1cf5b681c332a5b0c86857a4">absl::container_internal::checked_compare_base::checked_compare_base</a></div><div class="ttdeci">checked_compare_base(Compare c)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00167">btree.h:167</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1checked__compare__base_html_ac5b05a28154cb99424b49b87a73465a5"><div class="ttname"><a href="structabsl_1_1container__internal_1_1checked__compare__base.html#ac5b05a28154cb99424b49b87a73465a5">absl::container_internal::checked_compare_base::comp</a></div><div class="ttdeci">const Compare &amp; comp() const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00168">btree.h:168</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_html"><div class="ttname"><a href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html">absl::container_internal::key_compare_adapter::checked_compare</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00199">btree.h:199</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_html_a4866980272aeb23431d874ef76e59318"><div class="ttname"><a href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a4866980272aeb23431d874ef76e59318">absl::container_internal::key_compare_adapter::checked_compare::operator()</a></div><div class="ttdeci">bool operator()(const T &amp;lhs, const U &amp;rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00229">btree.h:229</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_html_a856a8a5cd32c909425e9979e08888137"><div class="ttname"><a href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a856a8a5cd32c909425e9979e08888137">absl::container_internal::key_compare_adapter::checked_compare::checked_compare</a></div><div class="ttdeci">checked_compare(Compare comp)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00220">btree.h:220</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_html_a8cc2fad7a99a268788711694c885d36c"><div class="ttname"><a href="structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare.html#a8cc2fad7a99a268788711694c885d36c">absl::container_internal::key_compare_adapter::checked_compare::operator()</a></div><div class="ttdeci">absl::weak_ordering operator()(const T &amp;lhs, const U &amp;rhs) const</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00245">btree.h:245</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1key__compare__adapter_html"><div class="ttname"><a href="structabsl_1_1container__internal_1_1key__compare__adapter.html">absl::container_internal::key_compare_adapter</a></div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00191">btree.h:191</a></div></div>
<div class="ttc" id="astructabsl_1_1container__internal_1_1key__compare__adapter_html_af99ac249bd516219a4922ed17d3d33bf"><div class="ttname"><a href="structabsl_1_1container__internal_1_1key__compare__adapter.html#af99ac249bd516219a4922ed17d3d33bf">absl::container_internal::key_compare_adapter::type</a></div><div class="ttdeci">absl::conditional_t&lt; std::is_base_of&lt; BtreeTestOnlyCheckedCompareOptOutBase, Compare &gt;::value, Compare, checked_compare &gt; type</div><div class="ttdef"><b>Definition:</b> <a href="btree_8h_source.html#l00265">btree.h:267</a></div></div>
<div class="ttc" id="atype__traits_8h_html"><div class="ttname"><a href="type__traits_8h.html">type_traits.h</a></div></div>
<div class="ttc" id="autility_8h_html"><div class="ttname"><a href="utility_8h.html">utility.h</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ee62946d34d9e18774ac39157bda6717.html">open_spiel</a></li><li class="navelem"><a class="el" href="dir_2ebe12dd687c9cb269367ddf4fdfdc98.html">abseil-cpp</a></li><li class="navelem"><a class="el" href="dir_097057be3668f423b801d69a8fe80bd8.html">absl</a></li><li class="navelem"><a class="el" href="dir_8c9485db3889511f15eb622662d67f10.html">container</a></li><li class="navelem"><a class="el" href="dir_eae5b0220ed3338aa9554d480cf8bd2a.html">internal</a></li><li class="navelem"><a class="el" href="btree_8h.html">btree.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
