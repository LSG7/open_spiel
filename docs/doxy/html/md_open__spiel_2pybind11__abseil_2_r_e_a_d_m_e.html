<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>open spiel: Pybind11 bindings for the Abseil C++ Common Libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">open spiel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Pybind11 bindings for the Abseil C++ Common Libraries</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md81">Overview</a></li>
<li class="level1"><a href="#autotoc_md82">Installation</a></li>
<li class="level1"><a href="#autotoc_md83">absl::Duration</a></li>
<li class="level1"><a href="#autotoc_md84">absl::Time</a><ul><li class="level2"><a href="#autotoc_md85">Time zones</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md86">absl::CivilTime</a></li>
<li class="level1"><a href="#autotoc_md87">absl::Span</a><ul><li class="level2"><a href="#autotoc_md88">Loading</a></li>
<li class="level2"><a href="#autotoc_md89">Casting</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md90">absl::string_view</a></li>
<li class="level1"><a href="#autotoc_md91">absl::optional</a></li>
<li class="level1"><a href="#autotoc_md92">absl::flat_hash_map and absl::btree_map</a></li>
<li class="level1"><a href="#autotoc_md93">absl::flat_hash_set</a></li>
<li class="level1"><a href="#autotoc_md94">absl::Status[Or]</a><ul><li class="level2"><a href="#autotoc_md95">absl::StatusOr</a></li>
<li class="level2"><a href="#autotoc_md96">absl::StatusCode</a></li>
<li class="level2"><a href="#autotoc_md97">Aliasing parts of the status module</a></li>
<li class="level2"><a href="#autotoc_md98">Importing the status module</a></li>
<li class="level2"><a href="#autotoc_md99">Use Outside of Google3</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md80"></a> <img src="https://github.com/pybind/pybind11_abseil/workflows/build_and_test/badge.svg" alt="build_and_test" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md81"></a>
Overview</h1>
<p>These adapters make Abseil types work with Pybind11 bindings. For more information on using Pybind11, see g3doc/third_party/pybind11/google3_utils/README.md.</p>
<p>To use the converters listed below, just include the header in the .cc file with your bindings:</p>
<div class="fragment"><div class="line">#include &quot;pybind11_abseil/absl_casters.h&quot;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md82"></a>
Installation</h1>
<p>You will need to depend on <code><a class="el" href="namespacepybind11.html">pybind11</a></code>, <code>pybind11_bazel</code>(see <a href="https://github.com/pybind/pybind11_bazel#installation">doc</a>, and on <code>pybind11_abseil</code>, e.g.</p>
<div class="fragment"><div class="line">git_repository(</div>
<div class="line">    name = &quot;pybind11_bazel&quot;,</div>
<div class="line">    remote = &quot;https://github.com/pybind/pybind11_bazel.git&quot;,</div>
<div class="line">    branch = &quot;master&quot;,</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">http_archive(</div>
<div class="line">  name = &quot;pybind11&quot;,</div>
<div class="line">  build_file = &quot;@pybind11_bazel//:pybind11.BUILD&quot;,</div>
<div class="line">  strip_prefix = &quot;pybind11-2.6.2&quot;,</div>
<div class="line">  sha256 = &quot;8ff2fff22df038f5cd02cea8af56622bc67f5b64534f1b83b9f133b8366acff2&quot;,</div>
<div class="line">  urls = [&quot;https://github.com/pybind/pybind11/archive/v2.6.2.tar.gz&quot;],</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">load(&quot;@pybind11_bazel//:python_configure.bzl&quot;, &quot;python_configure&quot;)</div>
<div class="line">python_configure(name = &quot;local_config_python&quot;)</div>
<div class="line"> </div>
<div class="line">git_repository(</div>
<div class="line">    name = &quot;pybind11_abseil&quot;,</div>
<div class="line">    remote = &quot;https://github.com/pybind/pybind11_abseil.git&quot;,</div>
<div class="line">    branch = &quot;master&quot;,</div>
<div class="line">)</div>
</div><!-- fragment --><p>Then, in your BUILD file:</p>
<div class="fragment"><div class="line">load(&quot;@pybind11_bazel//:build_defs.bzl&quot;, &quot;pybind_extension&quot;)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md83"></a>
absl::Duration</h1>
<p><code><a class="el" href="classabsl_1_1_duration.html">absl::Duration</a></code> objects are converted to/ from python datetime.timedelta objects. Therefore, C code cannot mutate any datetime.timedelta objects from python.</p>
<h1><a class="anchor" id="autotoc_md84"></a>
absl::Time</h1>
<p><code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> objects are converted to/from python datetime.datetime objects. Additionally, datetime.date objects can be converted to <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> objects. C code cannot mutate any datetime.datetime objects from python.</p>
<p>Python date objects effectively truncate the time to 0 (i.e., midnight). Python time objects are not supported because <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> would implicitly assume a year, which could be confusing.</p>
<h2><a class="anchor" id="autotoc_md85"></a>
Time zones</h2>
<p>Python <code>datetime</code> objects include timezone information, while <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> does not. When converting from Python to C++, if a timezone is specified then it will be used to determine the <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code> instant. If no timezone is specified by the Python <code>datetime</code> object, the local timezone is assumed.</p>
<p>When converting back from C++ to Python, the resultant time will be presented in the local timezone and the <code>tzinfo</code> property set on the <code>datetime</code> object to reflect that. This means that the caller may receive a datetime formatted in a different timezone to the one they passed in. To handle this safely, the caller should take care to check the <code>tzinfo</code> of any returned <code>datetime</code>s.</p>
<h1><a class="anchor" id="autotoc_md86"></a>
absl::CivilTime</h1>
<p><code>absl::CivilTime</code> objects are converted to/from Python datetime.datetime objects. Fractional Python datetime components are truncated when converting to less granular C++ types, and time zone information is ignored.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
absl::Span</h1>
<h2><a class="anchor" id="autotoc_md88"></a>
Loading</h2>
<p>Some python types can be loaded (Python-&gt;C++) without copying or converting the list, while some require copying/ converting the list. The non-converting load methods will be tried first, and, if the span elements are const, the converting load methods will be tried next.</p>
<p>Arguments cast to a span with <em>non-const</em> elements can never be copied/converted. To prevent an argument cast to a span with <em>const</em> elements from being copied or converted, mark it as <code>noconvert()</code> (see go/pybind11-non-converting-arguments).</p>
<p>The following python types can be loaded <em>without</em> copying or converting:</p>
<ul>
<li>Numpy array (or anything else that supports <a href="https://docs.python.org/3/c-api/buffer.htm">buffer protocol</a>) =&gt; <code>Span&lt;{const or non-const} T&gt;</code> if <em>all</em> of the following conditions are satisfied:<ul>
<li>The buffer is 1-D.</li>
<li>T is a numeric type.</li>
<li>The array dtype matches T exactly.</li>
<li>If T is not const, the buffer allows writing.</li>
<li>The stride does not indicate to skip elements or go in reverse order.</li>
</ul>
</li>
<li><a href="go/pybind11-opaque-types">Opaque</a> <code>std::vector&lt;T&gt;</code> =&gt; <code>Span&lt;{const or non-const} T&gt;</code>.<ul>
<li>T can be any type, including converted or pointer types, but must match exactly between C++ and python.</li>
<li>Opaque vectors are <em>not</em> currently compatible with the smart holder.</li>
</ul>
</li>
</ul>
<p>The following python types must be copied/converted to be loaded:</p>
<ul>
<li>Python sequence of elements that require conversion (numbers, strings, datetimes, etc) =&gt; <code>Span&lt;const T&gt;</code>.<ul>
<li>The elements will be copied/ converted, so that conversion must be legal.</li>
<li>T <em>cannot</em> be a pointer.</li>
</ul>
</li>
<li>Python sequence of elements that do <em>not</em> require conversion (ie, classes wrapped with py::class_) =&gt; <code>Span&lt;const T&gt;</code> (elements <em>will</em> be copied) or <code>Span&lt;{const or non-const} T* const&gt;</code> (elements will <em>not</em> be copied).</li>
</ul>
<p>Specifically, this conversion will <em>fail</em> if any of the following are true:</p>
<ul>
<li><code>noconvert()</code> was specified (see go/pybind11-non-converting-arguments).</li>
<li>The element conversion is not allowed (eg, floating point to integer).</li>
<li>The sequence is being loaded into a <code>Span&lt;{non-const} T&gt;</code> or <code>Span&lt;{const or non-const} T* {non-const}&gt;</code>.</li>
<li>The elements require conversion <em>and</em> the sequence is being loaded into a <code>Span&lt;T*&gt;</code> (regardless of any <code>const</code>s; the element caster which owns the converted value would be destroyed before <code>load</code> is complete, resulting in dangling references).</li>
<li>The span is nested (ie, <code><a class="el" href="classabsl_1_1_span.html">absl::Span</a>&lt;<a class="el" href="classabsl_1_1_span.html">absl::Span</a>&lt;T&gt;&gt;</code>, regardless of any <code>const</code>s).</li>
</ul>
<p>Note: These failure conditions only apply to <em>converted</em> python types.</p>
<h2><a class="anchor" id="autotoc_md89"></a>
Casting</h2>
<p>Spans are cast (C++-&gt;Python) with the standard list caster, which always converts the list. This could be changed in the future (eg, using <a href="https://pybind11.readthedocs.io/en/stable/advanced/pycpp/numpy.html#buffer-protocol">buffer protocol</a>) but generally using spans as return values is not recommended.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
absl::string_view</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::string_view</code>.</p>
<h1><a class="anchor" id="autotoc_md91"></a>
absl::optional</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::optional</code>.</p>
<h1><a class="anchor" id="autotoc_md92"></a>
absl::flat_hash_map and absl::btree_map</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::map</code>.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
absl::flat_hash_set</h1>
<p>Supported exactly the same way <a class="el" href="namespacepybind11.html">pybind11</a> supports <code>std::set</code>.</p>
<h1><a class="anchor" id="autotoc_md94"></a>
absl::Status[Or]</h1>
<p>To use the Status[Or] casters:</p>
<ol type="1">
<li>Include the header file <code><a class="el" href="status__casters_8h.html">pybind11_abseil/status_casters.h</a></code> in the .cc file with your bindings.</li>
</ol>
<ol type="1">
<li>Call <code><a class="el" href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule()</a>;</code> in your <code>PYBIND11_MODULE</code> definition.</li>
</ol>
<p>By default, an ok status will be converted into <code>None</code>, and a non-ok status will raise a <code>status.StatusNotOk</code> exception. This has a <code>status</code> attribute which can be used to access the status object and check the code/ message.</p>
<p>To get a <code>status.Status</code> object rather than having an exception thrown, pass either the <code>Status</code> object or a function returning a <code>Status</code> to <code><a class="el" href="namespacepybind11_1_1google.html#ae97c17c051dc7bdf1bb4fd8341e3dab8">pybind11::google::DoNotThrowStatus</a></code> before casting or binding. This works with references and pointers to <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> objects too.</p>
<p>It isn't possible to specify separate return value policies for a <code>StatusOr</code> object and its payload. Since <code>StatusOr</code> is processed and not ever actually represented in Python, the return value policy applies to the payload. E.g., if you return a StatusOr&lt;MyObject*&gt; (note the * is inside the <code>StatusOr</code>) with a take_ownership return val policy and the status is OK (i.e., it has a payload), Python will take ownership of that payload and free it when it is garbage collected.</p>
<p>However, if you return a <code>StatusOr&lt;MyObject&gt;*</code> (note: the <code>*</code> is outside the <code>StatusOr</code> rather than inside it now) with a <code>take_ownership</code> return val policy, Python does not take ownership of the <code>StatusOr</code> and will not free it (because again, that policy applies to <code>MyObject</code>, not <code>StatusOr</code>).</p>
<p>See <code>status_utils.cc</code> in this directory for details about what methods are available in wrapped <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> objects.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="status__casters_8h.html">pybind11_abseil/status_casters.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classabsl_1_1_status.html">absl::Status</a> StatusReturningFunction() {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="namespaceabsl.html#a0eae05137690e1e57dc9840e5a3cda92">absl::Status</a>(...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">pybind11::object StatusHandlingFunction() {</div>
<div class="line">  <span class="keywordflow">return</span> pybind11::cast(<a class="code hl_function" href="namespacepybind11_1_1google.html#ae97c17c051dc7bdf1bb4fd8341e3dab8">pybind11::google::DoNotThrowStatus</a>(StatusReturningFunction()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacepybind11_1_1google.html#a20dd5098a40cc581b16504071968a745">PYBIND11_MODULE</a>(test_bindings, m) {</div>
<div class="line">  <a class="code hl_function" href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule</a>();</div>
<div class="line"> </div>
<div class="line">  m.def(<span class="stringliteral">&quot;return_status&quot;</span>, &amp;StatusReturningFunction,</div>
<div class="line">        <span class="stringliteral">&quot;Return None if StatusCode is OK, otherwise raise an error.&quot;</span>);</div>
<div class="line">  m.def(<span class="stringliteral">&quot;make_status&quot;</span>, google::DoNotThrowStatus(&amp;StatusReturningFunction),</div>
<div class="line">        <span class="stringliteral">&quot;Return a wrapped status object without raising an error.&quot;</span>);</div>
<div class="line">  m.def(<span class="stringliteral">&quot;status_handling_function&quot;</span>, &amp;StatusHandlingFunction,</div>
<div class="line">        <span class="stringliteral">&quot;Same effect as make_status, but cast is done internally.&quot;</span>);</div>
<div class="line">};</div>
<div class="ttc" id="aclassabsl_1_1_status_html"><div class="ttname"><a href="classabsl_1_1_status.html">absl::Status</a></div><div class="ttdef"><b>Definition</b> <a href="status_8h_source.html#l00424">status.h:424</a></div></div>
<div class="ttc" id="anamespaceabsl_html_a0eae05137690e1e57dc9840e5a3cda92"><div class="ttname"><a href="namespaceabsl.html#a0eae05137690e1e57dc9840e5a3cda92">absl::Status</a></div><div class="ttdeci">ABSL_NAMESPACE_BEGIN class ABSL_MUST_USE_RESULT Status</div><div class="ttdef"><b>Definition</b> <a href="status__internal_8h_source.html#l00037">status_internal.h:37</a></div></div>
<div class="ttc" id="anamespacepybind11_1_1google_html_a20dd5098a40cc581b16504071968a745"><div class="ttname"><a href="namespacepybind11_1_1google.html#a20dd5098a40cc581b16504071968a745">pybind11::google::PYBIND11_MODULE</a></div><div class="ttdeci">PYBIND11_MODULE(status, m)</div><div class="ttdef"><b>Definition</b> <a href="pybind11__abseil_2pybind11__abseil_2status_8cc_source.html#l00008">status.cc:8</a></div></div>
<div class="ttc" id="anamespacepybind11_1_1google_html_a7e51f5be47ec8d1d31b1b3c4971d0f27"><div class="ttname"><a href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule</a></div><div class="ttdeci">module_ ImportStatusModule(bool bypass_regular_import)</div><div class="ttdef"><b>Definition</b> <a href="import__status__module_8cc_source.html#l00012">import_status_module.cc:12</a></div></div>
<div class="ttc" id="anamespacepybind11_1_1google_html_ae97c17c051dc7bdf1bb4fd8341e3dab8"><div class="ttname"><a href="namespacepybind11_1_1google.html#ae97c17c051dc7bdf1bb4fd8341e3dab8">pybind11::google::DoNotThrowStatus</a></div><div class="ttdeci">NoThrowStatus&lt; StatusType &gt; DoNotThrowStatus(StatusType status)</div><div class="ttdef"><b>Definition</b> <a href="no__throw__status_8h_source.html#l00026">no_throw_status.h:26</a></div></div>
<div class="ttc" id="astatus__casters_8h_html"><div class="ttname"><a href="status__casters_8h.html">status_casters.h</a></div></div>
</div><!-- fragment --><p>Python:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pybind11_abseil <span class="keyword">import</span> status</div>
<div class="line"><span class="keyword">import</span> test_bindings</div>
<div class="line"> </div>
<div class="line">my_status = make_status()</div>
<div class="line"><span class="keywordflow">if</span> my_status.code():</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">  return_status()</div>
<div class="line"><span class="keywordflow">except</span> status.StatusNotOk <span class="keyword">as</span> e:</div>
<div class="line">  print(e.status)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md95"></a>
absl::StatusOr</h2>
<p><code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> objects behave exactly like <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> objects, except:</p>
<ul>
<li>There is no support for passing StatusOr objects. You can only return them.</li>
<li>Instead of returning None or a wrapped status with OK, this casts and returns the payload when there is no error.</li>
</ul>
<p>As with <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code>, the default behavior is to throw an error when casting a non-ok status. You may pass a StatusOr object or StatusOr returning function to <code><a class="el" href="namespacepybind11_1_1google.html#ae97c17c051dc7bdf1bb4fd8341e3dab8">pybind11::google::DoNotThrowStatus</a></code> in exactly the same way as with <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> to change this behavior.</p>
<p><code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> objects must be returned by value (not reference or pointer). Why? Because the implementation takes advantage of the fact that python is a dynamically typed language to cast and return the payload <em>or</em> the <code><a class="el" href="classabsl_1_1_status.html">absl::Status</a></code> object (or raise an exeception). Python has no concept of a <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> object, so it's also impossible to apply the return_value_policy to a <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code>. Therefore returning a reference or pointer to a <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> is meaningless.</p>
<p>Pointers <em>can</em> be used as the payload type, and the return_value_policy will be applied to the payload if the status is OK. However, references cannot be used as the payload type, because that's a restriction on <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a></code> in general, not <a class="el" href="namespacepybind11.html">pybind11</a> (see <a href="https://yaqs/5903163345338368">https://yaqs/5903163345338368</a>).</p>
<p>This can handle any type of payload that pybind knows about. unique_ptrs (i.e., <code><a class="el" href="classabsl_1_1_status_or.html">absl::StatusOr</a>&lt;std::unique_ptr&lt;...&gt;&gt;</code>) to wrapped classes or structs (i.e., any type which you created bindings for using <code>pybind11::class_&lt;...&gt;</code>) can be used, but unique_ptrs to converted types (e.g., <code>int</code>, <code>string</code>, <code><a class="el" href="classabsl_1_1_time.html">absl::Time</a></code>, <code><a class="el" href="classabsl_1_1_duration.html">absl::Duration</a></code>, etc.) cannot be used.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
absl::StatusCode</h2>
<p>The <code>status</code> module provides <code>pybind11::enum_</code> bindings for <code><a class="el" href="namespaceabsl.html#a6928184af6359d080e561c3a78cce371">absl::StatusCode</a></code>. These use python constant style, e.g. <code>status.StatusCode.OK</code>, <code>status.StatusCode.CANCELLED</code>, etc.</p>
<p>Warning: Pybind enums are their own type, and will never compare equally to integers due to being a different type, regardless of their value. In particular, note that the <a href="http://google3/util/task/status.proto">status proto</a> <code>code</code> field is an integer, so it will never directly compare as equal to a <code>StatusCode</code>. To fix this, convert an integer to a <code>StatusCode</code> or vice-versa.</p>
<div class="fragment"><div class="line">status_code = 0  <span class="comment"># An integer.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> status_code == status.StatusCode.OK:  <span class="comment"># Wrong: always evaluates to false.</span></div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> status.StatusCode(status_code) == status.StatusCode.OK:  <span class="comment"># Correct.</span></div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> status_code == int(status.StatusCode.OK):  <span class="comment"># Also correct.</span></div>
<div class="line">  ...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md97"></a>
Aliasing parts of the status module</h2>
<p>The need to import the <code>status</code> module can be eliminated by aliasing the parts of the status module that are needed in your own module:</p>
<div class="fragment"><div class="line">PYBIND11_MODULE(test_bindings, m) {</div>
<div class="line">  <span class="keyword">auto</span> status_module = <a class="code hl_function" href="namespacepybind11_1_1google.html#a7e51f5be47ec8d1d31b1b3c4971d0f27">pybind11::google::ImportStatusModule</a>();</div>
<div class="line">  m.attr(<span class="stringliteral">&quot;StatusNotOk&quot;</span>) = status_module.attr(<span class="stringliteral">&quot;StatusNotOk&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Python:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> test_bindings</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">  return_status()</div>
<div class="line"><span class="keywordflow">except</span> test_bindings.StatusNotOk <span class="keyword">as</span> e:</div>
<div class="line">  print(e.status)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md98"></a>
Importing the status module</h2>
<p>The status module uses the same import mechansim as the proto module; see <a href="../pybind11_protobuf/README.md#importing-the-proto-module">its documentation</a> for details. For now there is a <code>#ifdef</code> to allow <code>ImportStatusModule</code> to work with python 2 rather than giving an error, but this will be removed eventually.</p>
<p>If modifying the following functions, make the same changes in the corresponding proto functions:</p><ul>
<li>ImportStatusModule</li>
<li>IsStatusModuleImported</li>
<li>CheckStatusModuleImported</li>
</ul>
<h2><a class="anchor" id="autotoc_md99"></a>
Use Outside of Google3</h2>
<p>The path used for the status module may be changed by altering the value of <code>PYBIND11_ABSEIL_STATUS_MODULE_PATH</code> defined in <code><a class="el" href="status__casters_8h.html">status_casters.h</a></code>. This uses the same mechanism as the proto module, so see <a href="../pybind11_protobuf/README.md?cl=head#use-outside-of-google3">its documentation</a> for details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
